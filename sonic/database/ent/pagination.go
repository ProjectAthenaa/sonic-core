// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/accountgroup"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/address"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/app"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/billing"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/calendar"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/checkout"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/device"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/license"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/metadata"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/product"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/profile"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/profilegroup"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/proxy"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/proxylist"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/release"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/session"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/settings"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/shipping"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/stripe"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/task"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/taskgroup"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/user"
	"github.com/arsmn/fastgql/graphql/errcode"
	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    uuid.UUID `msgpack:"i"`
	Value Value     `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func getCollectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	field := fc.Field

walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Name == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return getCollectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

// AccountGroupEdge is the edge representation of AccountGroup.
type AccountGroupEdge struct {
	Node   *AccountGroup `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// AccountGroupConnection is the connection containing edges to AccountGroup.
type AccountGroupConnection struct {
	Edges      []*AccountGroupEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

// AccountGroupPaginateOption enables pagination customization.
type AccountGroupPaginateOption func(*accountGroupPager) error

// WithAccountGroupOrder configures pagination ordering.
func WithAccountGroupOrder(order *AccountGroupOrder) AccountGroupPaginateOption {
	if order == nil {
		order = DefaultAccountGroupOrder
	}
	o := *order
	return func(pager *accountGroupPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAccountGroupOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAccountGroupFilter configures pagination filter.
func WithAccountGroupFilter(filter func(*AccountGroupQuery) (*AccountGroupQuery, error)) AccountGroupPaginateOption {
	return func(pager *accountGroupPager) error {
		if filter == nil {
			return errors.New("AccountGroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type accountGroupPager struct {
	order  *AccountGroupOrder
	filter func(*AccountGroupQuery) (*AccountGroupQuery, error)
}

func newAccountGroupPager(opts []AccountGroupPaginateOption) (*accountGroupPager, error) {
	pager := &accountGroupPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAccountGroupOrder
	}
	return pager, nil
}

func (p *accountGroupPager) applyFilter(query *AccountGroupQuery) (*AccountGroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *accountGroupPager) toCursor(ag *AccountGroup) Cursor {
	return p.order.Field.toCursor(ag)
}

func (p *accountGroupPager) applyCursors(query *AccountGroupQuery, after, before *Cursor) *AccountGroupQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAccountGroupOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *accountGroupPager) applyOrder(query *AccountGroupQuery, reverse bool) *AccountGroupQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAccountGroupOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAccountGroupOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to AccountGroup.
func (ag *AccountGroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AccountGroupPaginateOption,
) (*AccountGroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAccountGroupPager(opts)
	if err != nil {
		return nil, err
	}

	if ag, err = pager.applyFilter(ag); err != nil {
		return nil, err
	}

	conn := &AccountGroupConnection{Edges: []*AccountGroupEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ag.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := ag.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ag = pager.applyCursors(ag, after, before)
	ag = pager.applyOrder(ag, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ag = ag.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ag = ag.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ag.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *AccountGroup
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AccountGroup {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AccountGroup {
			return nodes[i]
		}
	}

	conn.Edges = make([]*AccountGroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &AccountGroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// AccountGroupOrderField defines the ordering field of AccountGroup.
type AccountGroupOrderField struct {
	field    string
	toCursor func(*AccountGroup) Cursor
}

// AccountGroupOrder defines the ordering of AccountGroup.
type AccountGroupOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *AccountGroupOrderField `json:"field"`
}

// DefaultAccountGroupOrder is the default ordering of AccountGroup.
var DefaultAccountGroupOrder = &AccountGroupOrder{
	Direction: OrderDirectionAsc,
	Field: &AccountGroupOrderField{
		field: accountgroup.FieldID,
		toCursor: func(ag *AccountGroup) Cursor {
			return Cursor{ID: ag.ID}
		},
	},
}

// ToEdge converts AccountGroup into AccountGroupEdge.
func (ag *AccountGroup) ToEdge(order *AccountGroupOrder) *AccountGroupEdge {
	if order == nil {
		order = DefaultAccountGroupOrder
	}
	return &AccountGroupEdge{
		Node:   ag,
		Cursor: order.Field.toCursor(ag),
	}
}

// AddressEdge is the edge representation of Address.
type AddressEdge struct {
	Node   *Address `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// AddressConnection is the connection containing edges to Address.
type AddressConnection struct {
	Edges      []*AddressEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// AddressPaginateOption enables pagination customization.
type AddressPaginateOption func(*addressPager) error

// WithAddressOrder configures pagination ordering.
func WithAddressOrder(order *AddressOrder) AddressPaginateOption {
	if order == nil {
		order = DefaultAddressOrder
	}
	o := *order
	return func(pager *addressPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAddressOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAddressFilter configures pagination filter.
func WithAddressFilter(filter func(*AddressQuery) (*AddressQuery, error)) AddressPaginateOption {
	return func(pager *addressPager) error {
		if filter == nil {
			return errors.New("AddressQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type addressPager struct {
	order  *AddressOrder
	filter func(*AddressQuery) (*AddressQuery, error)
}

func newAddressPager(opts []AddressPaginateOption) (*addressPager, error) {
	pager := &addressPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAddressOrder
	}
	return pager, nil
}

func (p *addressPager) applyFilter(query *AddressQuery) (*AddressQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *addressPager) toCursor(a *Address) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *addressPager) applyCursors(query *AddressQuery, after, before *Cursor) *AddressQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAddressOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *addressPager) applyOrder(query *AddressQuery, reverse bool) *AddressQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAddressOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAddressOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Address.
func (a *AddressQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AddressPaginateOption,
) (*AddressConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAddressPager(opts)
	if err != nil {
		return nil, err
	}

	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}

	conn := &AddressConnection{Edges: []*AddressEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := a.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := a.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	a = pager.applyCursors(a, after, before)
	a = pager.applyOrder(a, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		a = a.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		a = a.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := a.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Address
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Address {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Address {
			return nodes[i]
		}
	}

	conn.Edges = make([]*AddressEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &AddressEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// AddressOrderField defines the ordering field of Address.
type AddressOrderField struct {
	field    string
	toCursor func(*Address) Cursor
}

// AddressOrder defines the ordering of Address.
type AddressOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *AddressOrderField `json:"field"`
}

// DefaultAddressOrder is the default ordering of Address.
var DefaultAddressOrder = &AddressOrder{
	Direction: OrderDirectionAsc,
	Field: &AddressOrderField{
		field: address.FieldID,
		toCursor: func(a *Address) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Address into AddressEdge.
func (a *Address) ToEdge(order *AddressOrder) *AddressEdge {
	if order == nil {
		order = DefaultAddressOrder
	}
	return &AddressEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// AppEdge is the edge representation of App.
type AppEdge struct {
	Node   *App   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// AppConnection is the connection containing edges to App.
type AppConnection struct {
	Edges      []*AppEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

// AppPaginateOption enables pagination customization.
type AppPaginateOption func(*appPager) error

// WithAppOrder configures pagination ordering.
func WithAppOrder(order *AppOrder) AppPaginateOption {
	if order == nil {
		order = DefaultAppOrder
	}
	o := *order
	return func(pager *appPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAppOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAppFilter configures pagination filter.
func WithAppFilter(filter func(*AppQuery) (*AppQuery, error)) AppPaginateOption {
	return func(pager *appPager) error {
		if filter == nil {
			return errors.New("AppQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type appPager struct {
	order  *AppOrder
	filter func(*AppQuery) (*AppQuery, error)
}

func newAppPager(opts []AppPaginateOption) (*appPager, error) {
	pager := &appPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAppOrder
	}
	return pager, nil
}

func (p *appPager) applyFilter(query *AppQuery) (*AppQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *appPager) toCursor(a *App) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *appPager) applyCursors(query *AppQuery, after, before *Cursor) *AppQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultAppOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *appPager) applyOrder(query *AppQuery, reverse bool) *AppQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultAppOrder.Field {
		query = query.Order(direction.orderFunc(DefaultAppOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to App.
func (a *AppQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AppPaginateOption,
) (*AppConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAppPager(opts)
	if err != nil {
		return nil, err
	}

	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}

	conn := &AppConnection{Edges: []*AppEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := a.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := a.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	a = pager.applyCursors(a, after, before)
	a = pager.applyOrder(a, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		a = a.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		a = a.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := a.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *App
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *App {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *App {
			return nodes[i]
		}
	}

	conn.Edges = make([]*AppEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &AppEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// AppOrderField defines the ordering field of App.
type AppOrderField struct {
	field    string
	toCursor func(*App) Cursor
}

// AppOrder defines the ordering of App.
type AppOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *AppOrderField `json:"field"`
}

// DefaultAppOrder is the default ordering of App.
var DefaultAppOrder = &AppOrder{
	Direction: OrderDirectionAsc,
	Field: &AppOrderField{
		field: app.FieldID,
		toCursor: func(a *App) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts App into AppEdge.
func (a *App) ToEdge(order *AppOrder) *AppEdge {
	if order == nil {
		order = DefaultAppOrder
	}
	return &AppEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// BillingEdge is the edge representation of Billing.
type BillingEdge struct {
	Node   *Billing `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// BillingConnection is the connection containing edges to Billing.
type BillingConnection struct {
	Edges      []*BillingEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// BillingPaginateOption enables pagination customization.
type BillingPaginateOption func(*billingPager) error

// WithBillingOrder configures pagination ordering.
func WithBillingOrder(order *BillingOrder) BillingPaginateOption {
	if order == nil {
		order = DefaultBillingOrder
	}
	o := *order
	return func(pager *billingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBillingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBillingFilter configures pagination filter.
func WithBillingFilter(filter func(*BillingQuery) (*BillingQuery, error)) BillingPaginateOption {
	return func(pager *billingPager) error {
		if filter == nil {
			return errors.New("BillingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type billingPager struct {
	order  *BillingOrder
	filter func(*BillingQuery) (*BillingQuery, error)
}

func newBillingPager(opts []BillingPaginateOption) (*billingPager, error) {
	pager := &billingPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBillingOrder
	}
	return pager, nil
}

func (p *billingPager) applyFilter(query *BillingQuery) (*BillingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *billingPager) toCursor(b *Billing) Cursor {
	return p.order.Field.toCursor(b)
}

func (p *billingPager) applyCursors(query *BillingQuery, after, before *Cursor) *BillingQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultBillingOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *billingPager) applyOrder(query *BillingQuery, reverse bool) *BillingQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultBillingOrder.Field {
		query = query.Order(direction.orderFunc(DefaultBillingOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Billing.
func (b *BillingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BillingPaginateOption,
) (*BillingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBillingPager(opts)
	if err != nil {
		return nil, err
	}

	if b, err = pager.applyFilter(b); err != nil {
		return nil, err
	}

	conn := &BillingConnection{Edges: []*BillingEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := b.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := b.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	b = pager.applyCursors(b, after, before)
	b = pager.applyOrder(b, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		b = b.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		b = b.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := b.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Billing
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Billing {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Billing {
			return nodes[i]
		}
	}

	conn.Edges = make([]*BillingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &BillingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// BillingOrderField defines the ordering field of Billing.
type BillingOrderField struct {
	field    string
	toCursor func(*Billing) Cursor
}

// BillingOrder defines the ordering of Billing.
type BillingOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *BillingOrderField `json:"field"`
}

// DefaultBillingOrder is the default ordering of Billing.
var DefaultBillingOrder = &BillingOrder{
	Direction: OrderDirectionAsc,
	Field: &BillingOrderField{
		field: billing.FieldID,
		toCursor: func(b *Billing) Cursor {
			return Cursor{ID: b.ID}
		},
	},
}

// ToEdge converts Billing into BillingEdge.
func (b *Billing) ToEdge(order *BillingOrder) *BillingEdge {
	if order == nil {
		order = DefaultBillingOrder
	}
	return &BillingEdge{
		Node:   b,
		Cursor: order.Field.toCursor(b),
	}
}

// CalendarEdge is the edge representation of Calendar.
type CalendarEdge struct {
	Node   *Calendar `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// CalendarConnection is the connection containing edges to Calendar.
type CalendarConnection struct {
	Edges      []*CalendarEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// CalendarPaginateOption enables pagination customization.
type CalendarPaginateOption func(*calendarPager) error

// WithCalendarOrder configures pagination ordering.
func WithCalendarOrder(order *CalendarOrder) CalendarPaginateOption {
	if order == nil {
		order = DefaultCalendarOrder
	}
	o := *order
	return func(pager *calendarPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCalendarOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCalendarFilter configures pagination filter.
func WithCalendarFilter(filter func(*CalendarQuery) (*CalendarQuery, error)) CalendarPaginateOption {
	return func(pager *calendarPager) error {
		if filter == nil {
			return errors.New("CalendarQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type calendarPager struct {
	order  *CalendarOrder
	filter func(*CalendarQuery) (*CalendarQuery, error)
}

func newCalendarPager(opts []CalendarPaginateOption) (*calendarPager, error) {
	pager := &calendarPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCalendarOrder
	}
	return pager, nil
}

func (p *calendarPager) applyFilter(query *CalendarQuery) (*CalendarQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *calendarPager) toCursor(c *Calendar) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *calendarPager) applyCursors(query *CalendarQuery, after, before *Cursor) *CalendarQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCalendarOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *calendarPager) applyOrder(query *CalendarQuery, reverse bool) *CalendarQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCalendarOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCalendarOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Calendar.
func (c *CalendarQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CalendarPaginateOption,
) (*CalendarConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCalendarPager(opts)
	if err != nil {
		return nil, err
	}

	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}

	conn := &CalendarConnection{Edges: []*CalendarEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := c.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := c.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		c = c.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		c = c.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := c.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Calendar
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Calendar {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Calendar {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CalendarEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CalendarEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// CalendarOrderField defines the ordering field of Calendar.
type CalendarOrderField struct {
	field    string
	toCursor func(*Calendar) Cursor
}

// CalendarOrder defines the ordering of Calendar.
type CalendarOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *CalendarOrderField `json:"field"`
}

// DefaultCalendarOrder is the default ordering of Calendar.
var DefaultCalendarOrder = &CalendarOrder{
	Direction: OrderDirectionAsc,
	Field: &CalendarOrderField{
		field: calendar.FieldID,
		toCursor: func(c *Calendar) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Calendar into CalendarEdge.
func (c *Calendar) ToEdge(order *CalendarOrder) *CalendarEdge {
	if order == nil {
		order = DefaultCalendarOrder
	}
	return &CalendarEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CheckoutEdge is the edge representation of Checkout.
type CheckoutEdge struct {
	Node   *Checkout `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// CheckoutConnection is the connection containing edges to Checkout.
type CheckoutConnection struct {
	Edges      []*CheckoutEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// CheckoutPaginateOption enables pagination customization.
type CheckoutPaginateOption func(*checkoutPager) error

// WithCheckoutOrder configures pagination ordering.
func WithCheckoutOrder(order *CheckoutOrder) CheckoutPaginateOption {
	if order == nil {
		order = DefaultCheckoutOrder
	}
	o := *order
	return func(pager *checkoutPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCheckoutOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCheckoutFilter configures pagination filter.
func WithCheckoutFilter(filter func(*CheckoutQuery) (*CheckoutQuery, error)) CheckoutPaginateOption {
	return func(pager *checkoutPager) error {
		if filter == nil {
			return errors.New("CheckoutQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type checkoutPager struct {
	order  *CheckoutOrder
	filter func(*CheckoutQuery) (*CheckoutQuery, error)
}

func newCheckoutPager(opts []CheckoutPaginateOption) (*checkoutPager, error) {
	pager := &checkoutPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCheckoutOrder
	}
	return pager, nil
}

func (p *checkoutPager) applyFilter(query *CheckoutQuery) (*CheckoutQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *checkoutPager) toCursor(c *Checkout) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *checkoutPager) applyCursors(query *CheckoutQuery, after, before *Cursor) *CheckoutQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCheckoutOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *checkoutPager) applyOrder(query *CheckoutQuery, reverse bool) *CheckoutQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCheckoutOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCheckoutOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Checkout.
func (c *CheckoutQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CheckoutPaginateOption,
) (*CheckoutConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCheckoutPager(opts)
	if err != nil {
		return nil, err
	}

	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}

	conn := &CheckoutConnection{Edges: []*CheckoutEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := c.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := c.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		c = c.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		c = c.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := c.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Checkout
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Checkout {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Checkout {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CheckoutEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CheckoutEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// CheckoutOrderField defines the ordering field of Checkout.
type CheckoutOrderField struct {
	field    string
	toCursor func(*Checkout) Cursor
}

// CheckoutOrder defines the ordering of Checkout.
type CheckoutOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *CheckoutOrderField `json:"field"`
}

// DefaultCheckoutOrder is the default ordering of Checkout.
var DefaultCheckoutOrder = &CheckoutOrder{
	Direction: OrderDirectionAsc,
	Field: &CheckoutOrderField{
		field: checkout.FieldID,
		toCursor: func(c *Checkout) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Checkout into CheckoutEdge.
func (c *Checkout) ToEdge(order *CheckoutOrder) *CheckoutEdge {
	if order == nil {
		order = DefaultCheckoutOrder
	}
	return &CheckoutEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// DeviceEdge is the edge representation of Device.
type DeviceEdge struct {
	Node   *Device `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// DeviceConnection is the connection containing edges to Device.
type DeviceConnection struct {
	Edges      []*DeviceEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

// DevicePaginateOption enables pagination customization.
type DevicePaginateOption func(*devicePager) error

// WithDeviceOrder configures pagination ordering.
func WithDeviceOrder(order *DeviceOrder) DevicePaginateOption {
	if order == nil {
		order = DefaultDeviceOrder
	}
	o := *order
	return func(pager *devicePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDeviceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDeviceFilter configures pagination filter.
func WithDeviceFilter(filter func(*DeviceQuery) (*DeviceQuery, error)) DevicePaginateOption {
	return func(pager *devicePager) error {
		if filter == nil {
			return errors.New("DeviceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type devicePager struct {
	order  *DeviceOrder
	filter func(*DeviceQuery) (*DeviceQuery, error)
}

func newDevicePager(opts []DevicePaginateOption) (*devicePager, error) {
	pager := &devicePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDeviceOrder
	}
	return pager, nil
}

func (p *devicePager) applyFilter(query *DeviceQuery) (*DeviceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *devicePager) toCursor(d *Device) Cursor {
	return p.order.Field.toCursor(d)
}

func (p *devicePager) applyCursors(query *DeviceQuery, after, before *Cursor) *DeviceQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultDeviceOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *devicePager) applyOrder(query *DeviceQuery, reverse bool) *DeviceQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultDeviceOrder.Field {
		query = query.Order(direction.orderFunc(DefaultDeviceOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Device.
func (d *DeviceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DevicePaginateOption,
) (*DeviceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDevicePager(opts)
	if err != nil {
		return nil, err
	}

	if d, err = pager.applyFilter(d); err != nil {
		return nil, err
	}

	conn := &DeviceConnection{Edges: []*DeviceEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := d.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := d.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	d = pager.applyCursors(d, after, before)
	d = pager.applyOrder(d, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		d = d.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		d = d.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := d.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Device
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Device {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Device {
			return nodes[i]
		}
	}

	conn.Edges = make([]*DeviceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &DeviceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// DeviceOrderField defines the ordering field of Device.
type DeviceOrderField struct {
	field    string
	toCursor func(*Device) Cursor
}

// DeviceOrder defines the ordering of Device.
type DeviceOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *DeviceOrderField `json:"field"`
}

// DefaultDeviceOrder is the default ordering of Device.
var DefaultDeviceOrder = &DeviceOrder{
	Direction: OrderDirectionAsc,
	Field: &DeviceOrderField{
		field: device.FieldID,
		toCursor: func(d *Device) Cursor {
			return Cursor{ID: d.ID}
		},
	},
}

// ToEdge converts Device into DeviceEdge.
func (d *Device) ToEdge(order *DeviceOrder) *DeviceEdge {
	if order == nil {
		order = DefaultDeviceOrder
	}
	return &DeviceEdge{
		Node:   d,
		Cursor: order.Field.toCursor(d),
	}
}

// LicenseEdge is the edge representation of License.
type LicenseEdge struct {
	Node   *License `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// LicenseConnection is the connection containing edges to License.
type LicenseConnection struct {
	Edges      []*LicenseEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// LicensePaginateOption enables pagination customization.
type LicensePaginateOption func(*licensePager) error

// WithLicenseOrder configures pagination ordering.
func WithLicenseOrder(order *LicenseOrder) LicensePaginateOption {
	if order == nil {
		order = DefaultLicenseOrder
	}
	o := *order
	return func(pager *licensePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLicenseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLicenseFilter configures pagination filter.
func WithLicenseFilter(filter func(*LicenseQuery) (*LicenseQuery, error)) LicensePaginateOption {
	return func(pager *licensePager) error {
		if filter == nil {
			return errors.New("LicenseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type licensePager struct {
	order  *LicenseOrder
	filter func(*LicenseQuery) (*LicenseQuery, error)
}

func newLicensePager(opts []LicensePaginateOption) (*licensePager, error) {
	pager := &licensePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLicenseOrder
	}
	return pager, nil
}

func (p *licensePager) applyFilter(query *LicenseQuery) (*LicenseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *licensePager) toCursor(l *License) Cursor {
	return p.order.Field.toCursor(l)
}

func (p *licensePager) applyCursors(query *LicenseQuery, after, before *Cursor) *LicenseQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultLicenseOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *licensePager) applyOrder(query *LicenseQuery, reverse bool) *LicenseQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultLicenseOrder.Field {
		query = query.Order(direction.orderFunc(DefaultLicenseOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to License.
func (l *LicenseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LicensePaginateOption,
) (*LicenseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLicensePager(opts)
	if err != nil {
		return nil, err
	}

	if l, err = pager.applyFilter(l); err != nil {
		return nil, err
	}

	conn := &LicenseConnection{Edges: []*LicenseEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := l.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := l.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	l = pager.applyCursors(l, after, before)
	l = pager.applyOrder(l, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		l = l.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		l = l.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := l.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *License
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *License {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *License {
			return nodes[i]
		}
	}

	conn.Edges = make([]*LicenseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &LicenseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// LicenseOrderField defines the ordering field of License.
type LicenseOrderField struct {
	field    string
	toCursor func(*License) Cursor
}

// LicenseOrder defines the ordering of License.
type LicenseOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *LicenseOrderField `json:"field"`
}

// DefaultLicenseOrder is the default ordering of License.
var DefaultLicenseOrder = &LicenseOrder{
	Direction: OrderDirectionAsc,
	Field: &LicenseOrderField{
		field: license.FieldID,
		toCursor: func(l *License) Cursor {
			return Cursor{ID: l.ID}
		},
	},
}

// ToEdge converts License into LicenseEdge.
func (l *License) ToEdge(order *LicenseOrder) *LicenseEdge {
	if order == nil {
		order = DefaultLicenseOrder
	}
	return &LicenseEdge{
		Node:   l,
		Cursor: order.Field.toCursor(l),
	}
}

// MetadataEdge is the edge representation of Metadata.
type MetadataEdge struct {
	Node   *Metadata `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// MetadataConnection is the connection containing edges to Metadata.
type MetadataConnection struct {
	Edges      []*MetadataEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// MetadataPaginateOption enables pagination customization.
type MetadataPaginateOption func(*metadataPager) error

// WithMetadataOrder configures pagination ordering.
func WithMetadataOrder(order *MetadataOrder) MetadataPaginateOption {
	if order == nil {
		order = DefaultMetadataOrder
	}
	o := *order
	return func(pager *metadataPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultMetadataOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithMetadataFilter configures pagination filter.
func WithMetadataFilter(filter func(*MetadataQuery) (*MetadataQuery, error)) MetadataPaginateOption {
	return func(pager *metadataPager) error {
		if filter == nil {
			return errors.New("MetadataQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type metadataPager struct {
	order  *MetadataOrder
	filter func(*MetadataQuery) (*MetadataQuery, error)
}

func newMetadataPager(opts []MetadataPaginateOption) (*metadataPager, error) {
	pager := &metadataPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultMetadataOrder
	}
	return pager, nil
}

func (p *metadataPager) applyFilter(query *MetadataQuery) (*MetadataQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *metadataPager) toCursor(m *Metadata) Cursor {
	return p.order.Field.toCursor(m)
}

func (p *metadataPager) applyCursors(query *MetadataQuery, after, before *Cursor) *MetadataQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultMetadataOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *metadataPager) applyOrder(query *MetadataQuery, reverse bool) *MetadataQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultMetadataOrder.Field {
		query = query.Order(direction.orderFunc(DefaultMetadataOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Metadata.
func (m *MetadataQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...MetadataPaginateOption,
) (*MetadataConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newMetadataPager(opts)
	if err != nil {
		return nil, err
	}

	if m, err = pager.applyFilter(m); err != nil {
		return nil, err
	}

	conn := &MetadataConnection{Edges: []*MetadataEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := m.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := m.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	m = pager.applyCursors(m, after, before)
	m = pager.applyOrder(m, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		m = m.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		m = m.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := m.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Metadata
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Metadata {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Metadata {
			return nodes[i]
		}
	}

	conn.Edges = make([]*MetadataEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &MetadataEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// MetadataOrderField defines the ordering field of Metadata.
type MetadataOrderField struct {
	field    string
	toCursor func(*Metadata) Cursor
}

// MetadataOrder defines the ordering of Metadata.
type MetadataOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *MetadataOrderField `json:"field"`
}

// DefaultMetadataOrder is the default ordering of Metadata.
var DefaultMetadataOrder = &MetadataOrder{
	Direction: OrderDirectionAsc,
	Field: &MetadataOrderField{
		field: metadata.FieldID,
		toCursor: func(m *Metadata) Cursor {
			return Cursor{ID: m.ID}
		},
	},
}

// ToEdge converts Metadata into MetadataEdge.
func (m *Metadata) ToEdge(order *MetadataOrder) *MetadataEdge {
	if order == nil {
		order = DefaultMetadataOrder
	}
	return &MetadataEdge{
		Node:   m,
		Cursor: order.Field.toCursor(m),
	}
}

// ProductEdge is the edge representation of Product.
type ProductEdge struct {
	Node   *Product `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProductConnection is the connection containing edges to Product.
type ProductConnection struct {
	Edges      []*ProductEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// ProductPaginateOption enables pagination customization.
type ProductPaginateOption func(*productPager) error

// WithProductOrder configures pagination ordering.
func WithProductOrder(order *ProductOrder) ProductPaginateOption {
	if order == nil {
		order = DefaultProductOrder
	}
	o := *order
	return func(pager *productPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProductOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProductFilter configures pagination filter.
func WithProductFilter(filter func(*ProductQuery) (*ProductQuery, error)) ProductPaginateOption {
	return func(pager *productPager) error {
		if filter == nil {
			return errors.New("ProductQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type productPager struct {
	order  *ProductOrder
	filter func(*ProductQuery) (*ProductQuery, error)
}

func newProductPager(opts []ProductPaginateOption) (*productPager, error) {
	pager := &productPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProductOrder
	}
	return pager, nil
}

func (p *productPager) applyFilter(query *ProductQuery) (*ProductQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *productPager) toCursor(pr *Product) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *productPager) applyCursors(query *ProductQuery, after, before *Cursor) *ProductQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultProductOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *productPager) applyOrder(query *ProductQuery, reverse bool) *ProductQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultProductOrder.Field {
		query = query.Order(direction.orderFunc(DefaultProductOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Product.
func (pr *ProductQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProductPaginateOption,
) (*ProductConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProductPager(opts)
	if err != nil {
		return nil, err
	}

	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}

	conn := &ProductConnection{Edges: []*ProductEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pr.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := pr.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pr = pager.applyCursors(pr, after, before)
	pr = pager.applyOrder(pr, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pr = pr.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pr = pr.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pr.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Product
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Product {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Product {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ProductEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ProductEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ProductOrderField defines the ordering field of Product.
type ProductOrderField struct {
	field    string
	toCursor func(*Product) Cursor
}

// ProductOrder defines the ordering of Product.
type ProductOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProductOrderField `json:"field"`
}

// DefaultProductOrder is the default ordering of Product.
var DefaultProductOrder = &ProductOrder{
	Direction: OrderDirectionAsc,
	Field: &ProductOrderField{
		field: product.FieldID,
		toCursor: func(pr *Product) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Product into ProductEdge.
func (pr *Product) ToEdge(order *ProductOrder) *ProductEdge {
	if order == nil {
		order = DefaultProductOrder
	}
	return &ProductEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProfileEdge is the edge representation of Profile.
type ProfileEdge struct {
	Node   *Profile `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProfileConnection is the connection containing edges to Profile.
type ProfileConnection struct {
	Edges      []*ProfileEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// ProfilePaginateOption enables pagination customization.
type ProfilePaginateOption func(*profilePager) error

// WithProfileOrder configures pagination ordering.
func WithProfileOrder(order *ProfileOrder) ProfilePaginateOption {
	if order == nil {
		order = DefaultProfileOrder
	}
	o := *order
	return func(pager *profilePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProfileOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProfileFilter configures pagination filter.
func WithProfileFilter(filter func(*ProfileQuery) (*ProfileQuery, error)) ProfilePaginateOption {
	return func(pager *profilePager) error {
		if filter == nil {
			return errors.New("ProfileQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type profilePager struct {
	order  *ProfileOrder
	filter func(*ProfileQuery) (*ProfileQuery, error)
}

func newProfilePager(opts []ProfilePaginateOption) (*profilePager, error) {
	pager := &profilePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProfileOrder
	}
	return pager, nil
}

func (p *profilePager) applyFilter(query *ProfileQuery) (*ProfileQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *profilePager) toCursor(pr *Profile) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *profilePager) applyCursors(query *ProfileQuery, after, before *Cursor) *ProfileQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultProfileOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *profilePager) applyOrder(query *ProfileQuery, reverse bool) *ProfileQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultProfileOrder.Field {
		query = query.Order(direction.orderFunc(DefaultProfileOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Profile.
func (pr *ProfileQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProfilePaginateOption,
) (*ProfileConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProfilePager(opts)
	if err != nil {
		return nil, err
	}

	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}

	conn := &ProfileConnection{Edges: []*ProfileEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pr.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := pr.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pr = pager.applyCursors(pr, after, before)
	pr = pager.applyOrder(pr, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pr = pr.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pr = pr.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pr.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Profile
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Profile {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Profile {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ProfileEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ProfileEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ProfileOrderField defines the ordering field of Profile.
type ProfileOrderField struct {
	field    string
	toCursor func(*Profile) Cursor
}

// ProfileOrder defines the ordering of Profile.
type ProfileOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProfileOrderField `json:"field"`
}

// DefaultProfileOrder is the default ordering of Profile.
var DefaultProfileOrder = &ProfileOrder{
	Direction: OrderDirectionAsc,
	Field: &ProfileOrderField{
		field: profile.FieldID,
		toCursor: func(pr *Profile) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Profile into ProfileEdge.
func (pr *Profile) ToEdge(order *ProfileOrder) *ProfileEdge {
	if order == nil {
		order = DefaultProfileOrder
	}
	return &ProfileEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProfileGroupEdge is the edge representation of ProfileGroup.
type ProfileGroupEdge struct {
	Node   *ProfileGroup `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// ProfileGroupConnection is the connection containing edges to ProfileGroup.
type ProfileGroupConnection struct {
	Edges      []*ProfileGroupEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

// ProfileGroupPaginateOption enables pagination customization.
type ProfileGroupPaginateOption func(*profileGroupPager) error

// WithProfileGroupOrder configures pagination ordering.
func WithProfileGroupOrder(order *ProfileGroupOrder) ProfileGroupPaginateOption {
	if order == nil {
		order = DefaultProfileGroupOrder
	}
	o := *order
	return func(pager *profileGroupPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProfileGroupOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProfileGroupFilter configures pagination filter.
func WithProfileGroupFilter(filter func(*ProfileGroupQuery) (*ProfileGroupQuery, error)) ProfileGroupPaginateOption {
	return func(pager *profileGroupPager) error {
		if filter == nil {
			return errors.New("ProfileGroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type profileGroupPager struct {
	order  *ProfileGroupOrder
	filter func(*ProfileGroupQuery) (*ProfileGroupQuery, error)
}

func newProfileGroupPager(opts []ProfileGroupPaginateOption) (*profileGroupPager, error) {
	pager := &profileGroupPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProfileGroupOrder
	}
	return pager, nil
}

func (p *profileGroupPager) applyFilter(query *ProfileGroupQuery) (*ProfileGroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *profileGroupPager) toCursor(pg *ProfileGroup) Cursor {
	return p.order.Field.toCursor(pg)
}

func (p *profileGroupPager) applyCursors(query *ProfileGroupQuery, after, before *Cursor) *ProfileGroupQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultProfileGroupOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *profileGroupPager) applyOrder(query *ProfileGroupQuery, reverse bool) *ProfileGroupQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultProfileGroupOrder.Field {
		query = query.Order(direction.orderFunc(DefaultProfileGroupOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ProfileGroup.
func (pg *ProfileGroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProfileGroupPaginateOption,
) (*ProfileGroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProfileGroupPager(opts)
	if err != nil {
		return nil, err
	}

	if pg, err = pager.applyFilter(pg); err != nil {
		return nil, err
	}

	conn := &ProfileGroupConnection{Edges: []*ProfileGroupEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pg.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := pg.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pg = pager.applyCursors(pg, after, before)
	pg = pager.applyOrder(pg, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pg = pg.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pg = pg.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pg.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ProfileGroup
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProfileGroup {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProfileGroup {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ProfileGroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ProfileGroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ProfileGroupOrderField defines the ordering field of ProfileGroup.
type ProfileGroupOrderField struct {
	field    string
	toCursor func(*ProfileGroup) Cursor
}

// ProfileGroupOrder defines the ordering of ProfileGroup.
type ProfileGroupOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *ProfileGroupOrderField `json:"field"`
}

// DefaultProfileGroupOrder is the default ordering of ProfileGroup.
var DefaultProfileGroupOrder = &ProfileGroupOrder{
	Direction: OrderDirectionAsc,
	Field: &ProfileGroupOrderField{
		field: profilegroup.FieldID,
		toCursor: func(pg *ProfileGroup) Cursor {
			return Cursor{ID: pg.ID}
		},
	},
}

// ToEdge converts ProfileGroup into ProfileGroupEdge.
func (pg *ProfileGroup) ToEdge(order *ProfileGroupOrder) *ProfileGroupEdge {
	if order == nil {
		order = DefaultProfileGroupOrder
	}
	return &ProfileGroupEdge{
		Node:   pg,
		Cursor: order.Field.toCursor(pg),
	}
}

// ProxyEdge is the edge representation of Proxy.
type ProxyEdge struct {
	Node   *Proxy `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ProxyConnection is the connection containing edges to Proxy.
type ProxyConnection struct {
	Edges      []*ProxyEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

// ProxyPaginateOption enables pagination customization.
type ProxyPaginateOption func(*proxyPager) error

// WithProxyOrder configures pagination ordering.
func WithProxyOrder(order *ProxyOrder) ProxyPaginateOption {
	if order == nil {
		order = DefaultProxyOrder
	}
	o := *order
	return func(pager *proxyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProxyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProxyFilter configures pagination filter.
func WithProxyFilter(filter func(*ProxyQuery) (*ProxyQuery, error)) ProxyPaginateOption {
	return func(pager *proxyPager) error {
		if filter == nil {
			return errors.New("ProxyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type proxyPager struct {
	order  *ProxyOrder
	filter func(*ProxyQuery) (*ProxyQuery, error)
}

func newProxyPager(opts []ProxyPaginateOption) (*proxyPager, error) {
	pager := &proxyPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProxyOrder
	}
	return pager, nil
}

func (p *proxyPager) applyFilter(query *ProxyQuery) (*ProxyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *proxyPager) toCursor(pr *Proxy) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *proxyPager) applyCursors(query *ProxyQuery, after, before *Cursor) *ProxyQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultProxyOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *proxyPager) applyOrder(query *ProxyQuery, reverse bool) *ProxyQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultProxyOrder.Field {
		query = query.Order(direction.orderFunc(DefaultProxyOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Proxy.
func (pr *ProxyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProxyPaginateOption,
) (*ProxyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProxyPager(opts)
	if err != nil {
		return nil, err
	}

	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}

	conn := &ProxyConnection{Edges: []*ProxyEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pr.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := pr.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pr = pager.applyCursors(pr, after, before)
	pr = pager.applyOrder(pr, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pr = pr.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pr = pr.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pr.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Proxy
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Proxy {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Proxy {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ProxyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ProxyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ProxyOrderField defines the ordering field of Proxy.
type ProxyOrderField struct {
	field    string
	toCursor func(*Proxy) Cursor
}

// ProxyOrder defines the ordering of Proxy.
type ProxyOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *ProxyOrderField `json:"field"`
}

// DefaultProxyOrder is the default ordering of Proxy.
var DefaultProxyOrder = &ProxyOrder{
	Direction: OrderDirectionAsc,
	Field: &ProxyOrderField{
		field: proxy.FieldID,
		toCursor: func(pr *Proxy) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Proxy into ProxyEdge.
func (pr *Proxy) ToEdge(order *ProxyOrder) *ProxyEdge {
	if order == nil {
		order = DefaultProxyOrder
	}
	return &ProxyEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProxyListEdge is the edge representation of ProxyList.
type ProxyListEdge struct {
	Node   *ProxyList `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// ProxyListConnection is the connection containing edges to ProxyList.
type ProxyListConnection struct {
	Edges      []*ProxyListEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// ProxyListPaginateOption enables pagination customization.
type ProxyListPaginateOption func(*proxyListPager) error

// WithProxyListOrder configures pagination ordering.
func WithProxyListOrder(order *ProxyListOrder) ProxyListPaginateOption {
	if order == nil {
		order = DefaultProxyListOrder
	}
	o := *order
	return func(pager *proxyListPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProxyListOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProxyListFilter configures pagination filter.
func WithProxyListFilter(filter func(*ProxyListQuery) (*ProxyListQuery, error)) ProxyListPaginateOption {
	return func(pager *proxyListPager) error {
		if filter == nil {
			return errors.New("ProxyListQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type proxyListPager struct {
	order  *ProxyListOrder
	filter func(*ProxyListQuery) (*ProxyListQuery, error)
}

func newProxyListPager(opts []ProxyListPaginateOption) (*proxyListPager, error) {
	pager := &proxyListPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProxyListOrder
	}
	return pager, nil
}

func (p *proxyListPager) applyFilter(query *ProxyListQuery) (*ProxyListQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *proxyListPager) toCursor(pl *ProxyList) Cursor {
	return p.order.Field.toCursor(pl)
}

func (p *proxyListPager) applyCursors(query *ProxyListQuery, after, before *Cursor) *ProxyListQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultProxyListOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *proxyListPager) applyOrder(query *ProxyListQuery, reverse bool) *ProxyListQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultProxyListOrder.Field {
		query = query.Order(direction.orderFunc(DefaultProxyListOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to ProxyList.
func (pl *ProxyListQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProxyListPaginateOption,
) (*ProxyListConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProxyListPager(opts)
	if err != nil {
		return nil, err
	}

	if pl, err = pager.applyFilter(pl); err != nil {
		return nil, err
	}

	conn := &ProxyListConnection{Edges: []*ProxyListEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := pl.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := pl.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	pl = pager.applyCursors(pl, after, before)
	pl = pager.applyOrder(pl, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		pl = pl.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		pl = pl.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := pl.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *ProxyList
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProxyList {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProxyList {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ProxyListEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ProxyListEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ProxyListOrderField defines the ordering field of ProxyList.
type ProxyListOrderField struct {
	field    string
	toCursor func(*ProxyList) Cursor
}

// ProxyListOrder defines the ordering of ProxyList.
type ProxyListOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *ProxyListOrderField `json:"field"`
}

// DefaultProxyListOrder is the default ordering of ProxyList.
var DefaultProxyListOrder = &ProxyListOrder{
	Direction: OrderDirectionAsc,
	Field: &ProxyListOrderField{
		field: proxylist.FieldID,
		toCursor: func(pl *ProxyList) Cursor {
			return Cursor{ID: pl.ID}
		},
	},
}

// ToEdge converts ProxyList into ProxyListEdge.
func (pl *ProxyList) ToEdge(order *ProxyListOrder) *ProxyListEdge {
	if order == nil {
		order = DefaultProxyListOrder
	}
	return &ProxyListEdge{
		Node:   pl,
		Cursor: order.Field.toCursor(pl),
	}
}

// ReleaseEdge is the edge representation of Release.
type ReleaseEdge struct {
	Node   *Release `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ReleaseConnection is the connection containing edges to Release.
type ReleaseConnection struct {
	Edges      []*ReleaseEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// ReleasePaginateOption enables pagination customization.
type ReleasePaginateOption func(*releasePager) error

// WithReleaseOrder configures pagination ordering.
func WithReleaseOrder(order *ReleaseOrder) ReleasePaginateOption {
	if order == nil {
		order = DefaultReleaseOrder
	}
	o := *order
	return func(pager *releasePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReleaseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReleaseFilter configures pagination filter.
func WithReleaseFilter(filter func(*ReleaseQuery) (*ReleaseQuery, error)) ReleasePaginateOption {
	return func(pager *releasePager) error {
		if filter == nil {
			return errors.New("ReleaseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type releasePager struct {
	order  *ReleaseOrder
	filter func(*ReleaseQuery) (*ReleaseQuery, error)
}

func newReleasePager(opts []ReleasePaginateOption) (*releasePager, error) {
	pager := &releasePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReleaseOrder
	}
	return pager, nil
}

func (p *releasePager) applyFilter(query *ReleaseQuery) (*ReleaseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *releasePager) toCursor(r *Release) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *releasePager) applyCursors(query *ReleaseQuery, after, before *Cursor) *ReleaseQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultReleaseOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *releasePager) applyOrder(query *ReleaseQuery, reverse bool) *ReleaseQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultReleaseOrder.Field {
		query = query.Order(direction.orderFunc(DefaultReleaseOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Release.
func (r *ReleaseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReleasePaginateOption,
) (*ReleaseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReleasePager(opts)
	if err != nil {
		return nil, err
	}

	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}

	conn := &ReleaseConnection{Edges: []*ReleaseEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := r.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := r.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	r = pager.applyCursors(r, after, before)
	r = pager.applyOrder(r, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		r = r.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		r = r.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := r.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Release
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Release {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Release {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ReleaseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ReleaseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ReleaseOrderField defines the ordering field of Release.
type ReleaseOrderField struct {
	field    string
	toCursor func(*Release) Cursor
}

// ReleaseOrder defines the ordering of Release.
type ReleaseOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ReleaseOrderField `json:"field"`
}

// DefaultReleaseOrder is the default ordering of Release.
var DefaultReleaseOrder = &ReleaseOrder{
	Direction: OrderDirectionAsc,
	Field: &ReleaseOrderField{
		field: release.FieldID,
		toCursor: func(r *Release) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Release into ReleaseEdge.
func (r *Release) ToEdge(order *ReleaseOrder) *ReleaseEdge {
	if order == nil {
		order = DefaultReleaseOrder
	}
	return &ReleaseEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// SessionEdge is the edge representation of Session.
type SessionEdge struct {
	Node   *Session `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// SessionConnection is the connection containing edges to Session.
type SessionConnection struct {
	Edges      []*SessionEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// SessionPaginateOption enables pagination customization.
type SessionPaginateOption func(*sessionPager) error

// WithSessionOrder configures pagination ordering.
func WithSessionOrder(order *SessionOrder) SessionPaginateOption {
	if order == nil {
		order = DefaultSessionOrder
	}
	o := *order
	return func(pager *sessionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSessionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSessionFilter configures pagination filter.
func WithSessionFilter(filter func(*SessionQuery) (*SessionQuery, error)) SessionPaginateOption {
	return func(pager *sessionPager) error {
		if filter == nil {
			return errors.New("SessionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type sessionPager struct {
	order  *SessionOrder
	filter func(*SessionQuery) (*SessionQuery, error)
}

func newSessionPager(opts []SessionPaginateOption) (*sessionPager, error) {
	pager := &sessionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSessionOrder
	}
	return pager, nil
}

func (p *sessionPager) applyFilter(query *SessionQuery) (*SessionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *sessionPager) toCursor(s *Session) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *sessionPager) applyCursors(query *SessionQuery, after, before *Cursor) *SessionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultSessionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *sessionPager) applyOrder(query *SessionQuery, reverse bool) *SessionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultSessionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultSessionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Session.
func (s *SessionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SessionPaginateOption,
) (*SessionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSessionPager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}

	conn := &SessionConnection{Edges: []*SessionEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := s.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := s.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		s = s.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		s = s.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := s.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Session
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Session {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Session {
			return nodes[i]
		}
	}

	conn.Edges = make([]*SessionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &SessionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// SessionOrderField defines the ordering field of Session.
type SessionOrderField struct {
	field    string
	toCursor func(*Session) Cursor
}

// SessionOrder defines the ordering of Session.
type SessionOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *SessionOrderField `json:"field"`
}

// DefaultSessionOrder is the default ordering of Session.
var DefaultSessionOrder = &SessionOrder{
	Direction: OrderDirectionAsc,
	Field: &SessionOrderField{
		field: session.FieldID,
		toCursor: func(s *Session) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Session into SessionEdge.
func (s *Session) ToEdge(order *SessionOrder) *SessionEdge {
	if order == nil {
		order = DefaultSessionOrder
	}
	return &SessionEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// SettingsEdge is the edge representation of Settings.
type SettingsEdge struct {
	Node   *Settings `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// SettingsConnection is the connection containing edges to Settings.
type SettingsConnection struct {
	Edges      []*SettingsEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// SettingsPaginateOption enables pagination customization.
type SettingsPaginateOption func(*settingsPager) error

// WithSettingsOrder configures pagination ordering.
func WithSettingsOrder(order *SettingsOrder) SettingsPaginateOption {
	if order == nil {
		order = DefaultSettingsOrder
	}
	o := *order
	return func(pager *settingsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSettingsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSettingsFilter configures pagination filter.
func WithSettingsFilter(filter func(*SettingsQuery) (*SettingsQuery, error)) SettingsPaginateOption {
	return func(pager *settingsPager) error {
		if filter == nil {
			return errors.New("SettingsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type settingsPager struct {
	order  *SettingsOrder
	filter func(*SettingsQuery) (*SettingsQuery, error)
}

func newSettingsPager(opts []SettingsPaginateOption) (*settingsPager, error) {
	pager := &settingsPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSettingsOrder
	}
	return pager, nil
}

func (p *settingsPager) applyFilter(query *SettingsQuery) (*SettingsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *settingsPager) toCursor(s *Settings) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *settingsPager) applyCursors(query *SettingsQuery, after, before *Cursor) *SettingsQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultSettingsOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *settingsPager) applyOrder(query *SettingsQuery, reverse bool) *SettingsQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultSettingsOrder.Field {
		query = query.Order(direction.orderFunc(DefaultSettingsOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Settings.
func (s *SettingsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SettingsPaginateOption,
) (*SettingsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSettingsPager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}

	conn := &SettingsConnection{Edges: []*SettingsEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := s.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := s.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		s = s.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		s = s.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := s.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Settings
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Settings {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Settings {
			return nodes[i]
		}
	}

	conn.Edges = make([]*SettingsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &SettingsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// SettingsOrderField defines the ordering field of Settings.
type SettingsOrderField struct {
	field    string
	toCursor func(*Settings) Cursor
}

// SettingsOrder defines the ordering of Settings.
type SettingsOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *SettingsOrderField `json:"field"`
}

// DefaultSettingsOrder is the default ordering of Settings.
var DefaultSettingsOrder = &SettingsOrder{
	Direction: OrderDirectionAsc,
	Field: &SettingsOrderField{
		field: settings.FieldID,
		toCursor: func(s *Settings) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Settings into SettingsEdge.
func (s *Settings) ToEdge(order *SettingsOrder) *SettingsEdge {
	if order == nil {
		order = DefaultSettingsOrder
	}
	return &SettingsEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// ShippingEdge is the edge representation of Shipping.
type ShippingEdge struct {
	Node   *Shipping `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ShippingConnection is the connection containing edges to Shipping.
type ShippingConnection struct {
	Edges      []*ShippingEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// ShippingPaginateOption enables pagination customization.
type ShippingPaginateOption func(*shippingPager) error

// WithShippingOrder configures pagination ordering.
func WithShippingOrder(order *ShippingOrder) ShippingPaginateOption {
	if order == nil {
		order = DefaultShippingOrder
	}
	o := *order
	return func(pager *shippingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShippingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShippingFilter configures pagination filter.
func WithShippingFilter(filter func(*ShippingQuery) (*ShippingQuery, error)) ShippingPaginateOption {
	return func(pager *shippingPager) error {
		if filter == nil {
			return errors.New("ShippingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shippingPager struct {
	order  *ShippingOrder
	filter func(*ShippingQuery) (*ShippingQuery, error)
}

func newShippingPager(opts []ShippingPaginateOption) (*shippingPager, error) {
	pager := &shippingPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShippingOrder
	}
	return pager, nil
}

func (p *shippingPager) applyFilter(query *ShippingQuery) (*ShippingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shippingPager) toCursor(s *Shipping) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *shippingPager) applyCursors(query *ShippingQuery, after, before *Cursor) *ShippingQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultShippingOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *shippingPager) applyOrder(query *ShippingQuery, reverse bool) *ShippingQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultShippingOrder.Field {
		query = query.Order(direction.orderFunc(DefaultShippingOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Shipping.
func (s *ShippingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShippingPaginateOption,
) (*ShippingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShippingPager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}

	conn := &ShippingConnection{Edges: []*ShippingEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := s.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := s.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		s = s.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		s = s.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := s.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Shipping
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Shipping {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Shipping {
			return nodes[i]
		}
	}

	conn.Edges = make([]*ShippingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &ShippingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// ShippingOrderField defines the ordering field of Shipping.
type ShippingOrderField struct {
	field    string
	toCursor func(*Shipping) Cursor
}

// ShippingOrder defines the ordering of Shipping.
type ShippingOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ShippingOrderField `json:"field"`
}

// DefaultShippingOrder is the default ordering of Shipping.
var DefaultShippingOrder = &ShippingOrder{
	Direction: OrderDirectionAsc,
	Field: &ShippingOrderField{
		field: shipping.FieldID,
		toCursor: func(s *Shipping) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Shipping into ShippingEdge.
func (s *Shipping) ToEdge(order *ShippingOrder) *ShippingEdge {
	if order == nil {
		order = DefaultShippingOrder
	}
	return &ShippingEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// StripeEdge is the edge representation of Stripe.
type StripeEdge struct {
	Node   *Stripe `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// StripeConnection is the connection containing edges to Stripe.
type StripeConnection struct {
	Edges      []*StripeEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

// StripePaginateOption enables pagination customization.
type StripePaginateOption func(*stripePager) error

// WithStripeOrder configures pagination ordering.
func WithStripeOrder(order *StripeOrder) StripePaginateOption {
	if order == nil {
		order = DefaultStripeOrder
	}
	o := *order
	return func(pager *stripePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultStripeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithStripeFilter configures pagination filter.
func WithStripeFilter(filter func(*StripeQuery) (*StripeQuery, error)) StripePaginateOption {
	return func(pager *stripePager) error {
		if filter == nil {
			return errors.New("StripeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type stripePager struct {
	order  *StripeOrder
	filter func(*StripeQuery) (*StripeQuery, error)
}

func newStripePager(opts []StripePaginateOption) (*stripePager, error) {
	pager := &stripePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultStripeOrder
	}
	return pager, nil
}

func (p *stripePager) applyFilter(query *StripeQuery) (*StripeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *stripePager) toCursor(s *Stripe) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *stripePager) applyCursors(query *StripeQuery, after, before *Cursor) *StripeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultStripeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *stripePager) applyOrder(query *StripeQuery, reverse bool) *StripeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultStripeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultStripeOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Stripe.
func (s *StripeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...StripePaginateOption,
) (*StripeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newStripePager(opts)
	if err != nil {
		return nil, err
	}

	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}

	conn := &StripeConnection{Edges: []*StripeEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := s.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := s.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	s = pager.applyCursors(s, after, before)
	s = pager.applyOrder(s, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		s = s.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		s = s.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := s.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Stripe
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Stripe {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Stripe {
			return nodes[i]
		}
	}

	conn.Edges = make([]*StripeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &StripeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// StripeOrderField defines the ordering field of Stripe.
type StripeOrderField struct {
	field    string
	toCursor func(*Stripe) Cursor
}

// StripeOrder defines the ordering of Stripe.
type StripeOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *StripeOrderField `json:"field"`
}

// DefaultStripeOrder is the default ordering of Stripe.
var DefaultStripeOrder = &StripeOrder{
	Direction: OrderDirectionAsc,
	Field: &StripeOrderField{
		field: stripe.FieldID,
		toCursor: func(s *Stripe) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Stripe into StripeEdge.
func (s *Stripe) ToEdge(order *StripeOrder) *StripeEdge {
	if order == nil {
		order = DefaultStripeOrder
	}
	return &StripeEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// TaskEdge is the edge representation of Task.
type TaskEdge struct {
	Node   *Task  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TaskConnection is the connection containing edges to Task.
type TaskConnection struct {
	Edges      []*TaskEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// TaskPaginateOption enables pagination customization.
type TaskPaginateOption func(*taskPager) error

// WithTaskOrder configures pagination ordering.
func WithTaskOrder(order *TaskOrder) TaskPaginateOption {
	if order == nil {
		order = DefaultTaskOrder
	}
	o := *order
	return func(pager *taskPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTaskOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTaskFilter configures pagination filter.
func WithTaskFilter(filter func(*TaskQuery) (*TaskQuery, error)) TaskPaginateOption {
	return func(pager *taskPager) error {
		if filter == nil {
			return errors.New("TaskQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type taskPager struct {
	order  *TaskOrder
	filter func(*TaskQuery) (*TaskQuery, error)
}

func newTaskPager(opts []TaskPaginateOption) (*taskPager, error) {
	pager := &taskPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTaskOrder
	}
	return pager, nil
}

func (p *taskPager) applyFilter(query *TaskQuery) (*TaskQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *taskPager) toCursor(t *Task) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *taskPager) applyCursors(query *TaskQuery, after, before *Cursor) *TaskQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTaskOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *taskPager) applyOrder(query *TaskQuery, reverse bool) *TaskQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTaskOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTaskOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Task.
func (t *TaskQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TaskPaginateOption,
) (*TaskConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTaskPager(opts)
	if err != nil {
		return nil, err
	}

	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}

	conn := &TaskConnection{Edges: []*TaskEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := t.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := t.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	t = pager.applyCursors(t, after, before)
	t = pager.applyOrder(t, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		t = t.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		t = t.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := t.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Task
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Task {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Task {
			return nodes[i]
		}
	}

	conn.Edges = make([]*TaskEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &TaskEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// TaskOrderField defines the ordering field of Task.
type TaskOrderField struct {
	field    string
	toCursor func(*Task) Cursor
}

// TaskOrder defines the ordering of Task.
type TaskOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *TaskOrderField `json:"field"`
}

// DefaultTaskOrder is the default ordering of Task.
var DefaultTaskOrder = &TaskOrder{
	Direction: OrderDirectionAsc,
	Field: &TaskOrderField{
		field: task.FieldID,
		toCursor: func(t *Task) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Task into TaskEdge.
func (t *Task) ToEdge(order *TaskOrder) *TaskEdge {
	if order == nil {
		order = DefaultTaskOrder
	}
	return &TaskEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// TaskGroupEdge is the edge representation of TaskGroup.
type TaskGroupEdge struct {
	Node   *TaskGroup `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// TaskGroupConnection is the connection containing edges to TaskGroup.
type TaskGroupConnection struct {
	Edges      []*TaskGroupEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// TaskGroupPaginateOption enables pagination customization.
type TaskGroupPaginateOption func(*taskGroupPager) error

// WithTaskGroupOrder configures pagination ordering.
func WithTaskGroupOrder(order *TaskGroupOrder) TaskGroupPaginateOption {
	if order == nil {
		order = DefaultTaskGroupOrder
	}
	o := *order
	return func(pager *taskGroupPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTaskGroupOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTaskGroupFilter configures pagination filter.
func WithTaskGroupFilter(filter func(*TaskGroupQuery) (*TaskGroupQuery, error)) TaskGroupPaginateOption {
	return func(pager *taskGroupPager) error {
		if filter == nil {
			return errors.New("TaskGroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type taskGroupPager struct {
	order  *TaskGroupOrder
	filter func(*TaskGroupQuery) (*TaskGroupQuery, error)
}

func newTaskGroupPager(opts []TaskGroupPaginateOption) (*taskGroupPager, error) {
	pager := &taskGroupPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTaskGroupOrder
	}
	return pager, nil
}

func (p *taskGroupPager) applyFilter(query *TaskGroupQuery) (*TaskGroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *taskGroupPager) toCursor(tg *TaskGroup) Cursor {
	return p.order.Field.toCursor(tg)
}

func (p *taskGroupPager) applyCursors(query *TaskGroupQuery, after, before *Cursor) *TaskGroupQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultTaskGroupOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *taskGroupPager) applyOrder(query *TaskGroupQuery, reverse bool) *TaskGroupQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultTaskGroupOrder.Field {
		query = query.Order(direction.orderFunc(DefaultTaskGroupOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to TaskGroup.
func (tg *TaskGroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TaskGroupPaginateOption,
) (*TaskGroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTaskGroupPager(opts)
	if err != nil {
		return nil, err
	}

	if tg, err = pager.applyFilter(tg); err != nil {
		return nil, err
	}

	conn := &TaskGroupConnection{Edges: []*TaskGroupEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := tg.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := tg.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	tg = pager.applyCursors(tg, after, before)
	tg = pager.applyOrder(tg, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		tg = tg.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		tg = tg.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := tg.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *TaskGroup
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TaskGroup {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TaskGroup {
			return nodes[i]
		}
	}

	conn.Edges = make([]*TaskGroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &TaskGroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// TaskGroupOrderField defines the ordering field of TaskGroup.
type TaskGroupOrderField struct {
	field    string
	toCursor func(*TaskGroup) Cursor
}

// TaskGroupOrder defines the ordering of TaskGroup.
type TaskGroupOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *TaskGroupOrderField `json:"field"`
}

// DefaultTaskGroupOrder is the default ordering of TaskGroup.
var DefaultTaskGroupOrder = &TaskGroupOrder{
	Direction: OrderDirectionAsc,
	Field: &TaskGroupOrderField{
		field: taskgroup.FieldID,
		toCursor: func(tg *TaskGroup) Cursor {
			return Cursor{ID: tg.ID}
		},
	},
}

// ToEdge converts TaskGroup into TaskGroupEdge.
func (tg *TaskGroup) ToEdge(order *TaskGroupOrder) *TaskGroupEdge {
	if order == nil {
		order = DefaultTaskGroupOrder
	}
	return &TaskGroupEdge{
		Node:   tg,
		Cursor: order.Field.toCursor(tg),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	order  *UserOrder
	filter func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption) (*userPager, error) {
	pager := &userPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) *UserQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUserOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *userPager) applyOrder(query *UserQuery, reverse bool) *UserQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUserOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts)
	if err != nil {
		return nil, err
	}

	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}

	conn := &UserConnection{Edges: []*UserEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := u.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := u.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	u = pager.applyCursors(u, after, before)
	u = pager.applyOrder(u, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		u = u.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		u = u.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := u.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}

	conn.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	field    string
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: OrderDirectionAsc,
	Field: &UserOrderField{
		field: user.FieldID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}
