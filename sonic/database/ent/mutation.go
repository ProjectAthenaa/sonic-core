// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/ProjectAthenaa/sonic-core/sonic"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/accountgroup"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/address"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/app"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/billing"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/license"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/predicate"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/product"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/profile"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/profilegroup"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/proxy"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/proxylist"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/settings"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/shipping"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/statistic"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/stripe"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/task"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/taskgroup"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/user"
	"github.com/google/uuid"
	"github.com/lib/pq"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccountGroup = "AccountGroup"
	TypeAddress      = "Address"
	TypeApp          = "App"
	TypeBilling      = "Billing"
	TypeLicense      = "License"
	TypeProduct      = "Product"
	TypeProfile      = "Profile"
	TypeProfileGroup = "ProfileGroup"
	TypeProxy        = "Proxy"
	TypeProxyList    = "ProxyList"
	TypeSettings     = "Settings"
	TypeShipping     = "Shipping"
	TypeStatistic    = "Statistic"
	TypeStripe       = "Stripe"
	TypeTask         = "Task"
	TypeTaskGroup    = "TaskGroup"
	TypeUser         = "User"
)

// AccountGroupMutation represents an operation that mutates the AccountGroup nodes in the graph.
type AccountGroupMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	_Name         *string
	_Site         *accountgroup.Site
	_Accounts     *sonic.Map
	clearedFields map[string]struct{}
	_App          *uuid.UUID
	cleared_App   bool
	done          bool
	oldValue      func(context.Context) (*AccountGroup, error)
	predicates    []predicate.AccountGroup
}

var _ ent.Mutation = (*AccountGroupMutation)(nil)

// accountgroupOption allows management of the mutation configuration using functional options.
type accountgroupOption func(*AccountGroupMutation)

// newAccountGroupMutation creates new mutation for the AccountGroup entity.
func newAccountGroupMutation(c config, op Op, opts ...accountgroupOption) *AccountGroupMutation {
	m := &AccountGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountGroupID sets the ID field of the mutation.
func withAccountGroupID(id uuid.UUID) accountgroupOption {
	return func(m *AccountGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountGroup
		)
		m.oldValue = func(ctx context.Context) (*AccountGroup, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountGroup sets the old AccountGroup of the mutation.
func withAccountGroup(node *AccountGroup) accountgroupOption {
	return func(m *AccountGroupMutation) {
		m.oldValue = func(context.Context) (*AccountGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccountGroup entities.
func (m *AccountGroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AccountGroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccountGroup entity.
// If the AccountGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AccountGroup entity.
// If the AccountGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "Name" field.
func (m *AccountGroupMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *AccountGroupMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the AccountGroup entity.
// If the AccountGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *AccountGroupMutation) ResetName() {
	m._Name = nil
}

// SetSite sets the "Site" field.
func (m *AccountGroupMutation) SetSite(a accountgroup.Site) {
	m._Site = &a
}

// Site returns the value of the "Site" field in the mutation.
func (m *AccountGroupMutation) Site() (r accountgroup.Site, exists bool) {
	v := m._Site
	if v == nil {
		return
	}
	return *v, true
}

// OldSite returns the old "Site" field's value of the AccountGroup entity.
// If the AccountGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountGroupMutation) OldSite(ctx context.Context) (v accountgroup.Site, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSite: %w", err)
	}
	return oldValue.Site, nil
}

// ResetSite resets all changes to the "Site" field.
func (m *AccountGroupMutation) ResetSite() {
	m._Site = nil
}

// SetAccounts sets the "Accounts" field.
func (m *AccountGroupMutation) SetAccounts(s sonic.Map) {
	m._Accounts = &s
}

// Accounts returns the value of the "Accounts" field in the mutation.
func (m *AccountGroupMutation) Accounts() (r sonic.Map, exists bool) {
	v := m._Accounts
	if v == nil {
		return
	}
	return *v, true
}

// OldAccounts returns the old "Accounts" field's value of the AccountGroup entity.
// If the AccountGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountGroupMutation) OldAccounts(ctx context.Context) (v sonic.Map, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccounts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccounts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccounts: %w", err)
	}
	return oldValue.Accounts, nil
}

// ResetAccounts resets all changes to the "Accounts" field.
func (m *AccountGroupMutation) ResetAccounts() {
	m._Accounts = nil
}

// SetAppID sets the "App" edge to the App entity by id.
func (m *AccountGroupMutation) SetAppID(id uuid.UUID) {
	m._App = &id
}

// ClearApp clears the "App" edge to the App entity.
func (m *AccountGroupMutation) ClearApp() {
	m.cleared_App = true
}

// AppCleared reports if the "App" edge to the App entity was cleared.
func (m *AccountGroupMutation) AppCleared() bool {
	return m.cleared_App
}

// AppID returns the "App" edge ID in the mutation.
func (m *AccountGroupMutation) AppID() (id uuid.UUID, exists bool) {
	if m._App != nil {
		return *m._App, true
	}
	return
}

// AppIDs returns the "App" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AccountGroupMutation) AppIDs() (ids []uuid.UUID) {
	if id := m._App; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "App" edge.
func (m *AccountGroupMutation) ResetApp() {
	m._App = nil
	m.cleared_App = false
}

// Op returns the operation name.
func (m *AccountGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AccountGroup).
func (m *AccountGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountGroupMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, accountgroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, accountgroup.FieldUpdatedAt)
	}
	if m._Name != nil {
		fields = append(fields, accountgroup.FieldName)
	}
	if m._Site != nil {
		fields = append(fields, accountgroup.FieldSite)
	}
	if m._Accounts != nil {
		fields = append(fields, accountgroup.FieldAccounts)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountgroup.FieldCreatedAt:
		return m.CreatedAt()
	case accountgroup.FieldUpdatedAt:
		return m.UpdatedAt()
	case accountgroup.FieldName:
		return m.Name()
	case accountgroup.FieldSite:
		return m.Site()
	case accountgroup.FieldAccounts:
		return m.Accounts()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountgroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accountgroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case accountgroup.FieldName:
		return m.OldName(ctx)
	case accountgroup.FieldSite:
		return m.OldSite(ctx)
	case accountgroup.FieldAccounts:
		return m.OldAccounts(ctx)
	}
	return nil, fmt.Errorf("unknown AccountGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accountgroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case accountgroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case accountgroup.FieldSite:
		v, ok := value.(accountgroup.Site)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSite(v)
		return nil
	case accountgroup.FieldAccounts:
		v, ok := value.(sonic.Map)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccounts(v)
		return nil
	}
	return fmt.Errorf("unknown AccountGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AccountGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccountGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountGroupMutation) ResetField(name string) error {
	switch name {
	case accountgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accountgroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case accountgroup.FieldName:
		m.ResetName()
		return nil
	case accountgroup.FieldSite:
		m.ResetSite()
		return nil
	case accountgroup.FieldAccounts:
		m.ResetAccounts()
		return nil
	}
	return fmt.Errorf("unknown AccountGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._App != nil {
		edges = append(edges, accountgroup.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountgroup.EdgeApp:
		if id := m._App; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_App {
		edges = append(edges, accountgroup.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case accountgroup.EdgeApp:
		return m.cleared_App
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountGroupMutation) ClearEdge(name string) error {
	switch name {
	case accountgroup.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AccountGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountGroupMutation) ResetEdge(name string) error {
	switch name {
	case accountgroup.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown AccountGroup edge %s", name)
}

// AddressMutation represents an operation that mutates the Address nodes in the graph.
type AddressMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *time.Time
	updated_at              *time.Time
	_AddressLine            *string
	_AddressLine2           *string
	_Country                *string
	_State                  *string
	_City                   *string
	_ZIP                    *string
	clearedFields           map[string]struct{}
	_ShippingAddress        map[uuid.UUID]struct{}
	removed_ShippingAddress map[uuid.UUID]struct{}
	cleared_ShippingAddress bool
	_BillingAddress         map[uuid.UUID]struct{}
	removed_BillingAddress  map[uuid.UUID]struct{}
	cleared_BillingAddress  bool
	done                    bool
	oldValue                func(context.Context) (*Address, error)
	predicates              []predicate.Address
}

var _ ent.Mutation = (*AddressMutation)(nil)

// addressOption allows management of the mutation configuration using functional options.
type addressOption func(*AddressMutation)

// newAddressMutation creates new mutation for the Address entity.
func newAddressMutation(c config, op Op, opts ...addressOption) *AddressMutation {
	m := &AddressMutation{
		config:        c,
		op:            op,
		typ:           TypeAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddressID sets the ID field of the mutation.
func withAddressID(id uuid.UUID) addressOption {
	return func(m *AddressMutation) {
		var (
			err   error
			once  sync.Once
			value *Address
		)
		m.oldValue = func(ctx context.Context) (*Address, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Address.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddress sets the old Address of the mutation.
func withAddress(node *Address) addressOption {
	return func(m *AddressMutation) {
		m.oldValue = func(context.Context) (*Address, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Address entities.
func (m *AddressMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AddressMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *AddressMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AddressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AddressMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AddressMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AddressMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AddressMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAddressLine sets the "AddressLine" field.
func (m *AddressMutation) SetAddressLine(s string) {
	m._AddressLine = &s
}

// AddressLine returns the value of the "AddressLine" field in the mutation.
func (m *AddressMutation) AddressLine() (r string, exists bool) {
	v := m._AddressLine
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressLine returns the old "AddressLine" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldAddressLine(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddressLine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddressLine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressLine: %w", err)
	}
	return oldValue.AddressLine, nil
}

// ResetAddressLine resets all changes to the "AddressLine" field.
func (m *AddressMutation) ResetAddressLine() {
	m._AddressLine = nil
}

// SetAddressLine2 sets the "AddressLine2" field.
func (m *AddressMutation) SetAddressLine2(s string) {
	m._AddressLine2 = &s
}

// AddressLine2 returns the value of the "AddressLine2" field in the mutation.
func (m *AddressMutation) AddressLine2() (r string, exists bool) {
	v := m._AddressLine2
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressLine2 returns the old "AddressLine2" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldAddressLine2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddressLine2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddressLine2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressLine2: %w", err)
	}
	return oldValue.AddressLine2, nil
}

// ClearAddressLine2 clears the value of the "AddressLine2" field.
func (m *AddressMutation) ClearAddressLine2() {
	m._AddressLine2 = nil
	m.clearedFields[address.FieldAddressLine2] = struct{}{}
}

// AddressLine2Cleared returns if the "AddressLine2" field was cleared in this mutation.
func (m *AddressMutation) AddressLine2Cleared() bool {
	_, ok := m.clearedFields[address.FieldAddressLine2]
	return ok
}

// ResetAddressLine2 resets all changes to the "AddressLine2" field.
func (m *AddressMutation) ResetAddressLine2() {
	m._AddressLine2 = nil
	delete(m.clearedFields, address.FieldAddressLine2)
}

// SetCountry sets the "Country" field.
func (m *AddressMutation) SetCountry(s string) {
	m._Country = &s
}

// Country returns the value of the "Country" field in the mutation.
func (m *AddressMutation) Country() (r string, exists bool) {
	v := m._Country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "Country" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "Country" field.
func (m *AddressMutation) ResetCountry() {
	m._Country = nil
}

// SetState sets the "State" field.
func (m *AddressMutation) SetState(s string) {
	m._State = &s
}

// State returns the value of the "State" field in the mutation.
func (m *AddressMutation) State() (r string, exists bool) {
	v := m._State
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "State" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "State" field.
func (m *AddressMutation) ResetState() {
	m._State = nil
}

// SetCity sets the "City" field.
func (m *AddressMutation) SetCity(s string) {
	m._City = &s
}

// City returns the value of the "City" field in the mutation.
func (m *AddressMutation) City() (r string, exists bool) {
	v := m._City
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "City" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "City" field.
func (m *AddressMutation) ResetCity() {
	m._City = nil
}

// SetZIP sets the "ZIP" field.
func (m *AddressMutation) SetZIP(s string) {
	m._ZIP = &s
}

// ZIP returns the value of the "ZIP" field in the mutation.
func (m *AddressMutation) ZIP() (r string, exists bool) {
	v := m._ZIP
	if v == nil {
		return
	}
	return *v, true
}

// OldZIP returns the old "ZIP" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldZIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldZIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldZIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZIP: %w", err)
	}
	return oldValue.ZIP, nil
}

// ResetZIP resets all changes to the "ZIP" field.
func (m *AddressMutation) ResetZIP() {
	m._ZIP = nil
}

// AddShippingAddresIDs adds the "ShippingAddress" edge to the Shipping entity by ids.
func (m *AddressMutation) AddShippingAddresIDs(ids ...uuid.UUID) {
	if m._ShippingAddress == nil {
		m._ShippingAddress = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ShippingAddress[ids[i]] = struct{}{}
	}
}

// ClearShippingAddress clears the "ShippingAddress" edge to the Shipping entity.
func (m *AddressMutation) ClearShippingAddress() {
	m.cleared_ShippingAddress = true
}

// ShippingAddressCleared reports if the "ShippingAddress" edge to the Shipping entity was cleared.
func (m *AddressMutation) ShippingAddressCleared() bool {
	return m.cleared_ShippingAddress
}

// RemoveShippingAddresIDs removes the "ShippingAddress" edge to the Shipping entity by IDs.
func (m *AddressMutation) RemoveShippingAddresIDs(ids ...uuid.UUID) {
	if m.removed_ShippingAddress == nil {
		m.removed_ShippingAddress = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_ShippingAddress[ids[i]] = struct{}{}
	}
}

// RemovedShippingAddress returns the removed IDs of the "ShippingAddress" edge to the Shipping entity.
func (m *AddressMutation) RemovedShippingAddressIDs() (ids []uuid.UUID) {
	for id := range m.removed_ShippingAddress {
		ids = append(ids, id)
	}
	return
}

// ShippingAddressIDs returns the "ShippingAddress" edge IDs in the mutation.
func (m *AddressMutation) ShippingAddressIDs() (ids []uuid.UUID) {
	for id := range m._ShippingAddress {
		ids = append(ids, id)
	}
	return
}

// ResetShippingAddress resets all changes to the "ShippingAddress" edge.
func (m *AddressMutation) ResetShippingAddress() {
	m._ShippingAddress = nil
	m.cleared_ShippingAddress = false
	m.removed_ShippingAddress = nil
}

// AddBillingAddresIDs adds the "BillingAddress" edge to the Shipping entity by ids.
func (m *AddressMutation) AddBillingAddresIDs(ids ...uuid.UUID) {
	if m._BillingAddress == nil {
		m._BillingAddress = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._BillingAddress[ids[i]] = struct{}{}
	}
}

// ClearBillingAddress clears the "BillingAddress" edge to the Shipping entity.
func (m *AddressMutation) ClearBillingAddress() {
	m.cleared_BillingAddress = true
}

// BillingAddressCleared reports if the "BillingAddress" edge to the Shipping entity was cleared.
func (m *AddressMutation) BillingAddressCleared() bool {
	return m.cleared_BillingAddress
}

// RemoveBillingAddresIDs removes the "BillingAddress" edge to the Shipping entity by IDs.
func (m *AddressMutation) RemoveBillingAddresIDs(ids ...uuid.UUID) {
	if m.removed_BillingAddress == nil {
		m.removed_BillingAddress = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_BillingAddress[ids[i]] = struct{}{}
	}
}

// RemovedBillingAddress returns the removed IDs of the "BillingAddress" edge to the Shipping entity.
func (m *AddressMutation) RemovedBillingAddressIDs() (ids []uuid.UUID) {
	for id := range m.removed_BillingAddress {
		ids = append(ids, id)
	}
	return
}

// BillingAddressIDs returns the "BillingAddress" edge IDs in the mutation.
func (m *AddressMutation) BillingAddressIDs() (ids []uuid.UUID) {
	for id := range m._BillingAddress {
		ids = append(ids, id)
	}
	return
}

// ResetBillingAddress resets all changes to the "BillingAddress" edge.
func (m *AddressMutation) ResetBillingAddress() {
	m._BillingAddress = nil
	m.cleared_BillingAddress = false
	m.removed_BillingAddress = nil
}

// Op returns the operation name.
func (m *AddressMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Address).
func (m *AddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddressMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, address.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, address.FieldUpdatedAt)
	}
	if m._AddressLine != nil {
		fields = append(fields, address.FieldAddressLine)
	}
	if m._AddressLine2 != nil {
		fields = append(fields, address.FieldAddressLine2)
	}
	if m._Country != nil {
		fields = append(fields, address.FieldCountry)
	}
	if m._State != nil {
		fields = append(fields, address.FieldState)
	}
	if m._City != nil {
		fields = append(fields, address.FieldCity)
	}
	if m._ZIP != nil {
		fields = append(fields, address.FieldZIP)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case address.FieldCreatedAt:
		return m.CreatedAt()
	case address.FieldUpdatedAt:
		return m.UpdatedAt()
	case address.FieldAddressLine:
		return m.AddressLine()
	case address.FieldAddressLine2:
		return m.AddressLine2()
	case address.FieldCountry:
		return m.Country()
	case address.FieldState:
		return m.State()
	case address.FieldCity:
		return m.City()
	case address.FieldZIP:
		return m.ZIP()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case address.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case address.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case address.FieldAddressLine:
		return m.OldAddressLine(ctx)
	case address.FieldAddressLine2:
		return m.OldAddressLine2(ctx)
	case address.FieldCountry:
		return m.OldCountry(ctx)
	case address.FieldState:
		return m.OldState(ctx)
	case address.FieldCity:
		return m.OldCity(ctx)
	case address.FieldZIP:
		return m.OldZIP(ctx)
	}
	return nil, fmt.Errorf("unknown Address field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case address.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case address.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case address.FieldAddressLine:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressLine(v)
		return nil
	case address.FieldAddressLine2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressLine2(v)
		return nil
	case address.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case address.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case address.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case address.FieldZIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZIP(v)
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Address numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(address.FieldAddressLine2) {
		fields = append(fields, address.FieldAddressLine2)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddressMutation) ClearField(name string) error {
	switch name {
	case address.FieldAddressLine2:
		m.ClearAddressLine2()
		return nil
	}
	return fmt.Errorf("unknown Address nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddressMutation) ResetField(name string) error {
	switch name {
	case address.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case address.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case address.FieldAddressLine:
		m.ResetAddressLine()
		return nil
	case address.FieldAddressLine2:
		m.ResetAddressLine2()
		return nil
	case address.FieldCountry:
		m.ResetCountry()
		return nil
	case address.FieldState:
		m.ResetState()
		return nil
	case address.FieldCity:
		m.ResetCity()
		return nil
	case address.FieldZIP:
		m.ResetZIP()
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._ShippingAddress != nil {
		edges = append(edges, address.EdgeShippingAddress)
	}
	if m._BillingAddress != nil {
		edges = append(edges, address.EdgeBillingAddress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeShippingAddress:
		ids := make([]ent.Value, 0, len(m._ShippingAddress))
		for id := range m._ShippingAddress {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeBillingAddress:
		ids := make([]ent.Value, 0, len(m._BillingAddress))
		for id := range m._BillingAddress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_ShippingAddress != nil {
		edges = append(edges, address.EdgeShippingAddress)
	}
	if m.removed_BillingAddress != nil {
		edges = append(edges, address.EdgeBillingAddress)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeShippingAddress:
		ids := make([]ent.Value, 0, len(m.removed_ShippingAddress))
		for id := range m.removed_ShippingAddress {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeBillingAddress:
		ids := make([]ent.Value, 0, len(m.removed_BillingAddress))
		for id := range m.removed_BillingAddress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_ShippingAddress {
		edges = append(edges, address.EdgeShippingAddress)
	}
	if m.cleared_BillingAddress {
		edges = append(edges, address.EdgeBillingAddress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddressMutation) EdgeCleared(name string) bool {
	switch name {
	case address.EdgeShippingAddress:
		return m.cleared_ShippingAddress
	case address.EdgeBillingAddress:
		return m.cleared_BillingAddress
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddressMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Address unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddressMutation) ResetEdge(name string) error {
	switch name {
	case address.EdgeShippingAddress:
		m.ResetShippingAddress()
		return nil
	case address.EdgeBillingAddress:
		m.ResetBillingAddress()
		return nil
	}
	return fmt.Errorf("unknown Address edge %s", name)
}

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	first_login           *bool
	clearedFields         map[string]struct{}
	_User                 *uuid.UUID
	cleared_User          bool
	_Settings             map[uuid.UUID]struct{}
	removed_Settings      map[uuid.UUID]struct{}
	cleared_Settings      bool
	_ProxyLists           map[uuid.UUID]struct{}
	removed_ProxyLists    map[uuid.UUID]struct{}
	cleared_ProxyLists    bool
	_ProfileGroups        map[uuid.UUID]struct{}
	removed_ProfileGroups map[uuid.UUID]struct{}
	cleared_ProfileGroups bool
	_TaskGroups           map[uuid.UUID]struct{}
	removed_TaskGroups    map[uuid.UUID]struct{}
	cleared_TaskGroups    bool
	_AccountGroups        map[uuid.UUID]struct{}
	removed_AccountGroups map[uuid.UUID]struct{}
	cleared_AccountGroups bool
	done                  bool
	oldValue              func(context.Context) (*App, error)
	predicates            []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id uuid.UUID) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AppMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFirstLogin sets the "first_login" field.
func (m *AppMutation) SetFirstLogin(b bool) {
	m.first_login = &b
}

// FirstLogin returns the value of the "first_login" field in the mutation.
func (m *AppMutation) FirstLogin() (r bool, exists bool) {
	v := m.first_login
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstLogin returns the old "first_login" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldFirstLogin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstLogin: %w", err)
	}
	return oldValue.FirstLogin, nil
}

// ResetFirstLogin resets all changes to the "first_login" field.
func (m *AppMutation) ResetFirstLogin() {
	m.first_login = nil
}

// SetUserID sets the "User" edge to the User entity by id.
func (m *AppMutation) SetUserID(id uuid.UUID) {
	m._User = &id
}

// ClearUser clears the "User" edge to the User entity.
func (m *AppMutation) ClearUser() {
	m.cleared_User = true
}

// UserCleared reports if the "User" edge to the User entity was cleared.
func (m *AppMutation) UserCleared() bool {
	return m.cleared_User
}

// UserID returns the "User" edge ID in the mutation.
func (m *AppMutation) UserID() (id uuid.UUID, exists bool) {
	if m._User != nil {
		return *m._User, true
	}
	return
}

// UserIDs returns the "User" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AppMutation) UserIDs() (ids []uuid.UUID) {
	if id := m._User; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "User" edge.
func (m *AppMutation) ResetUser() {
	m._User = nil
	m.cleared_User = false
}

// AddSettingIDs adds the "Settings" edge to the Settings entity by ids.
func (m *AppMutation) AddSettingIDs(ids ...uuid.UUID) {
	if m._Settings == nil {
		m._Settings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Settings[ids[i]] = struct{}{}
	}
}

// ClearSettings clears the "Settings" edge to the Settings entity.
func (m *AppMutation) ClearSettings() {
	m.cleared_Settings = true
}

// SettingsCleared reports if the "Settings" edge to the Settings entity was cleared.
func (m *AppMutation) SettingsCleared() bool {
	return m.cleared_Settings
}

// RemoveSettingIDs removes the "Settings" edge to the Settings entity by IDs.
func (m *AppMutation) RemoveSettingIDs(ids ...uuid.UUID) {
	if m.removed_Settings == nil {
		m.removed_Settings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_Settings[ids[i]] = struct{}{}
	}
}

// RemovedSettings returns the removed IDs of the "Settings" edge to the Settings entity.
func (m *AppMutation) RemovedSettingsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Settings {
		ids = append(ids, id)
	}
	return
}

// SettingsIDs returns the "Settings" edge IDs in the mutation.
func (m *AppMutation) SettingsIDs() (ids []uuid.UUID) {
	for id := range m._Settings {
		ids = append(ids, id)
	}
	return
}

// ResetSettings resets all changes to the "Settings" edge.
func (m *AppMutation) ResetSettings() {
	m._Settings = nil
	m.cleared_Settings = false
	m.removed_Settings = nil
}

// AddProxyListIDs adds the "ProxyLists" edge to the ProxyList entity by ids.
func (m *AppMutation) AddProxyListIDs(ids ...uuid.UUID) {
	if m._ProxyLists == nil {
		m._ProxyLists = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ProxyLists[ids[i]] = struct{}{}
	}
}

// ClearProxyLists clears the "ProxyLists" edge to the ProxyList entity.
func (m *AppMutation) ClearProxyLists() {
	m.cleared_ProxyLists = true
}

// ProxyListsCleared reports if the "ProxyLists" edge to the ProxyList entity was cleared.
func (m *AppMutation) ProxyListsCleared() bool {
	return m.cleared_ProxyLists
}

// RemoveProxyListIDs removes the "ProxyLists" edge to the ProxyList entity by IDs.
func (m *AppMutation) RemoveProxyListIDs(ids ...uuid.UUID) {
	if m.removed_ProxyLists == nil {
		m.removed_ProxyLists = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_ProxyLists[ids[i]] = struct{}{}
	}
}

// RemovedProxyLists returns the removed IDs of the "ProxyLists" edge to the ProxyList entity.
func (m *AppMutation) RemovedProxyListsIDs() (ids []uuid.UUID) {
	for id := range m.removed_ProxyLists {
		ids = append(ids, id)
	}
	return
}

// ProxyListsIDs returns the "ProxyLists" edge IDs in the mutation.
func (m *AppMutation) ProxyListsIDs() (ids []uuid.UUID) {
	for id := range m._ProxyLists {
		ids = append(ids, id)
	}
	return
}

// ResetProxyLists resets all changes to the "ProxyLists" edge.
func (m *AppMutation) ResetProxyLists() {
	m._ProxyLists = nil
	m.cleared_ProxyLists = false
	m.removed_ProxyLists = nil
}

// AddProfileGroupIDs adds the "ProfileGroups" edge to the ProfileGroup entity by ids.
func (m *AppMutation) AddProfileGroupIDs(ids ...uuid.UUID) {
	if m._ProfileGroups == nil {
		m._ProfileGroups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ProfileGroups[ids[i]] = struct{}{}
	}
}

// ClearProfileGroups clears the "ProfileGroups" edge to the ProfileGroup entity.
func (m *AppMutation) ClearProfileGroups() {
	m.cleared_ProfileGroups = true
}

// ProfileGroupsCleared reports if the "ProfileGroups" edge to the ProfileGroup entity was cleared.
func (m *AppMutation) ProfileGroupsCleared() bool {
	return m.cleared_ProfileGroups
}

// RemoveProfileGroupIDs removes the "ProfileGroups" edge to the ProfileGroup entity by IDs.
func (m *AppMutation) RemoveProfileGroupIDs(ids ...uuid.UUID) {
	if m.removed_ProfileGroups == nil {
		m.removed_ProfileGroups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_ProfileGroups[ids[i]] = struct{}{}
	}
}

// RemovedProfileGroups returns the removed IDs of the "ProfileGroups" edge to the ProfileGroup entity.
func (m *AppMutation) RemovedProfileGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removed_ProfileGroups {
		ids = append(ids, id)
	}
	return
}

// ProfileGroupsIDs returns the "ProfileGroups" edge IDs in the mutation.
func (m *AppMutation) ProfileGroupsIDs() (ids []uuid.UUID) {
	for id := range m._ProfileGroups {
		ids = append(ids, id)
	}
	return
}

// ResetProfileGroups resets all changes to the "ProfileGroups" edge.
func (m *AppMutation) ResetProfileGroups() {
	m._ProfileGroups = nil
	m.cleared_ProfileGroups = false
	m.removed_ProfileGroups = nil
}

// AddTaskGroupIDs adds the "TaskGroups" edge to the TaskGroup entity by ids.
func (m *AppMutation) AddTaskGroupIDs(ids ...uuid.UUID) {
	if m._TaskGroups == nil {
		m._TaskGroups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._TaskGroups[ids[i]] = struct{}{}
	}
}

// ClearTaskGroups clears the "TaskGroups" edge to the TaskGroup entity.
func (m *AppMutation) ClearTaskGroups() {
	m.cleared_TaskGroups = true
}

// TaskGroupsCleared reports if the "TaskGroups" edge to the TaskGroup entity was cleared.
func (m *AppMutation) TaskGroupsCleared() bool {
	return m.cleared_TaskGroups
}

// RemoveTaskGroupIDs removes the "TaskGroups" edge to the TaskGroup entity by IDs.
func (m *AppMutation) RemoveTaskGroupIDs(ids ...uuid.UUID) {
	if m.removed_TaskGroups == nil {
		m.removed_TaskGroups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_TaskGroups[ids[i]] = struct{}{}
	}
}

// RemovedTaskGroups returns the removed IDs of the "TaskGroups" edge to the TaskGroup entity.
func (m *AppMutation) RemovedTaskGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removed_TaskGroups {
		ids = append(ids, id)
	}
	return
}

// TaskGroupsIDs returns the "TaskGroups" edge IDs in the mutation.
func (m *AppMutation) TaskGroupsIDs() (ids []uuid.UUID) {
	for id := range m._TaskGroups {
		ids = append(ids, id)
	}
	return
}

// ResetTaskGroups resets all changes to the "TaskGroups" edge.
func (m *AppMutation) ResetTaskGroups() {
	m._TaskGroups = nil
	m.cleared_TaskGroups = false
	m.removed_TaskGroups = nil
}

// AddAccountGroupIDs adds the "AccountGroups" edge to the AccountGroup entity by ids.
func (m *AppMutation) AddAccountGroupIDs(ids ...uuid.UUID) {
	if m._AccountGroups == nil {
		m._AccountGroups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._AccountGroups[ids[i]] = struct{}{}
	}
}

// ClearAccountGroups clears the "AccountGroups" edge to the AccountGroup entity.
func (m *AppMutation) ClearAccountGroups() {
	m.cleared_AccountGroups = true
}

// AccountGroupsCleared reports if the "AccountGroups" edge to the AccountGroup entity was cleared.
func (m *AppMutation) AccountGroupsCleared() bool {
	return m.cleared_AccountGroups
}

// RemoveAccountGroupIDs removes the "AccountGroups" edge to the AccountGroup entity by IDs.
func (m *AppMutation) RemoveAccountGroupIDs(ids ...uuid.UUID) {
	if m.removed_AccountGroups == nil {
		m.removed_AccountGroups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_AccountGroups[ids[i]] = struct{}{}
	}
}

// RemovedAccountGroups returns the removed IDs of the "AccountGroups" edge to the AccountGroup entity.
func (m *AppMutation) RemovedAccountGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removed_AccountGroups {
		ids = append(ids, id)
	}
	return
}

// AccountGroupsIDs returns the "AccountGroups" edge IDs in the mutation.
func (m *AppMutation) AccountGroupsIDs() (ids []uuid.UUID) {
	for id := range m._AccountGroups {
		ids = append(ids, id)
	}
	return
}

// ResetAccountGroups resets all changes to the "AccountGroups" edge.
func (m *AppMutation) ResetAccountGroups() {
	m._AccountGroups = nil
	m.cleared_AccountGroups = false
	m.removed_AccountGroups = nil
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.first_login != nil {
		fields = append(fields, app.FieldFirstLogin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreatedAt:
		return m.CreatedAt()
	case app.FieldUpdatedAt:
		return m.UpdatedAt()
	case app.FieldFirstLogin:
		return m.FirstLogin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case app.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case app.FieldFirstLogin:
		return m.OldFirstLogin(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case app.FieldFirstLogin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstLogin(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case app.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case app.FieldFirstLogin:
		m.ResetFirstLogin()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m._User != nil {
		edges = append(edges, app.EdgeUser)
	}
	if m._Settings != nil {
		edges = append(edges, app.EdgeSettings)
	}
	if m._ProxyLists != nil {
		edges = append(edges, app.EdgeProxyLists)
	}
	if m._ProfileGroups != nil {
		edges = append(edges, app.EdgeProfileGroups)
	}
	if m._TaskGroups != nil {
		edges = append(edges, app.EdgeTaskGroups)
	}
	if m._AccountGroups != nil {
		edges = append(edges, app.EdgeAccountGroups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeUser:
		if id := m._User; id != nil {
			return []ent.Value{*id}
		}
	case app.EdgeSettings:
		ids := make([]ent.Value, 0, len(m._Settings))
		for id := range m._Settings {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeProxyLists:
		ids := make([]ent.Value, 0, len(m._ProxyLists))
		for id := range m._ProxyLists {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeProfileGroups:
		ids := make([]ent.Value, 0, len(m._ProfileGroups))
		for id := range m._ProfileGroups {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeTaskGroups:
		ids := make([]ent.Value, 0, len(m._TaskGroups))
		for id := range m._TaskGroups {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeAccountGroups:
		ids := make([]ent.Value, 0, len(m._AccountGroups))
		for id := range m._AccountGroups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removed_Settings != nil {
		edges = append(edges, app.EdgeSettings)
	}
	if m.removed_ProxyLists != nil {
		edges = append(edges, app.EdgeProxyLists)
	}
	if m.removed_ProfileGroups != nil {
		edges = append(edges, app.EdgeProfileGroups)
	}
	if m.removed_TaskGroups != nil {
		edges = append(edges, app.EdgeTaskGroups)
	}
	if m.removed_AccountGroups != nil {
		edges = append(edges, app.EdgeAccountGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeSettings:
		ids := make([]ent.Value, 0, len(m.removed_Settings))
		for id := range m.removed_Settings {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeProxyLists:
		ids := make([]ent.Value, 0, len(m.removed_ProxyLists))
		for id := range m.removed_ProxyLists {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeProfileGroups:
		ids := make([]ent.Value, 0, len(m.removed_ProfileGroups))
		for id := range m.removed_ProfileGroups {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeTaskGroups:
		ids := make([]ent.Value, 0, len(m.removed_TaskGroups))
		for id := range m.removed_TaskGroups {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeAccountGroups:
		ids := make([]ent.Value, 0, len(m.removed_AccountGroups))
		for id := range m.removed_AccountGroups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleared_User {
		edges = append(edges, app.EdgeUser)
	}
	if m.cleared_Settings {
		edges = append(edges, app.EdgeSettings)
	}
	if m.cleared_ProxyLists {
		edges = append(edges, app.EdgeProxyLists)
	}
	if m.cleared_ProfileGroups {
		edges = append(edges, app.EdgeProfileGroups)
	}
	if m.cleared_TaskGroups {
		edges = append(edges, app.EdgeTaskGroups)
	}
	if m.cleared_AccountGroups {
		edges = append(edges, app.EdgeAccountGroups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	case app.EdgeUser:
		return m.cleared_User
	case app.EdgeSettings:
		return m.cleared_Settings
	case app.EdgeProxyLists:
		return m.cleared_ProxyLists
	case app.EdgeProfileGroups:
		return m.cleared_ProfileGroups
	case app.EdgeTaskGroups:
		return m.cleared_TaskGroups
	case app.EdgeAccountGroups:
		return m.cleared_AccountGroups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	case app.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case app.EdgeUser:
		m.ResetUser()
		return nil
	case app.EdgeSettings:
		m.ResetSettings()
		return nil
	case app.EdgeProxyLists:
		m.ResetProxyLists()
		return nil
	case app.EdgeProfileGroups:
		m.ResetProfileGroups()
		return nil
	case app.EdgeTaskGroups:
		m.ResetTaskGroups()
		return nil
	case app.EdgeAccountGroups:
		m.ResetAccountGroups()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// BillingMutation represents an operation that mutates the Billing nodes in the graph.
type BillingMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	_CardholderName *string
	_CardNumber     *string
	_ExpiryMonth    *string
	_ExpiryYear     *string
	_CVV            *string
	clearedFields   map[string]struct{}
	_Profile        map[uuid.UUID]struct{}
	removed_Profile map[uuid.UUID]struct{}
	cleared_Profile bool
	done            bool
	oldValue        func(context.Context) (*Billing, error)
	predicates      []predicate.Billing
}

var _ ent.Mutation = (*BillingMutation)(nil)

// billingOption allows management of the mutation configuration using functional options.
type billingOption func(*BillingMutation)

// newBillingMutation creates new mutation for the Billing entity.
func newBillingMutation(c config, op Op, opts ...billingOption) *BillingMutation {
	m := &BillingMutation{
		config:        c,
		op:            op,
		typ:           TypeBilling,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingID sets the ID field of the mutation.
func withBillingID(id uuid.UUID) billingOption {
	return func(m *BillingMutation) {
		var (
			err   error
			once  sync.Once
			value *Billing
		)
		m.oldValue = func(ctx context.Context) (*Billing, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Billing.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBilling sets the old Billing of the mutation.
func withBilling(node *Billing) billingOption {
	return func(m *BillingMutation) {
		m.oldValue = func(context.Context) (*Billing, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Billing entities.
func (m *BillingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *BillingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Billing entity.
// If the Billing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Billing entity.
// If the Billing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCardholderName sets the "CardholderName" field.
func (m *BillingMutation) SetCardholderName(s string) {
	m._CardholderName = &s
}

// CardholderName returns the value of the "CardholderName" field in the mutation.
func (m *BillingMutation) CardholderName() (r string, exists bool) {
	v := m._CardholderName
	if v == nil {
		return
	}
	return *v, true
}

// OldCardholderName returns the old "CardholderName" field's value of the Billing entity.
// If the Billing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingMutation) OldCardholderName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCardholderName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCardholderName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardholderName: %w", err)
	}
	return oldValue.CardholderName, nil
}

// ResetCardholderName resets all changes to the "CardholderName" field.
func (m *BillingMutation) ResetCardholderName() {
	m._CardholderName = nil
}

// SetCardNumber sets the "CardNumber" field.
func (m *BillingMutation) SetCardNumber(s string) {
	m._CardNumber = &s
}

// CardNumber returns the value of the "CardNumber" field in the mutation.
func (m *BillingMutation) CardNumber() (r string, exists bool) {
	v := m._CardNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldCardNumber returns the old "CardNumber" field's value of the Billing entity.
// If the Billing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingMutation) OldCardNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCardNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCardNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardNumber: %w", err)
	}
	return oldValue.CardNumber, nil
}

// ResetCardNumber resets all changes to the "CardNumber" field.
func (m *BillingMutation) ResetCardNumber() {
	m._CardNumber = nil
}

// SetExpiryMonth sets the "ExpiryMonth" field.
func (m *BillingMutation) SetExpiryMonth(s string) {
	m._ExpiryMonth = &s
}

// ExpiryMonth returns the value of the "ExpiryMonth" field in the mutation.
func (m *BillingMutation) ExpiryMonth() (r string, exists bool) {
	v := m._ExpiryMonth
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiryMonth returns the old "ExpiryMonth" field's value of the Billing entity.
// If the Billing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingMutation) OldExpiryMonth(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpiryMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpiryMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiryMonth: %w", err)
	}
	return oldValue.ExpiryMonth, nil
}

// ResetExpiryMonth resets all changes to the "ExpiryMonth" field.
func (m *BillingMutation) ResetExpiryMonth() {
	m._ExpiryMonth = nil
}

// SetExpiryYear sets the "ExpiryYear" field.
func (m *BillingMutation) SetExpiryYear(s string) {
	m._ExpiryYear = &s
}

// ExpiryYear returns the value of the "ExpiryYear" field in the mutation.
func (m *BillingMutation) ExpiryYear() (r string, exists bool) {
	v := m._ExpiryYear
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiryYear returns the old "ExpiryYear" field's value of the Billing entity.
// If the Billing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingMutation) OldExpiryYear(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpiryYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpiryYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiryYear: %w", err)
	}
	return oldValue.ExpiryYear, nil
}

// ResetExpiryYear resets all changes to the "ExpiryYear" field.
func (m *BillingMutation) ResetExpiryYear() {
	m._ExpiryYear = nil
}

// SetCVV sets the "CVV" field.
func (m *BillingMutation) SetCVV(s string) {
	m._CVV = &s
}

// CVV returns the value of the "CVV" field in the mutation.
func (m *BillingMutation) CVV() (r string, exists bool) {
	v := m._CVV
	if v == nil {
		return
	}
	return *v, true
}

// OldCVV returns the old "CVV" field's value of the Billing entity.
// If the Billing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingMutation) OldCVV(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCVV is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCVV requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCVV: %w", err)
	}
	return oldValue.CVV, nil
}

// ResetCVV resets all changes to the "CVV" field.
func (m *BillingMutation) ResetCVV() {
	m._CVV = nil
}

// AddProfileIDs adds the "Profile" edge to the Profile entity by ids.
func (m *BillingMutation) AddProfileIDs(ids ...uuid.UUID) {
	if m._Profile == nil {
		m._Profile = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Profile[ids[i]] = struct{}{}
	}
}

// ClearProfile clears the "Profile" edge to the Profile entity.
func (m *BillingMutation) ClearProfile() {
	m.cleared_Profile = true
}

// ProfileCleared reports if the "Profile" edge to the Profile entity was cleared.
func (m *BillingMutation) ProfileCleared() bool {
	return m.cleared_Profile
}

// RemoveProfileIDs removes the "Profile" edge to the Profile entity by IDs.
func (m *BillingMutation) RemoveProfileIDs(ids ...uuid.UUID) {
	if m.removed_Profile == nil {
		m.removed_Profile = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_Profile[ids[i]] = struct{}{}
	}
}

// RemovedProfile returns the removed IDs of the "Profile" edge to the Profile entity.
func (m *BillingMutation) RemovedProfileIDs() (ids []uuid.UUID) {
	for id := range m.removed_Profile {
		ids = append(ids, id)
	}
	return
}

// ProfileIDs returns the "Profile" edge IDs in the mutation.
func (m *BillingMutation) ProfileIDs() (ids []uuid.UUID) {
	for id := range m._Profile {
		ids = append(ids, id)
	}
	return
}

// ResetProfile resets all changes to the "Profile" edge.
func (m *BillingMutation) ResetProfile() {
	m._Profile = nil
	m.cleared_Profile = false
	m.removed_Profile = nil
}

// Op returns the operation name.
func (m *BillingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Billing).
func (m *BillingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, billing.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billing.FieldUpdatedAt)
	}
	if m._CardholderName != nil {
		fields = append(fields, billing.FieldCardholderName)
	}
	if m._CardNumber != nil {
		fields = append(fields, billing.FieldCardNumber)
	}
	if m._ExpiryMonth != nil {
		fields = append(fields, billing.FieldExpiryMonth)
	}
	if m._ExpiryYear != nil {
		fields = append(fields, billing.FieldExpiryYear)
	}
	if m._CVV != nil {
		fields = append(fields, billing.FieldCVV)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billing.FieldCreatedAt:
		return m.CreatedAt()
	case billing.FieldUpdatedAt:
		return m.UpdatedAt()
	case billing.FieldCardholderName:
		return m.CardholderName()
	case billing.FieldCardNumber:
		return m.CardNumber()
	case billing.FieldExpiryMonth:
		return m.ExpiryMonth()
	case billing.FieldExpiryYear:
		return m.ExpiryYear()
	case billing.FieldCVV:
		return m.CVV()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billing.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billing.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billing.FieldCardholderName:
		return m.OldCardholderName(ctx)
	case billing.FieldCardNumber:
		return m.OldCardNumber(ctx)
	case billing.FieldExpiryMonth:
		return m.OldExpiryMonth(ctx)
	case billing.FieldExpiryYear:
		return m.OldExpiryYear(ctx)
	case billing.FieldCVV:
		return m.OldCVV(ctx)
	}
	return nil, fmt.Errorf("unknown Billing field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billing.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billing.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billing.FieldCardholderName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardholderName(v)
		return nil
	case billing.FieldCardNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardNumber(v)
		return nil
	case billing.FieldExpiryMonth:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiryMonth(v)
		return nil
	case billing.FieldExpiryYear:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiryYear(v)
		return nil
	case billing.FieldCVV:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCVV(v)
		return nil
	}
	return fmt.Errorf("unknown Billing field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Billing numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Billing nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingMutation) ResetField(name string) error {
	switch name {
	case billing.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billing.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billing.FieldCardholderName:
		m.ResetCardholderName()
		return nil
	case billing.FieldCardNumber:
		m.ResetCardNumber()
		return nil
	case billing.FieldExpiryMonth:
		m.ResetExpiryMonth()
		return nil
	case billing.FieldExpiryYear:
		m.ResetExpiryYear()
		return nil
	case billing.FieldCVV:
		m.ResetCVV()
		return nil
	}
	return fmt.Errorf("unknown Billing field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Profile != nil {
		edges = append(edges, billing.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billing.EdgeProfile:
		ids := make([]ent.Value, 0, len(m._Profile))
		for id := range m._Profile {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Profile != nil {
		edges = append(edges, billing.EdgeProfile)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case billing.EdgeProfile:
		ids := make([]ent.Value, 0, len(m.removed_Profile))
		for id := range m.removed_Profile {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Profile {
		edges = append(edges, billing.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingMutation) EdgeCleared(name string) bool {
	switch name {
	case billing.EdgeProfile:
		return m.cleared_Profile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Billing unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingMutation) ResetEdge(name string) error {
	switch name {
	case billing.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown Billing edge %s", name)
}

// LicenseMutation represents an operation that mutates the License nodes in the graph.
type LicenseMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	_Key              *string
	_HardwareID       *string
	_MobileHardwareID *string
	_Type             *license.Type
	clearedFields     map[string]struct{}
	_User             *uuid.UUID
	cleared_User      bool
	_Stripe           map[uuid.UUID]struct{}
	removed_Stripe    map[uuid.UUID]struct{}
	cleared_Stripe    bool
	done              bool
	oldValue          func(context.Context) (*License, error)
	predicates        []predicate.License
}

var _ ent.Mutation = (*LicenseMutation)(nil)

// licenseOption allows management of the mutation configuration using functional options.
type licenseOption func(*LicenseMutation)

// newLicenseMutation creates new mutation for the License entity.
func newLicenseMutation(c config, op Op, opts ...licenseOption) *LicenseMutation {
	m := &LicenseMutation{
		config:        c,
		op:            op,
		typ:           TypeLicense,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLicenseID sets the ID field of the mutation.
func withLicenseID(id uuid.UUID) licenseOption {
	return func(m *LicenseMutation) {
		var (
			err   error
			once  sync.Once
			value *License
		)
		m.oldValue = func(ctx context.Context) (*License, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().License.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLicense sets the old License of the mutation.
func withLicense(node *License) licenseOption {
	return func(m *LicenseMutation) {
		m.oldValue = func(context.Context) (*License, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LicenseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LicenseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of License entities.
func (m *LicenseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *LicenseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *LicenseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LicenseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LicenseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LicenseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LicenseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LicenseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetKey sets the "Key" field.
func (m *LicenseMutation) SetKey(s string) {
	m._Key = &s
}

// Key returns the value of the "Key" field in the mutation.
func (m *LicenseMutation) Key() (r string, exists bool) {
	v := m._Key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "Key" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "Key" field.
func (m *LicenseMutation) ResetKey() {
	m._Key = nil
}

// SetHardwareID sets the "HardwareID" field.
func (m *LicenseMutation) SetHardwareID(s string) {
	m._HardwareID = &s
}

// HardwareID returns the value of the "HardwareID" field in the mutation.
func (m *LicenseMutation) HardwareID() (r string, exists bool) {
	v := m._HardwareID
	if v == nil {
		return
	}
	return *v, true
}

// OldHardwareID returns the old "HardwareID" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldHardwareID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHardwareID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHardwareID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHardwareID: %w", err)
	}
	return oldValue.HardwareID, nil
}

// ClearHardwareID clears the value of the "HardwareID" field.
func (m *LicenseMutation) ClearHardwareID() {
	m._HardwareID = nil
	m.clearedFields[license.FieldHardwareID] = struct{}{}
}

// HardwareIDCleared returns if the "HardwareID" field was cleared in this mutation.
func (m *LicenseMutation) HardwareIDCleared() bool {
	_, ok := m.clearedFields[license.FieldHardwareID]
	return ok
}

// ResetHardwareID resets all changes to the "HardwareID" field.
func (m *LicenseMutation) ResetHardwareID() {
	m._HardwareID = nil
	delete(m.clearedFields, license.FieldHardwareID)
}

// SetMobileHardwareID sets the "MobileHardwareID" field.
func (m *LicenseMutation) SetMobileHardwareID(s string) {
	m._MobileHardwareID = &s
}

// MobileHardwareID returns the value of the "MobileHardwareID" field in the mutation.
func (m *LicenseMutation) MobileHardwareID() (r string, exists bool) {
	v := m._MobileHardwareID
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileHardwareID returns the old "MobileHardwareID" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldMobileHardwareID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMobileHardwareID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMobileHardwareID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileHardwareID: %w", err)
	}
	return oldValue.MobileHardwareID, nil
}

// ClearMobileHardwareID clears the value of the "MobileHardwareID" field.
func (m *LicenseMutation) ClearMobileHardwareID() {
	m._MobileHardwareID = nil
	m.clearedFields[license.FieldMobileHardwareID] = struct{}{}
}

// MobileHardwareIDCleared returns if the "MobileHardwareID" field was cleared in this mutation.
func (m *LicenseMutation) MobileHardwareIDCleared() bool {
	_, ok := m.clearedFields[license.FieldMobileHardwareID]
	return ok
}

// ResetMobileHardwareID resets all changes to the "MobileHardwareID" field.
func (m *LicenseMutation) ResetMobileHardwareID() {
	m._MobileHardwareID = nil
	delete(m.clearedFields, license.FieldMobileHardwareID)
}

// SetType sets the "Type" field.
func (m *LicenseMutation) SetType(l license.Type) {
	m._Type = &l
}

// GetType returns the value of the "Type" field in the mutation.
func (m *LicenseMutation) GetType() (r license.Type, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldType(ctx context.Context) (v license.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "Type" field.
func (m *LicenseMutation) ResetType() {
	m._Type = nil
}

// SetUserID sets the "User" edge to the User entity by id.
func (m *LicenseMutation) SetUserID(id uuid.UUID) {
	m._User = &id
}

// ClearUser clears the "User" edge to the User entity.
func (m *LicenseMutation) ClearUser() {
	m.cleared_User = true
}

// UserCleared reports if the "User" edge to the User entity was cleared.
func (m *LicenseMutation) UserCleared() bool {
	return m.cleared_User
}

// UserID returns the "User" edge ID in the mutation.
func (m *LicenseMutation) UserID() (id uuid.UUID, exists bool) {
	if m._User != nil {
		return *m._User, true
	}
	return
}

// UserIDs returns the "User" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LicenseMutation) UserIDs() (ids []uuid.UUID) {
	if id := m._User; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "User" edge.
func (m *LicenseMutation) ResetUser() {
	m._User = nil
	m.cleared_User = false
}

// AddStripeIDs adds the "Stripe" edge to the Stripe entity by ids.
func (m *LicenseMutation) AddStripeIDs(ids ...uuid.UUID) {
	if m._Stripe == nil {
		m._Stripe = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Stripe[ids[i]] = struct{}{}
	}
}

// ClearStripe clears the "Stripe" edge to the Stripe entity.
func (m *LicenseMutation) ClearStripe() {
	m.cleared_Stripe = true
}

// StripeCleared reports if the "Stripe" edge to the Stripe entity was cleared.
func (m *LicenseMutation) StripeCleared() bool {
	return m.cleared_Stripe
}

// RemoveStripeIDs removes the "Stripe" edge to the Stripe entity by IDs.
func (m *LicenseMutation) RemoveStripeIDs(ids ...uuid.UUID) {
	if m.removed_Stripe == nil {
		m.removed_Stripe = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_Stripe[ids[i]] = struct{}{}
	}
}

// RemovedStripe returns the removed IDs of the "Stripe" edge to the Stripe entity.
func (m *LicenseMutation) RemovedStripeIDs() (ids []uuid.UUID) {
	for id := range m.removed_Stripe {
		ids = append(ids, id)
	}
	return
}

// StripeIDs returns the "Stripe" edge IDs in the mutation.
func (m *LicenseMutation) StripeIDs() (ids []uuid.UUID) {
	for id := range m._Stripe {
		ids = append(ids, id)
	}
	return
}

// ResetStripe resets all changes to the "Stripe" edge.
func (m *LicenseMutation) ResetStripe() {
	m._Stripe = nil
	m.cleared_Stripe = false
	m.removed_Stripe = nil
}

// Op returns the operation name.
func (m *LicenseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (License).
func (m *LicenseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LicenseMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, license.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, license.FieldUpdatedAt)
	}
	if m._Key != nil {
		fields = append(fields, license.FieldKey)
	}
	if m._HardwareID != nil {
		fields = append(fields, license.FieldHardwareID)
	}
	if m._MobileHardwareID != nil {
		fields = append(fields, license.FieldMobileHardwareID)
	}
	if m._Type != nil {
		fields = append(fields, license.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LicenseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case license.FieldCreatedAt:
		return m.CreatedAt()
	case license.FieldUpdatedAt:
		return m.UpdatedAt()
	case license.FieldKey:
		return m.Key()
	case license.FieldHardwareID:
		return m.HardwareID()
	case license.FieldMobileHardwareID:
		return m.MobileHardwareID()
	case license.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LicenseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case license.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case license.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case license.FieldKey:
		return m.OldKey(ctx)
	case license.FieldHardwareID:
		return m.OldHardwareID(ctx)
	case license.FieldMobileHardwareID:
		return m.OldMobileHardwareID(ctx)
	case license.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown License field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case license.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case license.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case license.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case license.FieldHardwareID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHardwareID(v)
		return nil
	case license.FieldMobileHardwareID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileHardwareID(v)
		return nil
	case license.FieldType:
		v, ok := value.(license.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LicenseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LicenseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown License numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LicenseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(license.FieldHardwareID) {
		fields = append(fields, license.FieldHardwareID)
	}
	if m.FieldCleared(license.FieldMobileHardwareID) {
		fields = append(fields, license.FieldMobileHardwareID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LicenseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LicenseMutation) ClearField(name string) error {
	switch name {
	case license.FieldHardwareID:
		m.ClearHardwareID()
		return nil
	case license.FieldMobileHardwareID:
		m.ClearMobileHardwareID()
		return nil
	}
	return fmt.Errorf("unknown License nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LicenseMutation) ResetField(name string) error {
	switch name {
	case license.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case license.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case license.FieldKey:
		m.ResetKey()
		return nil
	case license.FieldHardwareID:
		m.ResetHardwareID()
		return nil
	case license.FieldMobileHardwareID:
		m.ResetMobileHardwareID()
		return nil
	case license.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LicenseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._User != nil {
		edges = append(edges, license.EdgeUser)
	}
	if m._Stripe != nil {
		edges = append(edges, license.EdgeStripe)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LicenseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case license.EdgeUser:
		if id := m._User; id != nil {
			return []ent.Value{*id}
		}
	case license.EdgeStripe:
		ids := make([]ent.Value, 0, len(m._Stripe))
		for id := range m._Stripe {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LicenseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_Stripe != nil {
		edges = append(edges, license.EdgeStripe)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LicenseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case license.EdgeStripe:
		ids := make([]ent.Value, 0, len(m.removed_Stripe))
		for id := range m.removed_Stripe {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LicenseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_User {
		edges = append(edges, license.EdgeUser)
	}
	if m.cleared_Stripe {
		edges = append(edges, license.EdgeStripe)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LicenseMutation) EdgeCleared(name string) bool {
	switch name {
	case license.EdgeUser:
		return m.cleared_User
	case license.EdgeStripe:
		return m.cleared_Stripe
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LicenseMutation) ClearEdge(name string) error {
	switch name {
	case license.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown License unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LicenseMutation) ResetEdge(name string) error {
	switch name {
	case license.EdgeUser:
		m.ResetUser()
		return nil
	case license.EdgeStripe:
		m.ResetStripe()
		return nil
	}
	return fmt.Errorf("unknown License edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	_Name             *string
	_Image            *string
	_LookupType       *product.LookupType
	_PositiveKeywords *pq.StringArray
	_NegativeKeywords *pq.StringArray
	_Link             *string
	_Quantity         *int32
	add_Quantity      *int32
	_Sizes            *pq.StringArray
	_Colors           *pq.StringArray
	_Site             *product.Site
	_Metadata         *sonic.Map
	clearedFields     map[string]struct{}
	_Task             map[uuid.UUID]struct{}
	removed_Task      map[uuid.UUID]struct{}
	cleared_Task      bool
	_Statistic        map[uuid.UUID]struct{}
	removed_Statistic map[uuid.UUID]struct{}
	cleared_Statistic bool
	done              bool
	oldValue          func(context.Context) (*Product, error)
	predicates        []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id uuid.UUID) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Product entities.
func (m *ProductMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProductMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "Name" field.
func (m *ProductMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *ProductMutation) ResetName() {
	m._Name = nil
}

// SetImage sets the "Image" field.
func (m *ProductMutation) SetImage(s string) {
	m._Image = &s
}

// Image returns the value of the "Image" field in the mutation.
func (m *ProductMutation) Image() (r string, exists bool) {
	v := m._Image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "Image" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "Image" field.
func (m *ProductMutation) ClearImage() {
	m._Image = nil
	m.clearedFields[product.FieldImage] = struct{}{}
}

// ImageCleared returns if the "Image" field was cleared in this mutation.
func (m *ProductMutation) ImageCleared() bool {
	_, ok := m.clearedFields[product.FieldImage]
	return ok
}

// ResetImage resets all changes to the "Image" field.
func (m *ProductMutation) ResetImage() {
	m._Image = nil
	delete(m.clearedFields, product.FieldImage)
}

// SetLookupType sets the "LookupType" field.
func (m *ProductMutation) SetLookupType(pt product.LookupType) {
	m._LookupType = &pt
}

// LookupType returns the value of the "LookupType" field in the mutation.
func (m *ProductMutation) LookupType() (r product.LookupType, exists bool) {
	v := m._LookupType
	if v == nil {
		return
	}
	return *v, true
}

// OldLookupType returns the old "LookupType" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldLookupType(ctx context.Context) (v product.LookupType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLookupType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLookupType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLookupType: %w", err)
	}
	return oldValue.LookupType, nil
}

// ResetLookupType resets all changes to the "LookupType" field.
func (m *ProductMutation) ResetLookupType() {
	m._LookupType = nil
}

// SetPositiveKeywords sets the "PositiveKeywords" field.
func (m *ProductMutation) SetPositiveKeywords(pa pq.StringArray) {
	m._PositiveKeywords = &pa
}

// PositiveKeywords returns the value of the "PositiveKeywords" field in the mutation.
func (m *ProductMutation) PositiveKeywords() (r pq.StringArray, exists bool) {
	v := m._PositiveKeywords
	if v == nil {
		return
	}
	return *v, true
}

// OldPositiveKeywords returns the old "PositiveKeywords" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPositiveKeywords(ctx context.Context) (v pq.StringArray, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPositiveKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPositiveKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositiveKeywords: %w", err)
	}
	return oldValue.PositiveKeywords, nil
}

// ClearPositiveKeywords clears the value of the "PositiveKeywords" field.
func (m *ProductMutation) ClearPositiveKeywords() {
	m._PositiveKeywords = nil
	m.clearedFields[product.FieldPositiveKeywords] = struct{}{}
}

// PositiveKeywordsCleared returns if the "PositiveKeywords" field was cleared in this mutation.
func (m *ProductMutation) PositiveKeywordsCleared() bool {
	_, ok := m.clearedFields[product.FieldPositiveKeywords]
	return ok
}

// ResetPositiveKeywords resets all changes to the "PositiveKeywords" field.
func (m *ProductMutation) ResetPositiveKeywords() {
	m._PositiveKeywords = nil
	delete(m.clearedFields, product.FieldPositiveKeywords)
}

// SetNegativeKeywords sets the "NegativeKeywords" field.
func (m *ProductMutation) SetNegativeKeywords(pa pq.StringArray) {
	m._NegativeKeywords = &pa
}

// NegativeKeywords returns the value of the "NegativeKeywords" field in the mutation.
func (m *ProductMutation) NegativeKeywords() (r pq.StringArray, exists bool) {
	v := m._NegativeKeywords
	if v == nil {
		return
	}
	return *v, true
}

// OldNegativeKeywords returns the old "NegativeKeywords" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldNegativeKeywords(ctx context.Context) (v pq.StringArray, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNegativeKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNegativeKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNegativeKeywords: %w", err)
	}
	return oldValue.NegativeKeywords, nil
}

// ClearNegativeKeywords clears the value of the "NegativeKeywords" field.
func (m *ProductMutation) ClearNegativeKeywords() {
	m._NegativeKeywords = nil
	m.clearedFields[product.FieldNegativeKeywords] = struct{}{}
}

// NegativeKeywordsCleared returns if the "NegativeKeywords" field was cleared in this mutation.
func (m *ProductMutation) NegativeKeywordsCleared() bool {
	_, ok := m.clearedFields[product.FieldNegativeKeywords]
	return ok
}

// ResetNegativeKeywords resets all changes to the "NegativeKeywords" field.
func (m *ProductMutation) ResetNegativeKeywords() {
	m._NegativeKeywords = nil
	delete(m.clearedFields, product.FieldNegativeKeywords)
}

// SetLink sets the "Link" field.
func (m *ProductMutation) SetLink(s string) {
	m._Link = &s
}

// Link returns the value of the "Link" field in the mutation.
func (m *ProductMutation) Link() (r string, exists bool) {
	v := m._Link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "Link" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "Link" field.
func (m *ProductMutation) ClearLink() {
	m._Link = nil
	m.clearedFields[product.FieldLink] = struct{}{}
}

// LinkCleared returns if the "Link" field was cleared in this mutation.
func (m *ProductMutation) LinkCleared() bool {
	_, ok := m.clearedFields[product.FieldLink]
	return ok
}

// ResetLink resets all changes to the "Link" field.
func (m *ProductMutation) ResetLink() {
	m._Link = nil
	delete(m.clearedFields, product.FieldLink)
}

// SetQuantity sets the "Quantity" field.
func (m *ProductMutation) SetQuantity(i int32) {
	m._Quantity = &i
	m.add_Quantity = nil
}

// Quantity returns the value of the "Quantity" field in the mutation.
func (m *ProductMutation) Quantity() (r int32, exists bool) {
	v := m._Quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "Quantity" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldQuantity(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "Quantity" field.
func (m *ProductMutation) AddQuantity(i int32) {
	if m.add_Quantity != nil {
		*m.add_Quantity += i
	} else {
		m.add_Quantity = &i
	}
}

// AddedQuantity returns the value that was added to the "Quantity" field in this mutation.
func (m *ProductMutation) AddedQuantity() (r int32, exists bool) {
	v := m.add_Quantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "Quantity" field.
func (m *ProductMutation) ResetQuantity() {
	m._Quantity = nil
	m.add_Quantity = nil
}

// SetSizes sets the "Sizes" field.
func (m *ProductMutation) SetSizes(pa pq.StringArray) {
	m._Sizes = &pa
}

// Sizes returns the value of the "Sizes" field in the mutation.
func (m *ProductMutation) Sizes() (r pq.StringArray, exists bool) {
	v := m._Sizes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizes returns the old "Sizes" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSizes(ctx context.Context) (v pq.StringArray, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSizes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSizes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizes: %w", err)
	}
	return oldValue.Sizes, nil
}

// ResetSizes resets all changes to the "Sizes" field.
func (m *ProductMutation) ResetSizes() {
	m._Sizes = nil
}

// SetColors sets the "Colors" field.
func (m *ProductMutation) SetColors(pa pq.StringArray) {
	m._Colors = &pa
}

// Colors returns the value of the "Colors" field in the mutation.
func (m *ProductMutation) Colors() (r pq.StringArray, exists bool) {
	v := m._Colors
	if v == nil {
		return
	}
	return *v, true
}

// OldColors returns the old "Colors" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldColors(ctx context.Context) (v pq.StringArray, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldColors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldColors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColors: %w", err)
	}
	return oldValue.Colors, nil
}

// ResetColors resets all changes to the "Colors" field.
func (m *ProductMutation) ResetColors() {
	m._Colors = nil
}

// SetSite sets the "Site" field.
func (m *ProductMutation) SetSite(pr product.Site) {
	m._Site = &pr
}

// Site returns the value of the "Site" field in the mutation.
func (m *ProductMutation) Site() (r product.Site, exists bool) {
	v := m._Site
	if v == nil {
		return
	}
	return *v, true
}

// OldSite returns the old "Site" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSite(ctx context.Context) (v product.Site, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSite: %w", err)
	}
	return oldValue.Site, nil
}

// ResetSite resets all changes to the "Site" field.
func (m *ProductMutation) ResetSite() {
	m._Site = nil
}

// SetMetadata sets the "Metadata" field.
func (m *ProductMutation) SetMetadata(s sonic.Map) {
	m._Metadata = &s
}

// Metadata returns the value of the "Metadata" field in the mutation.
func (m *ProductMutation) Metadata() (r sonic.Map, exists bool) {
	v := m._Metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "Metadata" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMetadata(ctx context.Context) (v sonic.Map, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "Metadata" field.
func (m *ProductMutation) ResetMetadata() {
	m._Metadata = nil
}

// AddTaskIDs adds the "Task" edge to the Task entity by ids.
func (m *ProductMutation) AddTaskIDs(ids ...uuid.UUID) {
	if m._Task == nil {
		m._Task = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Task[ids[i]] = struct{}{}
	}
}

// ClearTask clears the "Task" edge to the Task entity.
func (m *ProductMutation) ClearTask() {
	m.cleared_Task = true
}

// TaskCleared reports if the "Task" edge to the Task entity was cleared.
func (m *ProductMutation) TaskCleared() bool {
	return m.cleared_Task
}

// RemoveTaskIDs removes the "Task" edge to the Task entity by IDs.
func (m *ProductMutation) RemoveTaskIDs(ids ...uuid.UUID) {
	if m.removed_Task == nil {
		m.removed_Task = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_Task[ids[i]] = struct{}{}
	}
}

// RemovedTask returns the removed IDs of the "Task" edge to the Task entity.
func (m *ProductMutation) RemovedTaskIDs() (ids []uuid.UUID) {
	for id := range m.removed_Task {
		ids = append(ids, id)
	}
	return
}

// TaskIDs returns the "Task" edge IDs in the mutation.
func (m *ProductMutation) TaskIDs() (ids []uuid.UUID) {
	for id := range m._Task {
		ids = append(ids, id)
	}
	return
}

// ResetTask resets all changes to the "Task" edge.
func (m *ProductMutation) ResetTask() {
	m._Task = nil
	m.cleared_Task = false
	m.removed_Task = nil
}

// AddStatisticIDs adds the "Statistic" edge to the Statistic entity by ids.
func (m *ProductMutation) AddStatisticIDs(ids ...uuid.UUID) {
	if m._Statistic == nil {
		m._Statistic = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Statistic[ids[i]] = struct{}{}
	}
}

// ClearStatistic clears the "Statistic" edge to the Statistic entity.
func (m *ProductMutation) ClearStatistic() {
	m.cleared_Statistic = true
}

// StatisticCleared reports if the "Statistic" edge to the Statistic entity was cleared.
func (m *ProductMutation) StatisticCleared() bool {
	return m.cleared_Statistic
}

// RemoveStatisticIDs removes the "Statistic" edge to the Statistic entity by IDs.
func (m *ProductMutation) RemoveStatisticIDs(ids ...uuid.UUID) {
	if m.removed_Statistic == nil {
		m.removed_Statistic = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_Statistic[ids[i]] = struct{}{}
	}
}

// RemovedStatistic returns the removed IDs of the "Statistic" edge to the Statistic entity.
func (m *ProductMutation) RemovedStatisticIDs() (ids []uuid.UUID) {
	for id := range m.removed_Statistic {
		ids = append(ids, id)
	}
	return
}

// StatisticIDs returns the "Statistic" edge IDs in the mutation.
func (m *ProductMutation) StatisticIDs() (ids []uuid.UUID) {
	for id := range m._Statistic {
		ids = append(ids, id)
	}
	return
}

// ResetStatistic resets all changes to the "Statistic" edge.
func (m *ProductMutation) ResetStatistic() {
	m._Statistic = nil
	m.cleared_Statistic = false
	m.removed_Statistic = nil
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m._Name != nil {
		fields = append(fields, product.FieldName)
	}
	if m._Image != nil {
		fields = append(fields, product.FieldImage)
	}
	if m._LookupType != nil {
		fields = append(fields, product.FieldLookupType)
	}
	if m._PositiveKeywords != nil {
		fields = append(fields, product.FieldPositiveKeywords)
	}
	if m._NegativeKeywords != nil {
		fields = append(fields, product.FieldNegativeKeywords)
	}
	if m._Link != nil {
		fields = append(fields, product.FieldLink)
	}
	if m._Quantity != nil {
		fields = append(fields, product.FieldQuantity)
	}
	if m._Sizes != nil {
		fields = append(fields, product.FieldSizes)
	}
	if m._Colors != nil {
		fields = append(fields, product.FieldColors)
	}
	if m._Site != nil {
		fields = append(fields, product.FieldSite)
	}
	if m._Metadata != nil {
		fields = append(fields, product.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldName:
		return m.Name()
	case product.FieldImage:
		return m.Image()
	case product.FieldLookupType:
		return m.LookupType()
	case product.FieldPositiveKeywords:
		return m.PositiveKeywords()
	case product.FieldNegativeKeywords:
		return m.NegativeKeywords()
	case product.FieldLink:
		return m.Link()
	case product.FieldQuantity:
		return m.Quantity()
	case product.FieldSizes:
		return m.Sizes()
	case product.FieldColors:
		return m.Colors()
	case product.FieldSite:
		return m.Site()
	case product.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldImage:
		return m.OldImage(ctx)
	case product.FieldLookupType:
		return m.OldLookupType(ctx)
	case product.FieldPositiveKeywords:
		return m.OldPositiveKeywords(ctx)
	case product.FieldNegativeKeywords:
		return m.OldNegativeKeywords(ctx)
	case product.FieldLink:
		return m.OldLink(ctx)
	case product.FieldQuantity:
		return m.OldQuantity(ctx)
	case product.FieldSizes:
		return m.OldSizes(ctx)
	case product.FieldColors:
		return m.OldColors(ctx)
	case product.FieldSite:
		return m.OldSite(ctx)
	case product.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case product.FieldLookupType:
		v, ok := value.(product.LookupType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLookupType(v)
		return nil
	case product.FieldPositiveKeywords:
		v, ok := value.(pq.StringArray)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositiveKeywords(v)
		return nil
	case product.FieldNegativeKeywords:
		v, ok := value.(pq.StringArray)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNegativeKeywords(v)
		return nil
	case product.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case product.FieldQuantity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case product.FieldSizes:
		v, ok := value.(pq.StringArray)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizes(v)
		return nil
	case product.FieldColors:
		v, ok := value.(pq.StringArray)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColors(v)
		return nil
	case product.FieldSite:
		v, ok := value.(product.Site)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSite(v)
		return nil
	case product.FieldMetadata:
		v, ok := value.(sonic.Map)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.add_Quantity != nil {
		fields = append(fields, product.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldQuantity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldImage) {
		fields = append(fields, product.FieldImage)
	}
	if m.FieldCleared(product.FieldPositiveKeywords) {
		fields = append(fields, product.FieldPositiveKeywords)
	}
	if m.FieldCleared(product.FieldNegativeKeywords) {
		fields = append(fields, product.FieldNegativeKeywords)
	}
	if m.FieldCleared(product.FieldLink) {
		fields = append(fields, product.FieldLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldImage:
		m.ClearImage()
		return nil
	case product.FieldPositiveKeywords:
		m.ClearPositiveKeywords()
		return nil
	case product.FieldNegativeKeywords:
		m.ClearNegativeKeywords()
		return nil
	case product.FieldLink:
		m.ClearLink()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldImage:
		m.ResetImage()
		return nil
	case product.FieldLookupType:
		m.ResetLookupType()
		return nil
	case product.FieldPositiveKeywords:
		m.ResetPositiveKeywords()
		return nil
	case product.FieldNegativeKeywords:
		m.ResetNegativeKeywords()
		return nil
	case product.FieldLink:
		m.ResetLink()
		return nil
	case product.FieldQuantity:
		m.ResetQuantity()
		return nil
	case product.FieldSizes:
		m.ResetSizes()
		return nil
	case product.FieldColors:
		m.ResetColors()
		return nil
	case product.FieldSite:
		m.ResetSite()
		return nil
	case product.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._Task != nil {
		edges = append(edges, product.EdgeTask)
	}
	if m._Statistic != nil {
		edges = append(edges, product.EdgeStatistic)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeTask:
		ids := make([]ent.Value, 0, len(m._Task))
		for id := range m._Task {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeStatistic:
		ids := make([]ent.Value, 0, len(m._Statistic))
		for id := range m._Statistic {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_Task != nil {
		edges = append(edges, product.EdgeTask)
	}
	if m.removed_Statistic != nil {
		edges = append(edges, product.EdgeStatistic)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeTask:
		ids := make([]ent.Value, 0, len(m.removed_Task))
		for id := range m.removed_Task {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeStatistic:
		ids := make([]ent.Value, 0, len(m.removed_Statistic))
		for id := range m.removed_Statistic {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_Task {
		edges = append(edges, product.EdgeTask)
	}
	if m.cleared_Statistic {
		edges = append(edges, product.EdgeStatistic)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeTask:
		return m.cleared_Task
	case product.EdgeStatistic:
		return m.cleared_Statistic
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeTask:
		m.ResetTask()
		return nil
	case product.EdgeStatistic:
		m.ResetStatistic()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProfileMutation represents an operation that mutates the Profile nodes in the graph.
type ProfileMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	_Name                *string
	_Email               *string
	clearedFields        map[string]struct{}
	_ProfileGroup        *uuid.UUID
	cleared_ProfileGroup bool
	_Shipping            map[uuid.UUID]struct{}
	removed_Shipping     map[uuid.UUID]struct{}
	cleared_Shipping     bool
	_Billing             map[uuid.UUID]struct{}
	removed_Billing      map[uuid.UUID]struct{}
	cleared_Billing      bool
	done                 bool
	oldValue             func(context.Context) (*Profile, error)
	predicates           []predicate.Profile
}

var _ ent.Mutation = (*ProfileMutation)(nil)

// profileOption allows management of the mutation configuration using functional options.
type profileOption func(*ProfileMutation)

// newProfileMutation creates new mutation for the Profile entity.
func newProfileMutation(c config, op Op, opts ...profileOption) *ProfileMutation {
	m := &ProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfileID sets the ID field of the mutation.
func withProfileID(id uuid.UUID) profileOption {
	return func(m *ProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *Profile
		)
		m.oldValue = func(ctx context.Context) (*Profile, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Profile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfile sets the old Profile of the mutation.
func withProfile(node *Profile) profileOption {
	return func(m *ProfileMutation) {
		m.oldValue = func(context.Context) (*Profile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Profile entities.
func (m *ProfileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProfileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "Name" field.
func (m *ProfileMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *ProfileMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *ProfileMutation) ResetName() {
	m._Name = nil
}

// SetEmail sets the "Email" field.
func (m *ProfileMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the value of the "Email" field in the mutation.
func (m *ProfileMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "Email" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "Email" field.
func (m *ProfileMutation) ResetEmail() {
	m._Email = nil
}

// SetProfileGroupID sets the "ProfileGroup" edge to the ProfileGroup entity by id.
func (m *ProfileMutation) SetProfileGroupID(id uuid.UUID) {
	m._ProfileGroup = &id
}

// ClearProfileGroup clears the "ProfileGroup" edge to the ProfileGroup entity.
func (m *ProfileMutation) ClearProfileGroup() {
	m.cleared_ProfileGroup = true
}

// ProfileGroupCleared reports if the "ProfileGroup" edge to the ProfileGroup entity was cleared.
func (m *ProfileMutation) ProfileGroupCleared() bool {
	return m.cleared_ProfileGroup
}

// ProfileGroupID returns the "ProfileGroup" edge ID in the mutation.
func (m *ProfileMutation) ProfileGroupID() (id uuid.UUID, exists bool) {
	if m._ProfileGroup != nil {
		return *m._ProfileGroup, true
	}
	return
}

// ProfileGroupIDs returns the "ProfileGroup" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileGroupID instead. It exists only for internal usage by the builders.
func (m *ProfileMutation) ProfileGroupIDs() (ids []uuid.UUID) {
	if id := m._ProfileGroup; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfileGroup resets all changes to the "ProfileGroup" edge.
func (m *ProfileMutation) ResetProfileGroup() {
	m._ProfileGroup = nil
	m.cleared_ProfileGroup = false
}

// AddShippingIDs adds the "Shipping" edge to the Shipping entity by ids.
func (m *ProfileMutation) AddShippingIDs(ids ...uuid.UUID) {
	if m._Shipping == nil {
		m._Shipping = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Shipping[ids[i]] = struct{}{}
	}
}

// ClearShipping clears the "Shipping" edge to the Shipping entity.
func (m *ProfileMutation) ClearShipping() {
	m.cleared_Shipping = true
}

// ShippingCleared reports if the "Shipping" edge to the Shipping entity was cleared.
func (m *ProfileMutation) ShippingCleared() bool {
	return m.cleared_Shipping
}

// RemoveShippingIDs removes the "Shipping" edge to the Shipping entity by IDs.
func (m *ProfileMutation) RemoveShippingIDs(ids ...uuid.UUID) {
	if m.removed_Shipping == nil {
		m.removed_Shipping = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_Shipping[ids[i]] = struct{}{}
	}
}

// RemovedShipping returns the removed IDs of the "Shipping" edge to the Shipping entity.
func (m *ProfileMutation) RemovedShippingIDs() (ids []uuid.UUID) {
	for id := range m.removed_Shipping {
		ids = append(ids, id)
	}
	return
}

// ShippingIDs returns the "Shipping" edge IDs in the mutation.
func (m *ProfileMutation) ShippingIDs() (ids []uuid.UUID) {
	for id := range m._Shipping {
		ids = append(ids, id)
	}
	return
}

// ResetShipping resets all changes to the "Shipping" edge.
func (m *ProfileMutation) ResetShipping() {
	m._Shipping = nil
	m.cleared_Shipping = false
	m.removed_Shipping = nil
}

// AddBillingIDs adds the "Billing" edge to the Billing entity by ids.
func (m *ProfileMutation) AddBillingIDs(ids ...uuid.UUID) {
	if m._Billing == nil {
		m._Billing = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Billing[ids[i]] = struct{}{}
	}
}

// ClearBilling clears the "Billing" edge to the Billing entity.
func (m *ProfileMutation) ClearBilling() {
	m.cleared_Billing = true
}

// BillingCleared reports if the "Billing" edge to the Billing entity was cleared.
func (m *ProfileMutation) BillingCleared() bool {
	return m.cleared_Billing
}

// RemoveBillingIDs removes the "Billing" edge to the Billing entity by IDs.
func (m *ProfileMutation) RemoveBillingIDs(ids ...uuid.UUID) {
	if m.removed_Billing == nil {
		m.removed_Billing = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_Billing[ids[i]] = struct{}{}
	}
}

// RemovedBilling returns the removed IDs of the "Billing" edge to the Billing entity.
func (m *ProfileMutation) RemovedBillingIDs() (ids []uuid.UUID) {
	for id := range m.removed_Billing {
		ids = append(ids, id)
	}
	return
}

// BillingIDs returns the "Billing" edge IDs in the mutation.
func (m *ProfileMutation) BillingIDs() (ids []uuid.UUID) {
	for id := range m._Billing {
		ids = append(ids, id)
	}
	return
}

// ResetBilling resets all changes to the "Billing" edge.
func (m *ProfileMutation) ResetBilling() {
	m._Billing = nil
	m.cleared_Billing = false
	m.removed_Billing = nil
}

// Op returns the operation name.
func (m *ProfileMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Profile).
func (m *ProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfileMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, profile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, profile.FieldUpdatedAt)
	}
	if m._Name != nil {
		fields = append(fields, profile.FieldName)
	}
	if m._Email != nil {
		fields = append(fields, profile.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profile.FieldCreatedAt:
		return m.CreatedAt()
	case profile.FieldUpdatedAt:
		return m.UpdatedAt()
	case profile.FieldName:
		return m.Name()
	case profile.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case profile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case profile.FieldName:
		return m.OldName(ctx)
	case profile.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown Profile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case profile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case profile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case profile.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Profile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Profile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfileMutation) ResetField(name string) error {
	switch name {
	case profile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case profile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case profile.FieldName:
		m.ResetName()
		return nil
	case profile.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._ProfileGroup != nil {
		edges = append(edges, profile.EdgeProfileGroup)
	}
	if m._Shipping != nil {
		edges = append(edges, profile.EdgeShipping)
	}
	if m._Billing != nil {
		edges = append(edges, profile.EdgeBilling)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeProfileGroup:
		if id := m._ProfileGroup; id != nil {
			return []ent.Value{*id}
		}
	case profile.EdgeShipping:
		ids := make([]ent.Value, 0, len(m._Shipping))
		for id := range m._Shipping {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeBilling:
		ids := make([]ent.Value, 0, len(m._Billing))
		for id := range m._Billing {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_Shipping != nil {
		edges = append(edges, profile.EdgeShipping)
	}
	if m.removed_Billing != nil {
		edges = append(edges, profile.EdgeBilling)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeShipping:
		ids := make([]ent.Value, 0, len(m.removed_Shipping))
		for id := range m.removed_Shipping {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeBilling:
		ids := make([]ent.Value, 0, len(m.removed_Billing))
		for id := range m.removed_Billing {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_ProfileGroup {
		edges = append(edges, profile.EdgeProfileGroup)
	}
	if m.cleared_Shipping {
		edges = append(edges, profile.EdgeShipping)
	}
	if m.cleared_Billing {
		edges = append(edges, profile.EdgeBilling)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case profile.EdgeProfileGroup:
		return m.cleared_ProfileGroup
	case profile.EdgeShipping:
		return m.cleared_Shipping
	case profile.EdgeBilling:
		return m.cleared_Billing
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfileMutation) ClearEdge(name string) error {
	switch name {
	case profile.EdgeProfileGroup:
		m.ClearProfileGroup()
		return nil
	}
	return fmt.Errorf("unknown Profile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfileMutation) ResetEdge(name string) error {
	switch name {
	case profile.EdgeProfileGroup:
		m.ResetProfileGroup()
		return nil
	case profile.EdgeShipping:
		m.ResetShipping()
		return nil
	case profile.EdgeBilling:
		m.ResetBilling()
		return nil
	}
	return fmt.Errorf("unknown Profile edge %s", name)
}

// ProfileGroupMutation represents an operation that mutates the ProfileGroup nodes in the graph.
type ProfileGroupMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	_Name            *string
	clearedFields    map[string]struct{}
	_Profiles        map[uuid.UUID]struct{}
	removed_Profiles map[uuid.UUID]struct{}
	cleared_Profiles bool
	_App             map[uuid.UUID]struct{}
	removed_App      map[uuid.UUID]struct{}
	cleared_App      bool
	_Task            map[uuid.UUID]struct{}
	removed_Task     map[uuid.UUID]struct{}
	cleared_Task     bool
	done             bool
	oldValue         func(context.Context) (*ProfileGroup, error)
	predicates       []predicate.ProfileGroup
}

var _ ent.Mutation = (*ProfileGroupMutation)(nil)

// profilegroupOption allows management of the mutation configuration using functional options.
type profilegroupOption func(*ProfileGroupMutation)

// newProfileGroupMutation creates new mutation for the ProfileGroup entity.
func newProfileGroupMutation(c config, op Op, opts ...profilegroupOption) *ProfileGroupMutation {
	m := &ProfileGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeProfileGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfileGroupID sets the ID field of the mutation.
func withProfileGroupID(id uuid.UUID) profilegroupOption {
	return func(m *ProfileGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *ProfileGroup
		)
		m.oldValue = func(ctx context.Context) (*ProfileGroup, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProfileGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfileGroup sets the old ProfileGroup of the mutation.
func withProfileGroup(node *ProfileGroup) profilegroupOption {
	return func(m *ProfileGroupMutation) {
		m.oldValue = func(context.Context) (*ProfileGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfileGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfileGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProfileGroup entities.
func (m *ProfileGroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProfileGroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProfileGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProfileGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProfileGroup entity.
// If the ProfileGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProfileGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProfileGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProfileGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProfileGroup entity.
// If the ProfileGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProfileGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "Name" field.
func (m *ProfileGroupMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *ProfileGroupMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the ProfileGroup entity.
// If the ProfileGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *ProfileGroupMutation) ResetName() {
	m._Name = nil
}

// AddProfileIDs adds the "Profiles" edge to the Profile entity by ids.
func (m *ProfileGroupMutation) AddProfileIDs(ids ...uuid.UUID) {
	if m._Profiles == nil {
		m._Profiles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Profiles[ids[i]] = struct{}{}
	}
}

// ClearProfiles clears the "Profiles" edge to the Profile entity.
func (m *ProfileGroupMutation) ClearProfiles() {
	m.cleared_Profiles = true
}

// ProfilesCleared reports if the "Profiles" edge to the Profile entity was cleared.
func (m *ProfileGroupMutation) ProfilesCleared() bool {
	return m.cleared_Profiles
}

// RemoveProfileIDs removes the "Profiles" edge to the Profile entity by IDs.
func (m *ProfileGroupMutation) RemoveProfileIDs(ids ...uuid.UUID) {
	if m.removed_Profiles == nil {
		m.removed_Profiles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_Profiles[ids[i]] = struct{}{}
	}
}

// RemovedProfiles returns the removed IDs of the "Profiles" edge to the Profile entity.
func (m *ProfileGroupMutation) RemovedProfilesIDs() (ids []uuid.UUID) {
	for id := range m.removed_Profiles {
		ids = append(ids, id)
	}
	return
}

// ProfilesIDs returns the "Profiles" edge IDs in the mutation.
func (m *ProfileGroupMutation) ProfilesIDs() (ids []uuid.UUID) {
	for id := range m._Profiles {
		ids = append(ids, id)
	}
	return
}

// ResetProfiles resets all changes to the "Profiles" edge.
func (m *ProfileGroupMutation) ResetProfiles() {
	m._Profiles = nil
	m.cleared_Profiles = false
	m.removed_Profiles = nil
}

// AddAppIDs adds the "App" edge to the App entity by ids.
func (m *ProfileGroupMutation) AddAppIDs(ids ...uuid.UUID) {
	if m._App == nil {
		m._App = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._App[ids[i]] = struct{}{}
	}
}

// ClearApp clears the "App" edge to the App entity.
func (m *ProfileGroupMutation) ClearApp() {
	m.cleared_App = true
}

// AppCleared reports if the "App" edge to the App entity was cleared.
func (m *ProfileGroupMutation) AppCleared() bool {
	return m.cleared_App
}

// RemoveAppIDs removes the "App" edge to the App entity by IDs.
func (m *ProfileGroupMutation) RemoveAppIDs(ids ...uuid.UUID) {
	if m.removed_App == nil {
		m.removed_App = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_App[ids[i]] = struct{}{}
	}
}

// RemovedApp returns the removed IDs of the "App" edge to the App entity.
func (m *ProfileGroupMutation) RemovedAppIDs() (ids []uuid.UUID) {
	for id := range m.removed_App {
		ids = append(ids, id)
	}
	return
}

// AppIDs returns the "App" edge IDs in the mutation.
func (m *ProfileGroupMutation) AppIDs() (ids []uuid.UUID) {
	for id := range m._App {
		ids = append(ids, id)
	}
	return
}

// ResetApp resets all changes to the "App" edge.
func (m *ProfileGroupMutation) ResetApp() {
	m._App = nil
	m.cleared_App = false
	m.removed_App = nil
}

// AddTaskIDs adds the "Task" edge to the Task entity by ids.
func (m *ProfileGroupMutation) AddTaskIDs(ids ...uuid.UUID) {
	if m._Task == nil {
		m._Task = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Task[ids[i]] = struct{}{}
	}
}

// ClearTask clears the "Task" edge to the Task entity.
func (m *ProfileGroupMutation) ClearTask() {
	m.cleared_Task = true
}

// TaskCleared reports if the "Task" edge to the Task entity was cleared.
func (m *ProfileGroupMutation) TaskCleared() bool {
	return m.cleared_Task
}

// RemoveTaskIDs removes the "Task" edge to the Task entity by IDs.
func (m *ProfileGroupMutation) RemoveTaskIDs(ids ...uuid.UUID) {
	if m.removed_Task == nil {
		m.removed_Task = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_Task[ids[i]] = struct{}{}
	}
}

// RemovedTask returns the removed IDs of the "Task" edge to the Task entity.
func (m *ProfileGroupMutation) RemovedTaskIDs() (ids []uuid.UUID) {
	for id := range m.removed_Task {
		ids = append(ids, id)
	}
	return
}

// TaskIDs returns the "Task" edge IDs in the mutation.
func (m *ProfileGroupMutation) TaskIDs() (ids []uuid.UUID) {
	for id := range m._Task {
		ids = append(ids, id)
	}
	return
}

// ResetTask resets all changes to the "Task" edge.
func (m *ProfileGroupMutation) ResetTask() {
	m._Task = nil
	m.cleared_Task = false
	m.removed_Task = nil
}

// Op returns the operation name.
func (m *ProfileGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProfileGroup).
func (m *ProfileGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfileGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, profilegroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, profilegroup.FieldUpdatedAt)
	}
	if m._Name != nil {
		fields = append(fields, profilegroup.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfileGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profilegroup.FieldCreatedAt:
		return m.CreatedAt()
	case profilegroup.FieldUpdatedAt:
		return m.UpdatedAt()
	case profilegroup.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfileGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profilegroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case profilegroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case profilegroup.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ProfileGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profilegroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case profilegroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case profilegroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ProfileGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfileGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfileGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProfileGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfileGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfileGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfileGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProfileGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfileGroupMutation) ResetField(name string) error {
	switch name {
	case profilegroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case profilegroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case profilegroup.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ProfileGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfileGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Profiles != nil {
		edges = append(edges, profilegroup.EdgeProfiles)
	}
	if m._App != nil {
		edges = append(edges, profilegroup.EdgeApp)
	}
	if m._Task != nil {
		edges = append(edges, profilegroup.EdgeTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfileGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profilegroup.EdgeProfiles:
		ids := make([]ent.Value, 0, len(m._Profiles))
		for id := range m._Profiles {
			ids = append(ids, id)
		}
		return ids
	case profilegroup.EdgeApp:
		ids := make([]ent.Value, 0, len(m._App))
		for id := range m._App {
			ids = append(ids, id)
		}
		return ids
	case profilegroup.EdgeTask:
		ids := make([]ent.Value, 0, len(m._Task))
		for id := range m._Task {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfileGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_Profiles != nil {
		edges = append(edges, profilegroup.EdgeProfiles)
	}
	if m.removed_App != nil {
		edges = append(edges, profilegroup.EdgeApp)
	}
	if m.removed_Task != nil {
		edges = append(edges, profilegroup.EdgeTask)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfileGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case profilegroup.EdgeProfiles:
		ids := make([]ent.Value, 0, len(m.removed_Profiles))
		for id := range m.removed_Profiles {
			ids = append(ids, id)
		}
		return ids
	case profilegroup.EdgeApp:
		ids := make([]ent.Value, 0, len(m.removed_App))
		for id := range m.removed_App {
			ids = append(ids, id)
		}
		return ids
	case profilegroup.EdgeTask:
		ids := make([]ent.Value, 0, len(m.removed_Task))
		for id := range m.removed_Task {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfileGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Profiles {
		edges = append(edges, profilegroup.EdgeProfiles)
	}
	if m.cleared_App {
		edges = append(edges, profilegroup.EdgeApp)
	}
	if m.cleared_Task {
		edges = append(edges, profilegroup.EdgeTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfileGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case profilegroup.EdgeProfiles:
		return m.cleared_Profiles
	case profilegroup.EdgeApp:
		return m.cleared_App
	case profilegroup.EdgeTask:
		return m.cleared_Task
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfileGroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProfileGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfileGroupMutation) ResetEdge(name string) error {
	switch name {
	case profilegroup.EdgeProfiles:
		m.ResetProfiles()
		return nil
	case profilegroup.EdgeApp:
		m.ResetApp()
		return nil
	case profilegroup.EdgeTask:
		m.ResetTask()
		return nil
	}
	return fmt.Errorf("unknown ProfileGroup edge %s", name)
}

// ProxyMutation represents an operation that mutates the Proxy nodes in the graph.
type ProxyMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	_Username         *string
	_Password         *string
	_IP               *string
	_Port             *string
	clearedFields     map[string]struct{}
	_ProxyList        *uuid.UUID
	cleared_ProxyList bool
	done              bool
	oldValue          func(context.Context) (*Proxy, error)
	predicates        []predicate.Proxy
}

var _ ent.Mutation = (*ProxyMutation)(nil)

// proxyOption allows management of the mutation configuration using functional options.
type proxyOption func(*ProxyMutation)

// newProxyMutation creates new mutation for the Proxy entity.
func newProxyMutation(c config, op Op, opts ...proxyOption) *ProxyMutation {
	m := &ProxyMutation{
		config:        c,
		op:            op,
		typ:           TypeProxy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProxyID sets the ID field of the mutation.
func withProxyID(id uuid.UUID) proxyOption {
	return func(m *ProxyMutation) {
		var (
			err   error
			once  sync.Once
			value *Proxy
		)
		m.oldValue = func(ctx context.Context) (*Proxy, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Proxy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProxy sets the old Proxy of the mutation.
func withProxy(node *Proxy) proxyOption {
	return func(m *ProxyMutation) {
		m.oldValue = func(context.Context) (*Proxy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProxyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProxyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Proxy entities.
func (m *ProxyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProxyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProxyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProxyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProxyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProxyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProxyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProxyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "Username" field.
func (m *ProxyMutation) SetUsername(s string) {
	m._Username = &s
}

// Username returns the value of the "Username" field in the mutation.
func (m *ProxyMutation) Username() (r string, exists bool) {
	v := m._Username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "Username" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "Username" field.
func (m *ProxyMutation) ClearUsername() {
	m._Username = nil
	m.clearedFields[proxy.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "Username" field was cleared in this mutation.
func (m *ProxyMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[proxy.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "Username" field.
func (m *ProxyMutation) ResetUsername() {
	m._Username = nil
	delete(m.clearedFields, proxy.FieldUsername)
}

// SetPassword sets the "Password" field.
func (m *ProxyMutation) SetPassword(s string) {
	m._Password = &s
}

// Password returns the value of the "Password" field in the mutation.
func (m *ProxyMutation) Password() (r string, exists bool) {
	v := m._Password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "Password" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "Password" field.
func (m *ProxyMutation) ClearPassword() {
	m._Password = nil
	m.clearedFields[proxy.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "Password" field was cleared in this mutation.
func (m *ProxyMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[proxy.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "Password" field.
func (m *ProxyMutation) ResetPassword() {
	m._Password = nil
	delete(m.clearedFields, proxy.FieldPassword)
}

// SetIP sets the "IP" field.
func (m *ProxyMutation) SetIP(s string) {
	m._IP = &s
}

// IP returns the value of the "IP" field in the mutation.
func (m *ProxyMutation) IP() (r string, exists bool) {
	v := m._IP
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "IP" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "IP" field.
func (m *ProxyMutation) ResetIP() {
	m._IP = nil
}

// SetPort sets the "Port" field.
func (m *ProxyMutation) SetPort(s string) {
	m._Port = &s
}

// Port returns the value of the "Port" field in the mutation.
func (m *ProxyMutation) Port() (r string, exists bool) {
	v := m._Port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "Port" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldPort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// ResetPort resets all changes to the "Port" field.
func (m *ProxyMutation) ResetPort() {
	m._Port = nil
}

// SetProxyListID sets the "ProxyList" edge to the ProxyList entity by id.
func (m *ProxyMutation) SetProxyListID(id uuid.UUID) {
	m._ProxyList = &id
}

// ClearProxyList clears the "ProxyList" edge to the ProxyList entity.
func (m *ProxyMutation) ClearProxyList() {
	m.cleared_ProxyList = true
}

// ProxyListCleared reports if the "ProxyList" edge to the ProxyList entity was cleared.
func (m *ProxyMutation) ProxyListCleared() bool {
	return m.cleared_ProxyList
}

// ProxyListID returns the "ProxyList" edge ID in the mutation.
func (m *ProxyMutation) ProxyListID() (id uuid.UUID, exists bool) {
	if m._ProxyList != nil {
		return *m._ProxyList, true
	}
	return
}

// ProxyListIDs returns the "ProxyList" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProxyListID instead. It exists only for internal usage by the builders.
func (m *ProxyMutation) ProxyListIDs() (ids []uuid.UUID) {
	if id := m._ProxyList; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProxyList resets all changes to the "ProxyList" edge.
func (m *ProxyMutation) ResetProxyList() {
	m._ProxyList = nil
	m.cleared_ProxyList = false
}

// Op returns the operation name.
func (m *ProxyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Proxy).
func (m *ProxyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProxyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, proxy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, proxy.FieldUpdatedAt)
	}
	if m._Username != nil {
		fields = append(fields, proxy.FieldUsername)
	}
	if m._Password != nil {
		fields = append(fields, proxy.FieldPassword)
	}
	if m._IP != nil {
		fields = append(fields, proxy.FieldIP)
	}
	if m._Port != nil {
		fields = append(fields, proxy.FieldPort)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProxyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case proxy.FieldCreatedAt:
		return m.CreatedAt()
	case proxy.FieldUpdatedAt:
		return m.UpdatedAt()
	case proxy.FieldUsername:
		return m.Username()
	case proxy.FieldPassword:
		return m.Password()
	case proxy.FieldIP:
		return m.IP()
	case proxy.FieldPort:
		return m.Port()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProxyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case proxy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case proxy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case proxy.FieldUsername:
		return m.OldUsername(ctx)
	case proxy.FieldPassword:
		return m.OldPassword(ctx)
	case proxy.FieldIP:
		return m.OldIP(ctx)
	case proxy.FieldPort:
		return m.OldPort(ctx)
	}
	return nil, fmt.Errorf("unknown Proxy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProxyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case proxy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case proxy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case proxy.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case proxy.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case proxy.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case proxy.FieldPort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	}
	return fmt.Errorf("unknown Proxy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProxyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProxyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProxyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Proxy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProxyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(proxy.FieldUsername) {
		fields = append(fields, proxy.FieldUsername)
	}
	if m.FieldCleared(proxy.FieldPassword) {
		fields = append(fields, proxy.FieldPassword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProxyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProxyMutation) ClearField(name string) error {
	switch name {
	case proxy.FieldUsername:
		m.ClearUsername()
		return nil
	case proxy.FieldPassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown Proxy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProxyMutation) ResetField(name string) error {
	switch name {
	case proxy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case proxy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case proxy.FieldUsername:
		m.ResetUsername()
		return nil
	case proxy.FieldPassword:
		m.ResetPassword()
		return nil
	case proxy.FieldIP:
		m.ResetIP()
		return nil
	case proxy.FieldPort:
		m.ResetPort()
		return nil
	}
	return fmt.Errorf("unknown Proxy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProxyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._ProxyList != nil {
		edges = append(edges, proxy.EdgeProxyList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProxyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case proxy.EdgeProxyList:
		if id := m._ProxyList; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProxyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProxyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProxyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_ProxyList {
		edges = append(edges, proxy.EdgeProxyList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProxyMutation) EdgeCleared(name string) bool {
	switch name {
	case proxy.EdgeProxyList:
		return m.cleared_ProxyList
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProxyMutation) ClearEdge(name string) error {
	switch name {
	case proxy.EdgeProxyList:
		m.ClearProxyList()
		return nil
	}
	return fmt.Errorf("unknown Proxy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProxyMutation) ResetEdge(name string) error {
	switch name {
	case proxy.EdgeProxyList:
		m.ResetProxyList()
		return nil
	}
	return fmt.Errorf("unknown Proxy edge %s", name)
}

// ProxyListMutation represents an operation that mutates the ProxyList nodes in the graph.
type ProxyListMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	_Name           *string
	_Type           *proxylist.Type
	clearedFields   map[string]struct{}
	_App            map[uuid.UUID]struct{}
	removed_App     map[uuid.UUID]struct{}
	cleared_App     bool
	_Proxies        map[uuid.UUID]struct{}
	removed_Proxies map[uuid.UUID]struct{}
	cleared_Proxies bool
	_Task           map[uuid.UUID]struct{}
	removed_Task    map[uuid.UUID]struct{}
	cleared_Task    bool
	done            bool
	oldValue        func(context.Context) (*ProxyList, error)
	predicates      []predicate.ProxyList
}

var _ ent.Mutation = (*ProxyListMutation)(nil)

// proxylistOption allows management of the mutation configuration using functional options.
type proxylistOption func(*ProxyListMutation)

// newProxyListMutation creates new mutation for the ProxyList entity.
func newProxyListMutation(c config, op Op, opts ...proxylistOption) *ProxyListMutation {
	m := &ProxyListMutation{
		config:        c,
		op:            op,
		typ:           TypeProxyList,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProxyListID sets the ID field of the mutation.
func withProxyListID(id uuid.UUID) proxylistOption {
	return func(m *ProxyListMutation) {
		var (
			err   error
			once  sync.Once
			value *ProxyList
		)
		m.oldValue = func(ctx context.Context) (*ProxyList, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProxyList.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProxyList sets the old ProxyList of the mutation.
func withProxyList(node *ProxyList) proxylistOption {
	return func(m *ProxyListMutation) {
		m.oldValue = func(context.Context) (*ProxyList, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProxyListMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProxyListMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProxyList entities.
func (m *ProxyListMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ProxyListMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProxyListMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProxyListMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProxyList entity.
// If the ProxyList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyListMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProxyListMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProxyListMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProxyListMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProxyList entity.
// If the ProxyList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyListMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProxyListMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "Name" field.
func (m *ProxyListMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *ProxyListMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the ProxyList entity.
// If the ProxyList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyListMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *ProxyListMutation) ResetName() {
	m._Name = nil
}

// SetType sets the "Type" field.
func (m *ProxyListMutation) SetType(pr proxylist.Type) {
	m._Type = &pr
}

// GetType returns the value of the "Type" field in the mutation.
func (m *ProxyListMutation) GetType() (r proxylist.Type, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the ProxyList entity.
// If the ProxyList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyListMutation) OldType(ctx context.Context) (v proxylist.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "Type" field.
func (m *ProxyListMutation) ResetType() {
	m._Type = nil
}

// AddAppIDs adds the "App" edge to the App entity by ids.
func (m *ProxyListMutation) AddAppIDs(ids ...uuid.UUID) {
	if m._App == nil {
		m._App = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._App[ids[i]] = struct{}{}
	}
}

// ClearApp clears the "App" edge to the App entity.
func (m *ProxyListMutation) ClearApp() {
	m.cleared_App = true
}

// AppCleared reports if the "App" edge to the App entity was cleared.
func (m *ProxyListMutation) AppCleared() bool {
	return m.cleared_App
}

// RemoveAppIDs removes the "App" edge to the App entity by IDs.
func (m *ProxyListMutation) RemoveAppIDs(ids ...uuid.UUID) {
	if m.removed_App == nil {
		m.removed_App = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_App[ids[i]] = struct{}{}
	}
}

// RemovedApp returns the removed IDs of the "App" edge to the App entity.
func (m *ProxyListMutation) RemovedAppIDs() (ids []uuid.UUID) {
	for id := range m.removed_App {
		ids = append(ids, id)
	}
	return
}

// AppIDs returns the "App" edge IDs in the mutation.
func (m *ProxyListMutation) AppIDs() (ids []uuid.UUID) {
	for id := range m._App {
		ids = append(ids, id)
	}
	return
}

// ResetApp resets all changes to the "App" edge.
func (m *ProxyListMutation) ResetApp() {
	m._App = nil
	m.cleared_App = false
	m.removed_App = nil
}

// AddProxyIDs adds the "Proxies" edge to the Proxy entity by ids.
func (m *ProxyListMutation) AddProxyIDs(ids ...uuid.UUID) {
	if m._Proxies == nil {
		m._Proxies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Proxies[ids[i]] = struct{}{}
	}
}

// ClearProxies clears the "Proxies" edge to the Proxy entity.
func (m *ProxyListMutation) ClearProxies() {
	m.cleared_Proxies = true
}

// ProxiesCleared reports if the "Proxies" edge to the Proxy entity was cleared.
func (m *ProxyListMutation) ProxiesCleared() bool {
	return m.cleared_Proxies
}

// RemoveProxyIDs removes the "Proxies" edge to the Proxy entity by IDs.
func (m *ProxyListMutation) RemoveProxyIDs(ids ...uuid.UUID) {
	if m.removed_Proxies == nil {
		m.removed_Proxies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_Proxies[ids[i]] = struct{}{}
	}
}

// RemovedProxies returns the removed IDs of the "Proxies" edge to the Proxy entity.
func (m *ProxyListMutation) RemovedProxiesIDs() (ids []uuid.UUID) {
	for id := range m.removed_Proxies {
		ids = append(ids, id)
	}
	return
}

// ProxiesIDs returns the "Proxies" edge IDs in the mutation.
func (m *ProxyListMutation) ProxiesIDs() (ids []uuid.UUID) {
	for id := range m._Proxies {
		ids = append(ids, id)
	}
	return
}

// ResetProxies resets all changes to the "Proxies" edge.
func (m *ProxyListMutation) ResetProxies() {
	m._Proxies = nil
	m.cleared_Proxies = false
	m.removed_Proxies = nil
}

// AddTaskIDs adds the "Task" edge to the Task entity by ids.
func (m *ProxyListMutation) AddTaskIDs(ids ...uuid.UUID) {
	if m._Task == nil {
		m._Task = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Task[ids[i]] = struct{}{}
	}
}

// ClearTask clears the "Task" edge to the Task entity.
func (m *ProxyListMutation) ClearTask() {
	m.cleared_Task = true
}

// TaskCleared reports if the "Task" edge to the Task entity was cleared.
func (m *ProxyListMutation) TaskCleared() bool {
	return m.cleared_Task
}

// RemoveTaskIDs removes the "Task" edge to the Task entity by IDs.
func (m *ProxyListMutation) RemoveTaskIDs(ids ...uuid.UUID) {
	if m.removed_Task == nil {
		m.removed_Task = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_Task[ids[i]] = struct{}{}
	}
}

// RemovedTask returns the removed IDs of the "Task" edge to the Task entity.
func (m *ProxyListMutation) RemovedTaskIDs() (ids []uuid.UUID) {
	for id := range m.removed_Task {
		ids = append(ids, id)
	}
	return
}

// TaskIDs returns the "Task" edge IDs in the mutation.
func (m *ProxyListMutation) TaskIDs() (ids []uuid.UUID) {
	for id := range m._Task {
		ids = append(ids, id)
	}
	return
}

// ResetTask resets all changes to the "Task" edge.
func (m *ProxyListMutation) ResetTask() {
	m._Task = nil
	m.cleared_Task = false
	m.removed_Task = nil
}

// Op returns the operation name.
func (m *ProxyListMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProxyList).
func (m *ProxyListMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProxyListMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, proxylist.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, proxylist.FieldUpdatedAt)
	}
	if m._Name != nil {
		fields = append(fields, proxylist.FieldName)
	}
	if m._Type != nil {
		fields = append(fields, proxylist.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProxyListMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case proxylist.FieldCreatedAt:
		return m.CreatedAt()
	case proxylist.FieldUpdatedAt:
		return m.UpdatedAt()
	case proxylist.FieldName:
		return m.Name()
	case proxylist.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProxyListMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case proxylist.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case proxylist.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case proxylist.FieldName:
		return m.OldName(ctx)
	case proxylist.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown ProxyList field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProxyListMutation) SetField(name string, value ent.Value) error {
	switch name {
	case proxylist.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case proxylist.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case proxylist.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case proxylist.FieldType:
		v, ok := value.(proxylist.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown ProxyList field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProxyListMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProxyListMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProxyListMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProxyList numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProxyListMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProxyListMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProxyListMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProxyList nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProxyListMutation) ResetField(name string) error {
	switch name {
	case proxylist.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case proxylist.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case proxylist.FieldName:
		m.ResetName()
		return nil
	case proxylist.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown ProxyList field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProxyListMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._App != nil {
		edges = append(edges, proxylist.EdgeApp)
	}
	if m._Proxies != nil {
		edges = append(edges, proxylist.EdgeProxies)
	}
	if m._Task != nil {
		edges = append(edges, proxylist.EdgeTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProxyListMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case proxylist.EdgeApp:
		ids := make([]ent.Value, 0, len(m._App))
		for id := range m._App {
			ids = append(ids, id)
		}
		return ids
	case proxylist.EdgeProxies:
		ids := make([]ent.Value, 0, len(m._Proxies))
		for id := range m._Proxies {
			ids = append(ids, id)
		}
		return ids
	case proxylist.EdgeTask:
		ids := make([]ent.Value, 0, len(m._Task))
		for id := range m._Task {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProxyListMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_App != nil {
		edges = append(edges, proxylist.EdgeApp)
	}
	if m.removed_Proxies != nil {
		edges = append(edges, proxylist.EdgeProxies)
	}
	if m.removed_Task != nil {
		edges = append(edges, proxylist.EdgeTask)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProxyListMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case proxylist.EdgeApp:
		ids := make([]ent.Value, 0, len(m.removed_App))
		for id := range m.removed_App {
			ids = append(ids, id)
		}
		return ids
	case proxylist.EdgeProxies:
		ids := make([]ent.Value, 0, len(m.removed_Proxies))
		for id := range m.removed_Proxies {
			ids = append(ids, id)
		}
		return ids
	case proxylist.EdgeTask:
		ids := make([]ent.Value, 0, len(m.removed_Task))
		for id := range m.removed_Task {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProxyListMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_App {
		edges = append(edges, proxylist.EdgeApp)
	}
	if m.cleared_Proxies {
		edges = append(edges, proxylist.EdgeProxies)
	}
	if m.cleared_Task {
		edges = append(edges, proxylist.EdgeTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProxyListMutation) EdgeCleared(name string) bool {
	switch name {
	case proxylist.EdgeApp:
		return m.cleared_App
	case proxylist.EdgeProxies:
		return m.cleared_Proxies
	case proxylist.EdgeTask:
		return m.cleared_Task
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProxyListMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProxyList unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProxyListMutation) ResetEdge(name string) error {
	switch name {
	case proxylist.EdgeApp:
		m.ResetApp()
		return nil
	case proxylist.EdgeProxies:
		m.ResetProxies()
		return nil
	case proxylist.EdgeTask:
		m.ResetTask()
		return nil
	}
	return fmt.Errorf("unknown ProxyList edge %s", name)
}

// SettingsMutation represents an operation that mutates the Settings nodes in the graph.
type SettingsMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	_SuccessWebhook   *string
	_DeclineWebhook   *string
	_CheckoutDelay    *int32
	add_CheckoutDelay *int32
	_ATCDelay         *int32
	add_ATCDelay      *int32
	clearedFields     map[string]struct{}
	_App              *uuid.UUID
	cleared_App       bool
	done              bool
	oldValue          func(context.Context) (*Settings, error)
	predicates        []predicate.Settings
}

var _ ent.Mutation = (*SettingsMutation)(nil)

// settingsOption allows management of the mutation configuration using functional options.
type settingsOption func(*SettingsMutation)

// newSettingsMutation creates new mutation for the Settings entity.
func newSettingsMutation(c config, op Op, opts ...settingsOption) *SettingsMutation {
	m := &SettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingsID sets the ID field of the mutation.
func withSettingsID(id uuid.UUID) settingsOption {
	return func(m *SettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *Settings
		)
		m.oldValue = func(ctx context.Context) (*Settings, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Settings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSettings sets the old Settings of the mutation.
func withSettings(node *Settings) settingsOption {
	return func(m *SettingsMutation) {
		m.oldValue = func(context.Context) (*Settings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Settings entities.
func (m *SettingsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *SettingsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *SettingsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettingsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettingsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSuccessWebhook sets the "SuccessWebhook" field.
func (m *SettingsMutation) SetSuccessWebhook(s string) {
	m._SuccessWebhook = &s
}

// SuccessWebhook returns the value of the "SuccessWebhook" field in the mutation.
func (m *SettingsMutation) SuccessWebhook() (r string, exists bool) {
	v := m._SuccessWebhook
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessWebhook returns the old "SuccessWebhook" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSuccessWebhook(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSuccessWebhook is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSuccessWebhook requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessWebhook: %w", err)
	}
	return oldValue.SuccessWebhook, nil
}

// ResetSuccessWebhook resets all changes to the "SuccessWebhook" field.
func (m *SettingsMutation) ResetSuccessWebhook() {
	m._SuccessWebhook = nil
}

// SetDeclineWebhook sets the "DeclineWebhook" field.
func (m *SettingsMutation) SetDeclineWebhook(s string) {
	m._DeclineWebhook = &s
}

// DeclineWebhook returns the value of the "DeclineWebhook" field in the mutation.
func (m *SettingsMutation) DeclineWebhook() (r string, exists bool) {
	v := m._DeclineWebhook
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclineWebhook returns the old "DeclineWebhook" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldDeclineWebhook(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeclineWebhook is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeclineWebhook requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclineWebhook: %w", err)
	}
	return oldValue.DeclineWebhook, nil
}

// ResetDeclineWebhook resets all changes to the "DeclineWebhook" field.
func (m *SettingsMutation) ResetDeclineWebhook() {
	m._DeclineWebhook = nil
}

// SetCheckoutDelay sets the "CheckoutDelay" field.
func (m *SettingsMutation) SetCheckoutDelay(i int32) {
	m._CheckoutDelay = &i
	m.add_CheckoutDelay = nil
}

// CheckoutDelay returns the value of the "CheckoutDelay" field in the mutation.
func (m *SettingsMutation) CheckoutDelay() (r int32, exists bool) {
	v := m._CheckoutDelay
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckoutDelay returns the old "CheckoutDelay" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldCheckoutDelay(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckoutDelay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckoutDelay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckoutDelay: %w", err)
	}
	return oldValue.CheckoutDelay, nil
}

// AddCheckoutDelay adds i to the "CheckoutDelay" field.
func (m *SettingsMutation) AddCheckoutDelay(i int32) {
	if m.add_CheckoutDelay != nil {
		*m.add_CheckoutDelay += i
	} else {
		m.add_CheckoutDelay = &i
	}
}

// AddedCheckoutDelay returns the value that was added to the "CheckoutDelay" field in this mutation.
func (m *SettingsMutation) AddedCheckoutDelay() (r int32, exists bool) {
	v := m.add_CheckoutDelay
	if v == nil {
		return
	}
	return *v, true
}

// ResetCheckoutDelay resets all changes to the "CheckoutDelay" field.
func (m *SettingsMutation) ResetCheckoutDelay() {
	m._CheckoutDelay = nil
	m.add_CheckoutDelay = nil
}

// SetATCDelay sets the "ATCDelay" field.
func (m *SettingsMutation) SetATCDelay(i int32) {
	m._ATCDelay = &i
	m.add_ATCDelay = nil
}

// ATCDelay returns the value of the "ATCDelay" field in the mutation.
func (m *SettingsMutation) ATCDelay() (r int32, exists bool) {
	v := m._ATCDelay
	if v == nil {
		return
	}
	return *v, true
}

// OldATCDelay returns the old "ATCDelay" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldATCDelay(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldATCDelay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldATCDelay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldATCDelay: %w", err)
	}
	return oldValue.ATCDelay, nil
}

// AddATCDelay adds i to the "ATCDelay" field.
func (m *SettingsMutation) AddATCDelay(i int32) {
	if m.add_ATCDelay != nil {
		*m.add_ATCDelay += i
	} else {
		m.add_ATCDelay = &i
	}
}

// AddedATCDelay returns the value that was added to the "ATCDelay" field in this mutation.
func (m *SettingsMutation) AddedATCDelay() (r int32, exists bool) {
	v := m.add_ATCDelay
	if v == nil {
		return
	}
	return *v, true
}

// ResetATCDelay resets all changes to the "ATCDelay" field.
func (m *SettingsMutation) ResetATCDelay() {
	m._ATCDelay = nil
	m.add_ATCDelay = nil
}

// SetAppID sets the "App" edge to the App entity by id.
func (m *SettingsMutation) SetAppID(id uuid.UUID) {
	m._App = &id
}

// ClearApp clears the "App" edge to the App entity.
func (m *SettingsMutation) ClearApp() {
	m.cleared_App = true
}

// AppCleared reports if the "App" edge to the App entity was cleared.
func (m *SettingsMutation) AppCleared() bool {
	return m.cleared_App
}

// AppID returns the "App" edge ID in the mutation.
func (m *SettingsMutation) AppID() (id uuid.UUID, exists bool) {
	if m._App != nil {
		return *m._App, true
	}
	return
}

// AppIDs returns the "App" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *SettingsMutation) AppIDs() (ids []uuid.UUID) {
	if id := m._App; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "App" edge.
func (m *SettingsMutation) ResetApp() {
	m._App = nil
	m.cleared_App = false
}

// Op returns the operation name.
func (m *SettingsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Settings).
func (m *SettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, settings.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, settings.FieldUpdatedAt)
	}
	if m._SuccessWebhook != nil {
		fields = append(fields, settings.FieldSuccessWebhook)
	}
	if m._DeclineWebhook != nil {
		fields = append(fields, settings.FieldDeclineWebhook)
	}
	if m._CheckoutDelay != nil {
		fields = append(fields, settings.FieldCheckoutDelay)
	}
	if m._ATCDelay != nil {
		fields = append(fields, settings.FieldATCDelay)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case settings.FieldCreatedAt:
		return m.CreatedAt()
	case settings.FieldUpdatedAt:
		return m.UpdatedAt()
	case settings.FieldSuccessWebhook:
		return m.SuccessWebhook()
	case settings.FieldDeclineWebhook:
		return m.DeclineWebhook()
	case settings.FieldCheckoutDelay:
		return m.CheckoutDelay()
	case settings.FieldATCDelay:
		return m.ATCDelay()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case settings.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case settings.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case settings.FieldSuccessWebhook:
		return m.OldSuccessWebhook(ctx)
	case settings.FieldDeclineWebhook:
		return m.OldDeclineWebhook(ctx)
	case settings.FieldCheckoutDelay:
		return m.OldCheckoutDelay(ctx)
	case settings.FieldATCDelay:
		return m.OldATCDelay(ctx)
	}
	return nil, fmt.Errorf("unknown Settings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case settings.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case settings.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case settings.FieldSuccessWebhook:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessWebhook(v)
		return nil
	case settings.FieldDeclineWebhook:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclineWebhook(v)
		return nil
	case settings.FieldCheckoutDelay:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckoutDelay(v)
		return nil
	case settings.FieldATCDelay:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetATCDelay(v)
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingsMutation) AddedFields() []string {
	var fields []string
	if m.add_CheckoutDelay != nil {
		fields = append(fields, settings.FieldCheckoutDelay)
	}
	if m.add_ATCDelay != nil {
		fields = append(fields, settings.FieldATCDelay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case settings.FieldCheckoutDelay:
		return m.AddedCheckoutDelay()
	case settings.FieldATCDelay:
		return m.AddedATCDelay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case settings.FieldCheckoutDelay:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCheckoutDelay(v)
		return nil
	case settings.FieldATCDelay:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddATCDelay(v)
		return nil
	}
	return fmt.Errorf("unknown Settings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Settings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingsMutation) ResetField(name string) error {
	switch name {
	case settings.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case settings.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case settings.FieldSuccessWebhook:
		m.ResetSuccessWebhook()
		return nil
	case settings.FieldDeclineWebhook:
		m.ResetDeclineWebhook()
		return nil
	case settings.FieldCheckoutDelay:
		m.ResetCheckoutDelay()
		return nil
	case settings.FieldATCDelay:
		m.ResetATCDelay()
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._App != nil {
		edges = append(edges, settings.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case settings.EdgeApp:
		if id := m._App; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_App {
		edges = append(edges, settings.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingsMutation) EdgeCleared(name string) bool {
	switch name {
	case settings.EdgeApp:
		return m.cleared_App
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingsMutation) ClearEdge(name string) error {
	switch name {
	case settings.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown Settings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingsMutation) ResetEdge(name string) error {
	switch name {
	case settings.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown Settings edge %s", name)
}

// ShippingMutation represents an operation that mutates the Shipping nodes in the graph.
type ShippingMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *time.Time
	updated_at              *time.Time
	_FirstName              *string
	_LastName               *string
	_PhoneNumber            *string
	_BillingIsShipping      *bool
	clearedFields           map[string]struct{}
	_Profile                *uuid.UUID
	cleared_Profile         bool
	_ShippingAddress        map[uuid.UUID]struct{}
	removed_ShippingAddress map[uuid.UUID]struct{}
	cleared_ShippingAddress bool
	_BillingAddress         map[uuid.UUID]struct{}
	removed_BillingAddress  map[uuid.UUID]struct{}
	cleared_BillingAddress  bool
	done                    bool
	oldValue                func(context.Context) (*Shipping, error)
	predicates              []predicate.Shipping
}

var _ ent.Mutation = (*ShippingMutation)(nil)

// shippingOption allows management of the mutation configuration using functional options.
type shippingOption func(*ShippingMutation)

// newShippingMutation creates new mutation for the Shipping entity.
func newShippingMutation(c config, op Op, opts ...shippingOption) *ShippingMutation {
	m := &ShippingMutation{
		config:        c,
		op:            op,
		typ:           TypeShipping,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShippingID sets the ID field of the mutation.
func withShippingID(id uuid.UUID) shippingOption {
	return func(m *ShippingMutation) {
		var (
			err   error
			once  sync.Once
			value *Shipping
		)
		m.oldValue = func(ctx context.Context) (*Shipping, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Shipping.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipping sets the old Shipping of the mutation.
func withShipping(node *Shipping) shippingOption {
	return func(m *ShippingMutation) {
		m.oldValue = func(context.Context) (*Shipping, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShippingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShippingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Shipping entities.
func (m *ShippingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ShippingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ShippingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShippingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Shipping entity.
// If the Shipping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShippingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShippingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShippingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShippingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Shipping entity.
// If the Shipping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShippingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShippingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFirstName sets the "FirstName" field.
func (m *ShippingMutation) SetFirstName(s string) {
	m._FirstName = &s
}

// FirstName returns the value of the "FirstName" field in the mutation.
func (m *ShippingMutation) FirstName() (r string, exists bool) {
	v := m._FirstName
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "FirstName" field's value of the Shipping entity.
// If the Shipping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShippingMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "FirstName" field.
func (m *ShippingMutation) ResetFirstName() {
	m._FirstName = nil
}

// SetLastName sets the "LastName" field.
func (m *ShippingMutation) SetLastName(s string) {
	m._LastName = &s
}

// LastName returns the value of the "LastName" field in the mutation.
func (m *ShippingMutation) LastName() (r string, exists bool) {
	v := m._LastName
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "LastName" field's value of the Shipping entity.
// If the Shipping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShippingMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "LastName" field.
func (m *ShippingMutation) ResetLastName() {
	m._LastName = nil
}

// SetPhoneNumber sets the "PhoneNumber" field.
func (m *ShippingMutation) SetPhoneNumber(s string) {
	m._PhoneNumber = &s
}

// PhoneNumber returns the value of the "PhoneNumber" field in the mutation.
func (m *ShippingMutation) PhoneNumber() (r string, exists bool) {
	v := m._PhoneNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "PhoneNumber" field's value of the Shipping entity.
// If the Shipping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShippingMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "PhoneNumber" field.
func (m *ShippingMutation) ResetPhoneNumber() {
	m._PhoneNumber = nil
}

// SetBillingIsShipping sets the "BillingIsShipping" field.
func (m *ShippingMutation) SetBillingIsShipping(b bool) {
	m._BillingIsShipping = &b
}

// BillingIsShipping returns the value of the "BillingIsShipping" field in the mutation.
func (m *ShippingMutation) BillingIsShipping() (r bool, exists bool) {
	v := m._BillingIsShipping
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingIsShipping returns the old "BillingIsShipping" field's value of the Shipping entity.
// If the Shipping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShippingMutation) OldBillingIsShipping(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBillingIsShipping is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBillingIsShipping requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingIsShipping: %w", err)
	}
	return oldValue.BillingIsShipping, nil
}

// ResetBillingIsShipping resets all changes to the "BillingIsShipping" field.
func (m *ShippingMutation) ResetBillingIsShipping() {
	m._BillingIsShipping = nil
}

// SetProfileID sets the "Profile" edge to the Profile entity by id.
func (m *ShippingMutation) SetProfileID(id uuid.UUID) {
	m._Profile = &id
}

// ClearProfile clears the "Profile" edge to the Profile entity.
func (m *ShippingMutation) ClearProfile() {
	m.cleared_Profile = true
}

// ProfileCleared reports if the "Profile" edge to the Profile entity was cleared.
func (m *ShippingMutation) ProfileCleared() bool {
	return m.cleared_Profile
}

// ProfileID returns the "Profile" edge ID in the mutation.
func (m *ShippingMutation) ProfileID() (id uuid.UUID, exists bool) {
	if m._Profile != nil {
		return *m._Profile, true
	}
	return
}

// ProfileIDs returns the "Profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *ShippingMutation) ProfileIDs() (ids []uuid.UUID) {
	if id := m._Profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "Profile" edge.
func (m *ShippingMutation) ResetProfile() {
	m._Profile = nil
	m.cleared_Profile = false
}

// AddShippingAddresIDs adds the "ShippingAddress" edge to the Address entity by ids.
func (m *ShippingMutation) AddShippingAddresIDs(ids ...uuid.UUID) {
	if m._ShippingAddress == nil {
		m._ShippingAddress = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ShippingAddress[ids[i]] = struct{}{}
	}
}

// ClearShippingAddress clears the "ShippingAddress" edge to the Address entity.
func (m *ShippingMutation) ClearShippingAddress() {
	m.cleared_ShippingAddress = true
}

// ShippingAddressCleared reports if the "ShippingAddress" edge to the Address entity was cleared.
func (m *ShippingMutation) ShippingAddressCleared() bool {
	return m.cleared_ShippingAddress
}

// RemoveShippingAddresIDs removes the "ShippingAddress" edge to the Address entity by IDs.
func (m *ShippingMutation) RemoveShippingAddresIDs(ids ...uuid.UUID) {
	if m.removed_ShippingAddress == nil {
		m.removed_ShippingAddress = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_ShippingAddress[ids[i]] = struct{}{}
	}
}

// RemovedShippingAddress returns the removed IDs of the "ShippingAddress" edge to the Address entity.
func (m *ShippingMutation) RemovedShippingAddressIDs() (ids []uuid.UUID) {
	for id := range m.removed_ShippingAddress {
		ids = append(ids, id)
	}
	return
}

// ShippingAddressIDs returns the "ShippingAddress" edge IDs in the mutation.
func (m *ShippingMutation) ShippingAddressIDs() (ids []uuid.UUID) {
	for id := range m._ShippingAddress {
		ids = append(ids, id)
	}
	return
}

// ResetShippingAddress resets all changes to the "ShippingAddress" edge.
func (m *ShippingMutation) ResetShippingAddress() {
	m._ShippingAddress = nil
	m.cleared_ShippingAddress = false
	m.removed_ShippingAddress = nil
}

// AddBillingAddresIDs adds the "BillingAddress" edge to the Address entity by ids.
func (m *ShippingMutation) AddBillingAddresIDs(ids ...uuid.UUID) {
	if m._BillingAddress == nil {
		m._BillingAddress = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._BillingAddress[ids[i]] = struct{}{}
	}
}

// ClearBillingAddress clears the "BillingAddress" edge to the Address entity.
func (m *ShippingMutation) ClearBillingAddress() {
	m.cleared_BillingAddress = true
}

// BillingAddressCleared reports if the "BillingAddress" edge to the Address entity was cleared.
func (m *ShippingMutation) BillingAddressCleared() bool {
	return m.cleared_BillingAddress
}

// RemoveBillingAddresIDs removes the "BillingAddress" edge to the Address entity by IDs.
func (m *ShippingMutation) RemoveBillingAddresIDs(ids ...uuid.UUID) {
	if m.removed_BillingAddress == nil {
		m.removed_BillingAddress = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_BillingAddress[ids[i]] = struct{}{}
	}
}

// RemovedBillingAddress returns the removed IDs of the "BillingAddress" edge to the Address entity.
func (m *ShippingMutation) RemovedBillingAddressIDs() (ids []uuid.UUID) {
	for id := range m.removed_BillingAddress {
		ids = append(ids, id)
	}
	return
}

// BillingAddressIDs returns the "BillingAddress" edge IDs in the mutation.
func (m *ShippingMutation) BillingAddressIDs() (ids []uuid.UUID) {
	for id := range m._BillingAddress {
		ids = append(ids, id)
	}
	return
}

// ResetBillingAddress resets all changes to the "BillingAddress" edge.
func (m *ShippingMutation) ResetBillingAddress() {
	m._BillingAddress = nil
	m.cleared_BillingAddress = false
	m.removed_BillingAddress = nil
}

// Op returns the operation name.
func (m *ShippingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Shipping).
func (m *ShippingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShippingMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, shipping.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shipping.FieldUpdatedAt)
	}
	if m._FirstName != nil {
		fields = append(fields, shipping.FieldFirstName)
	}
	if m._LastName != nil {
		fields = append(fields, shipping.FieldLastName)
	}
	if m._PhoneNumber != nil {
		fields = append(fields, shipping.FieldPhoneNumber)
	}
	if m._BillingIsShipping != nil {
		fields = append(fields, shipping.FieldBillingIsShipping)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShippingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipping.FieldCreatedAt:
		return m.CreatedAt()
	case shipping.FieldUpdatedAt:
		return m.UpdatedAt()
	case shipping.FieldFirstName:
		return m.FirstName()
	case shipping.FieldLastName:
		return m.LastName()
	case shipping.FieldPhoneNumber:
		return m.PhoneNumber()
	case shipping.FieldBillingIsShipping:
		return m.BillingIsShipping()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShippingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipping.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shipping.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shipping.FieldFirstName:
		return m.OldFirstName(ctx)
	case shipping.FieldLastName:
		return m.OldLastName(ctx)
	case shipping.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case shipping.FieldBillingIsShipping:
		return m.OldBillingIsShipping(ctx)
	}
	return nil, fmt.Errorf("unknown Shipping field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShippingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipping.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shipping.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shipping.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case shipping.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case shipping.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case shipping.FieldBillingIsShipping:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingIsShipping(v)
		return nil
	}
	return fmt.Errorf("unknown Shipping field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShippingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShippingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShippingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Shipping numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShippingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShippingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShippingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Shipping nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShippingMutation) ResetField(name string) error {
	switch name {
	case shipping.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shipping.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shipping.FieldFirstName:
		m.ResetFirstName()
		return nil
	case shipping.FieldLastName:
		m.ResetLastName()
		return nil
	case shipping.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case shipping.FieldBillingIsShipping:
		m.ResetBillingIsShipping()
		return nil
	}
	return fmt.Errorf("unknown Shipping field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShippingMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Profile != nil {
		edges = append(edges, shipping.EdgeProfile)
	}
	if m._ShippingAddress != nil {
		edges = append(edges, shipping.EdgeShippingAddress)
	}
	if m._BillingAddress != nil {
		edges = append(edges, shipping.EdgeBillingAddress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShippingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipping.EdgeProfile:
		if id := m._Profile; id != nil {
			return []ent.Value{*id}
		}
	case shipping.EdgeShippingAddress:
		ids := make([]ent.Value, 0, len(m._ShippingAddress))
		for id := range m._ShippingAddress {
			ids = append(ids, id)
		}
		return ids
	case shipping.EdgeBillingAddress:
		ids := make([]ent.Value, 0, len(m._BillingAddress))
		for id := range m._BillingAddress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShippingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_ShippingAddress != nil {
		edges = append(edges, shipping.EdgeShippingAddress)
	}
	if m.removed_BillingAddress != nil {
		edges = append(edges, shipping.EdgeBillingAddress)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShippingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case shipping.EdgeShippingAddress:
		ids := make([]ent.Value, 0, len(m.removed_ShippingAddress))
		for id := range m.removed_ShippingAddress {
			ids = append(ids, id)
		}
		return ids
	case shipping.EdgeBillingAddress:
		ids := make([]ent.Value, 0, len(m.removed_BillingAddress))
		for id := range m.removed_BillingAddress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShippingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Profile {
		edges = append(edges, shipping.EdgeProfile)
	}
	if m.cleared_ShippingAddress {
		edges = append(edges, shipping.EdgeShippingAddress)
	}
	if m.cleared_BillingAddress {
		edges = append(edges, shipping.EdgeBillingAddress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShippingMutation) EdgeCleared(name string) bool {
	switch name {
	case shipping.EdgeProfile:
		return m.cleared_Profile
	case shipping.EdgeShippingAddress:
		return m.cleared_ShippingAddress
	case shipping.EdgeBillingAddress:
		return m.cleared_BillingAddress
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShippingMutation) ClearEdge(name string) error {
	switch name {
	case shipping.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown Shipping unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShippingMutation) ResetEdge(name string) error {
	switch name {
	case shipping.EdgeProfile:
		m.ResetProfile()
		return nil
	case shipping.EdgeShippingAddress:
		m.ResetShippingAddress()
		return nil
	case shipping.EdgeBillingAddress:
		m.ResetBillingAddress()
		return nil
	}
	return fmt.Errorf("unknown Shipping edge %s", name)
}

// StatisticMutation represents an operation that mutates the Statistic nodes in the graph.
type StatisticMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	_Type           *statistic.Type
	clearedFields   map[string]struct{}
	_User           map[uuid.UUID]struct{}
	removed_User    map[uuid.UUID]struct{}
	cleared_User    bool
	_Product        map[uuid.UUID]struct{}
	removed_Product map[uuid.UUID]struct{}
	cleared_Product bool
	done            bool
	oldValue        func(context.Context) (*Statistic, error)
	predicates      []predicate.Statistic
}

var _ ent.Mutation = (*StatisticMutation)(nil)

// statisticOption allows management of the mutation configuration using functional options.
type statisticOption func(*StatisticMutation)

// newStatisticMutation creates new mutation for the Statistic entity.
func newStatisticMutation(c config, op Op, opts ...statisticOption) *StatisticMutation {
	m := &StatisticMutation{
		config:        c,
		op:            op,
		typ:           TypeStatistic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatisticID sets the ID field of the mutation.
func withStatisticID(id uuid.UUID) statisticOption {
	return func(m *StatisticMutation) {
		var (
			err   error
			once  sync.Once
			value *Statistic
		)
		m.oldValue = func(ctx context.Context) (*Statistic, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Statistic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatistic sets the old Statistic of the mutation.
func withStatistic(node *Statistic) statisticOption {
	return func(m *StatisticMutation) {
		m.oldValue = func(context.Context) (*Statistic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatisticMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatisticMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Statistic entities.
func (m *StatisticMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *StatisticMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *StatisticMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StatisticMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StatisticMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StatisticMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StatisticMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StatisticMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "Type" field.
func (m *StatisticMutation) SetType(s statistic.Type) {
	m._Type = &s
}

// GetType returns the value of the "Type" field in the mutation.
func (m *StatisticMutation) GetType() (r statistic.Type, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldType(ctx context.Context) (v statistic.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "Type" field.
func (m *StatisticMutation) ResetType() {
	m._Type = nil
}

// AddUserIDs adds the "User" edge to the User entity by ids.
func (m *StatisticMutation) AddUserIDs(ids ...uuid.UUID) {
	if m._User == nil {
		m._User = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._User[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "User" edge to the User entity.
func (m *StatisticMutation) ClearUser() {
	m.cleared_User = true
}

// UserCleared reports if the "User" edge to the User entity was cleared.
func (m *StatisticMutation) UserCleared() bool {
	return m.cleared_User
}

// RemoveUserIDs removes the "User" edge to the User entity by IDs.
func (m *StatisticMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removed_User == nil {
		m.removed_User = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_User[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "User" edge to the User entity.
func (m *StatisticMutation) RemovedUserIDs() (ids []uuid.UUID) {
	for id := range m.removed_User {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "User" edge IDs in the mutation.
func (m *StatisticMutation) UserIDs() (ids []uuid.UUID) {
	for id := range m._User {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "User" edge.
func (m *StatisticMutation) ResetUser() {
	m._User = nil
	m.cleared_User = false
	m.removed_User = nil
}

// AddProductIDs adds the "Product" edge to the Product entity by ids.
func (m *StatisticMutation) AddProductIDs(ids ...uuid.UUID) {
	if m._Product == nil {
		m._Product = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Product[ids[i]] = struct{}{}
	}
}

// ClearProduct clears the "Product" edge to the Product entity.
func (m *StatisticMutation) ClearProduct() {
	m.cleared_Product = true
}

// ProductCleared reports if the "Product" edge to the Product entity was cleared.
func (m *StatisticMutation) ProductCleared() bool {
	return m.cleared_Product
}

// RemoveProductIDs removes the "Product" edge to the Product entity by IDs.
func (m *StatisticMutation) RemoveProductIDs(ids ...uuid.UUID) {
	if m.removed_Product == nil {
		m.removed_Product = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_Product[ids[i]] = struct{}{}
	}
}

// RemovedProduct returns the removed IDs of the "Product" edge to the Product entity.
func (m *StatisticMutation) RemovedProductIDs() (ids []uuid.UUID) {
	for id := range m.removed_Product {
		ids = append(ids, id)
	}
	return
}

// ProductIDs returns the "Product" edge IDs in the mutation.
func (m *StatisticMutation) ProductIDs() (ids []uuid.UUID) {
	for id := range m._Product {
		ids = append(ids, id)
	}
	return
}

// ResetProduct resets all changes to the "Product" edge.
func (m *StatisticMutation) ResetProduct() {
	m._Product = nil
	m.cleared_Product = false
	m.removed_Product = nil
}

// Op returns the operation name.
func (m *StatisticMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Statistic).
func (m *StatisticMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatisticMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, statistic.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, statistic.FieldUpdatedAt)
	}
	if m._Type != nil {
		fields = append(fields, statistic.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatisticMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statistic.FieldCreatedAt:
		return m.CreatedAt()
	case statistic.FieldUpdatedAt:
		return m.UpdatedAt()
	case statistic.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatisticMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statistic.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case statistic.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case statistic.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Statistic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatisticMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statistic.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case statistic.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case statistic.FieldType:
		v, ok := value.(statistic.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Statistic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatisticMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatisticMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatisticMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Statistic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatisticMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatisticMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatisticMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Statistic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatisticMutation) ResetField(name string) error {
	switch name {
	case statistic.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case statistic.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case statistic.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Statistic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatisticMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._User != nil {
		edges = append(edges, statistic.EdgeUser)
	}
	if m._Product != nil {
		edges = append(edges, statistic.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatisticMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statistic.EdgeUser:
		ids := make([]ent.Value, 0, len(m._User))
		for id := range m._User {
			ids = append(ids, id)
		}
		return ids
	case statistic.EdgeProduct:
		ids := make([]ent.Value, 0, len(m._Product))
		for id := range m._Product {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatisticMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_User != nil {
		edges = append(edges, statistic.EdgeUser)
	}
	if m.removed_Product != nil {
		edges = append(edges, statistic.EdgeProduct)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatisticMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case statistic.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removed_User))
		for id := range m.removed_User {
			ids = append(ids, id)
		}
		return ids
	case statistic.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.removed_Product))
		for id := range m.removed_Product {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatisticMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_User {
		edges = append(edges, statistic.EdgeUser)
	}
	if m.cleared_Product {
		edges = append(edges, statistic.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatisticMutation) EdgeCleared(name string) bool {
	switch name {
	case statistic.EdgeUser:
		return m.cleared_User
	case statistic.EdgeProduct:
		return m.cleared_Product
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatisticMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Statistic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatisticMutation) ResetEdge(name string) error {
	switch name {
	case statistic.EdgeUser:
		m.ResetUser()
		return nil
	case statistic.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown Statistic edge %s", name)
}

// StripeMutation represents an operation that mutates the Stripe nodes in the graph.
type StripeMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	_CustomerID     *string
	_SubscriptionID *string
	_RenewalDate    *time.Time
	clearedFields   map[string]struct{}
	_License        *uuid.UUID
	cleared_License bool
	done            bool
	oldValue        func(context.Context) (*Stripe, error)
	predicates      []predicate.Stripe
}

var _ ent.Mutation = (*StripeMutation)(nil)

// stripeOption allows management of the mutation configuration using functional options.
type stripeOption func(*StripeMutation)

// newStripeMutation creates new mutation for the Stripe entity.
func newStripeMutation(c config, op Op, opts ...stripeOption) *StripeMutation {
	m := &StripeMutation{
		config:        c,
		op:            op,
		typ:           TypeStripe,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStripeID sets the ID field of the mutation.
func withStripeID(id uuid.UUID) stripeOption {
	return func(m *StripeMutation) {
		var (
			err   error
			once  sync.Once
			value *Stripe
		)
		m.oldValue = func(ctx context.Context) (*Stripe, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stripe.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStripe sets the old Stripe of the mutation.
func withStripe(node *Stripe) stripeOption {
	return func(m *StripeMutation) {
		m.oldValue = func(context.Context) (*Stripe, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StripeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StripeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Stripe entities.
func (m *StripeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *StripeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *StripeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StripeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Stripe entity.
// If the Stripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StripeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StripeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StripeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StripeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Stripe entity.
// If the Stripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StripeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StripeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCustomerID sets the "CustomerID" field.
func (m *StripeMutation) SetCustomerID(s string) {
	m._CustomerID = &s
}

// CustomerID returns the value of the "CustomerID" field in the mutation.
func (m *StripeMutation) CustomerID() (r string, exists bool) {
	v := m._CustomerID
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "CustomerID" field's value of the Stripe entity.
// If the Stripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StripeMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "CustomerID" field.
func (m *StripeMutation) ResetCustomerID() {
	m._CustomerID = nil
}

// SetSubscriptionID sets the "SubscriptionID" field.
func (m *StripeMutation) SetSubscriptionID(s string) {
	m._SubscriptionID = &s
}

// SubscriptionID returns the value of the "SubscriptionID" field in the mutation.
func (m *StripeMutation) SubscriptionID() (r string, exists bool) {
	v := m._SubscriptionID
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionID returns the old "SubscriptionID" field's value of the Stripe entity.
// If the Stripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StripeMutation) OldSubscriptionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionID: %w", err)
	}
	return oldValue.SubscriptionID, nil
}

// ClearSubscriptionID clears the value of the "SubscriptionID" field.
func (m *StripeMutation) ClearSubscriptionID() {
	m._SubscriptionID = nil
	m.clearedFields[stripe.FieldSubscriptionID] = struct{}{}
}

// SubscriptionIDCleared returns if the "SubscriptionID" field was cleared in this mutation.
func (m *StripeMutation) SubscriptionIDCleared() bool {
	_, ok := m.clearedFields[stripe.FieldSubscriptionID]
	return ok
}

// ResetSubscriptionID resets all changes to the "SubscriptionID" field.
func (m *StripeMutation) ResetSubscriptionID() {
	m._SubscriptionID = nil
	delete(m.clearedFields, stripe.FieldSubscriptionID)
}

// SetRenewalDate sets the "RenewalDate" field.
func (m *StripeMutation) SetRenewalDate(t time.Time) {
	m._RenewalDate = &t
}

// RenewalDate returns the value of the "RenewalDate" field in the mutation.
func (m *StripeMutation) RenewalDate() (r time.Time, exists bool) {
	v := m._RenewalDate
	if v == nil {
		return
	}
	return *v, true
}

// OldRenewalDate returns the old "RenewalDate" field's value of the Stripe entity.
// If the Stripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StripeMutation) OldRenewalDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRenewalDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRenewalDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenewalDate: %w", err)
	}
	return oldValue.RenewalDate, nil
}

// ClearRenewalDate clears the value of the "RenewalDate" field.
func (m *StripeMutation) ClearRenewalDate() {
	m._RenewalDate = nil
	m.clearedFields[stripe.FieldRenewalDate] = struct{}{}
}

// RenewalDateCleared returns if the "RenewalDate" field was cleared in this mutation.
func (m *StripeMutation) RenewalDateCleared() bool {
	_, ok := m.clearedFields[stripe.FieldRenewalDate]
	return ok
}

// ResetRenewalDate resets all changes to the "RenewalDate" field.
func (m *StripeMutation) ResetRenewalDate() {
	m._RenewalDate = nil
	delete(m.clearedFields, stripe.FieldRenewalDate)
}

// SetLicenseID sets the "License" edge to the License entity by id.
func (m *StripeMutation) SetLicenseID(id uuid.UUID) {
	m._License = &id
}

// ClearLicense clears the "License" edge to the License entity.
func (m *StripeMutation) ClearLicense() {
	m.cleared_License = true
}

// LicenseCleared reports if the "License" edge to the License entity was cleared.
func (m *StripeMutation) LicenseCleared() bool {
	return m.cleared_License
}

// LicenseID returns the "License" edge ID in the mutation.
func (m *StripeMutation) LicenseID() (id uuid.UUID, exists bool) {
	if m._License != nil {
		return *m._License, true
	}
	return
}

// LicenseIDs returns the "License" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LicenseID instead. It exists only for internal usage by the builders.
func (m *StripeMutation) LicenseIDs() (ids []uuid.UUID) {
	if id := m._License; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLicense resets all changes to the "License" edge.
func (m *StripeMutation) ResetLicense() {
	m._License = nil
	m.cleared_License = false
}

// Op returns the operation name.
func (m *StripeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Stripe).
func (m *StripeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StripeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, stripe.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, stripe.FieldUpdatedAt)
	}
	if m._CustomerID != nil {
		fields = append(fields, stripe.FieldCustomerID)
	}
	if m._SubscriptionID != nil {
		fields = append(fields, stripe.FieldSubscriptionID)
	}
	if m._RenewalDate != nil {
		fields = append(fields, stripe.FieldRenewalDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StripeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stripe.FieldCreatedAt:
		return m.CreatedAt()
	case stripe.FieldUpdatedAt:
		return m.UpdatedAt()
	case stripe.FieldCustomerID:
		return m.CustomerID()
	case stripe.FieldSubscriptionID:
		return m.SubscriptionID()
	case stripe.FieldRenewalDate:
		return m.RenewalDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StripeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stripe.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case stripe.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case stripe.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case stripe.FieldSubscriptionID:
		return m.OldSubscriptionID(ctx)
	case stripe.FieldRenewalDate:
		return m.OldRenewalDate(ctx)
	}
	return nil, fmt.Errorf("unknown Stripe field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StripeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stripe.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case stripe.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case stripe.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case stripe.FieldSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionID(v)
		return nil
	case stripe.FieldRenewalDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenewalDate(v)
		return nil
	}
	return fmt.Errorf("unknown Stripe field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StripeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StripeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StripeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Stripe numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StripeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stripe.FieldSubscriptionID) {
		fields = append(fields, stripe.FieldSubscriptionID)
	}
	if m.FieldCleared(stripe.FieldRenewalDate) {
		fields = append(fields, stripe.FieldRenewalDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StripeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StripeMutation) ClearField(name string) error {
	switch name {
	case stripe.FieldSubscriptionID:
		m.ClearSubscriptionID()
		return nil
	case stripe.FieldRenewalDate:
		m.ClearRenewalDate()
		return nil
	}
	return fmt.Errorf("unknown Stripe nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StripeMutation) ResetField(name string) error {
	switch name {
	case stripe.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case stripe.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case stripe.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case stripe.FieldSubscriptionID:
		m.ResetSubscriptionID()
		return nil
	case stripe.FieldRenewalDate:
		m.ResetRenewalDate()
		return nil
	}
	return fmt.Errorf("unknown Stripe field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StripeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._License != nil {
		edges = append(edges, stripe.EdgeLicense)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StripeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stripe.EdgeLicense:
		if id := m._License; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StripeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StripeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StripeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_License {
		edges = append(edges, stripe.EdgeLicense)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StripeMutation) EdgeCleared(name string) bool {
	switch name {
	case stripe.EdgeLicense:
		return m.cleared_License
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StripeMutation) ClearEdge(name string) error {
	switch name {
	case stripe.EdgeLicense:
		m.ClearLicense()
		return nil
	}
	return fmt.Errorf("unknown Stripe unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StripeMutation) ResetEdge(name string) error {
	switch name {
	case stripe.EdgeLicense:
		m.ResetLicense()
		return nil
	}
	return fmt.Errorf("unknown Stripe edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	_StartTime           *time.Time
	clearedFields        map[string]struct{}
	_Product             map[uuid.UUID]struct{}
	removed_Product      map[uuid.UUID]struct{}
	cleared_Product      bool
	_ProxyList           map[uuid.UUID]struct{}
	removed_ProxyList    map[uuid.UUID]struct{}
	cleared_ProxyList    bool
	_ProfileGroup        map[uuid.UUID]struct{}
	removed_ProfileGroup map[uuid.UUID]struct{}
	cleared_ProfileGroup bool
	_TaskGroup           map[uuid.UUID]struct{}
	removed_TaskGroup    map[uuid.UUID]struct{}
	cleared_TaskGroup    bool
	done                 bool
	oldValue             func(context.Context) (*Task, error)
	predicates           []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id uuid.UUID) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStartTime sets the "StartTime" field.
func (m *TaskMutation) SetStartTime(t time.Time) {
	m._StartTime = &t
}

// StartTime returns the value of the "StartTime" field in the mutation.
func (m *TaskMutation) StartTime() (r time.Time, exists bool) {
	v := m._StartTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "StartTime" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "StartTime" field.
func (m *TaskMutation) ClearStartTime() {
	m._StartTime = nil
	m.clearedFields[task.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "StartTime" field was cleared in this mutation.
func (m *TaskMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[task.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "StartTime" field.
func (m *TaskMutation) ResetStartTime() {
	m._StartTime = nil
	delete(m.clearedFields, task.FieldStartTime)
}

// AddProductIDs adds the "Product" edge to the Product entity by ids.
func (m *TaskMutation) AddProductIDs(ids ...uuid.UUID) {
	if m._Product == nil {
		m._Product = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Product[ids[i]] = struct{}{}
	}
}

// ClearProduct clears the "Product" edge to the Product entity.
func (m *TaskMutation) ClearProduct() {
	m.cleared_Product = true
}

// ProductCleared reports if the "Product" edge to the Product entity was cleared.
func (m *TaskMutation) ProductCleared() bool {
	return m.cleared_Product
}

// RemoveProductIDs removes the "Product" edge to the Product entity by IDs.
func (m *TaskMutation) RemoveProductIDs(ids ...uuid.UUID) {
	if m.removed_Product == nil {
		m.removed_Product = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_Product[ids[i]] = struct{}{}
	}
}

// RemovedProduct returns the removed IDs of the "Product" edge to the Product entity.
func (m *TaskMutation) RemovedProductIDs() (ids []uuid.UUID) {
	for id := range m.removed_Product {
		ids = append(ids, id)
	}
	return
}

// ProductIDs returns the "Product" edge IDs in the mutation.
func (m *TaskMutation) ProductIDs() (ids []uuid.UUID) {
	for id := range m._Product {
		ids = append(ids, id)
	}
	return
}

// ResetProduct resets all changes to the "Product" edge.
func (m *TaskMutation) ResetProduct() {
	m._Product = nil
	m.cleared_Product = false
	m.removed_Product = nil
}

// AddProxyListIDs adds the "ProxyList" edge to the ProxyList entity by ids.
func (m *TaskMutation) AddProxyListIDs(ids ...uuid.UUID) {
	if m._ProxyList == nil {
		m._ProxyList = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ProxyList[ids[i]] = struct{}{}
	}
}

// ClearProxyList clears the "ProxyList" edge to the ProxyList entity.
func (m *TaskMutation) ClearProxyList() {
	m.cleared_ProxyList = true
}

// ProxyListCleared reports if the "ProxyList" edge to the ProxyList entity was cleared.
func (m *TaskMutation) ProxyListCleared() bool {
	return m.cleared_ProxyList
}

// RemoveProxyListIDs removes the "ProxyList" edge to the ProxyList entity by IDs.
func (m *TaskMutation) RemoveProxyListIDs(ids ...uuid.UUID) {
	if m.removed_ProxyList == nil {
		m.removed_ProxyList = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_ProxyList[ids[i]] = struct{}{}
	}
}

// RemovedProxyList returns the removed IDs of the "ProxyList" edge to the ProxyList entity.
func (m *TaskMutation) RemovedProxyListIDs() (ids []uuid.UUID) {
	for id := range m.removed_ProxyList {
		ids = append(ids, id)
	}
	return
}

// ProxyListIDs returns the "ProxyList" edge IDs in the mutation.
func (m *TaskMutation) ProxyListIDs() (ids []uuid.UUID) {
	for id := range m._ProxyList {
		ids = append(ids, id)
	}
	return
}

// ResetProxyList resets all changes to the "ProxyList" edge.
func (m *TaskMutation) ResetProxyList() {
	m._ProxyList = nil
	m.cleared_ProxyList = false
	m.removed_ProxyList = nil
}

// AddProfileGroupIDs adds the "ProfileGroup" edge to the ProfileGroup entity by ids.
func (m *TaskMutation) AddProfileGroupIDs(ids ...uuid.UUID) {
	if m._ProfileGroup == nil {
		m._ProfileGroup = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ProfileGroup[ids[i]] = struct{}{}
	}
}

// ClearProfileGroup clears the "ProfileGroup" edge to the ProfileGroup entity.
func (m *TaskMutation) ClearProfileGroup() {
	m.cleared_ProfileGroup = true
}

// ProfileGroupCleared reports if the "ProfileGroup" edge to the ProfileGroup entity was cleared.
func (m *TaskMutation) ProfileGroupCleared() bool {
	return m.cleared_ProfileGroup
}

// RemoveProfileGroupIDs removes the "ProfileGroup" edge to the ProfileGroup entity by IDs.
func (m *TaskMutation) RemoveProfileGroupIDs(ids ...uuid.UUID) {
	if m.removed_ProfileGroup == nil {
		m.removed_ProfileGroup = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_ProfileGroup[ids[i]] = struct{}{}
	}
}

// RemovedProfileGroup returns the removed IDs of the "ProfileGroup" edge to the ProfileGroup entity.
func (m *TaskMutation) RemovedProfileGroupIDs() (ids []uuid.UUID) {
	for id := range m.removed_ProfileGroup {
		ids = append(ids, id)
	}
	return
}

// ProfileGroupIDs returns the "ProfileGroup" edge IDs in the mutation.
func (m *TaskMutation) ProfileGroupIDs() (ids []uuid.UUID) {
	for id := range m._ProfileGroup {
		ids = append(ids, id)
	}
	return
}

// ResetProfileGroup resets all changes to the "ProfileGroup" edge.
func (m *TaskMutation) ResetProfileGroup() {
	m._ProfileGroup = nil
	m.cleared_ProfileGroup = false
	m.removed_ProfileGroup = nil
}

// AddTaskGroupIDs adds the "TaskGroup" edge to the TaskGroup entity by ids.
func (m *TaskMutation) AddTaskGroupIDs(ids ...uuid.UUID) {
	if m._TaskGroup == nil {
		m._TaskGroup = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._TaskGroup[ids[i]] = struct{}{}
	}
}

// ClearTaskGroup clears the "TaskGroup" edge to the TaskGroup entity.
func (m *TaskMutation) ClearTaskGroup() {
	m.cleared_TaskGroup = true
}

// TaskGroupCleared reports if the "TaskGroup" edge to the TaskGroup entity was cleared.
func (m *TaskMutation) TaskGroupCleared() bool {
	return m.cleared_TaskGroup
}

// RemoveTaskGroupIDs removes the "TaskGroup" edge to the TaskGroup entity by IDs.
func (m *TaskMutation) RemoveTaskGroupIDs(ids ...uuid.UUID) {
	if m.removed_TaskGroup == nil {
		m.removed_TaskGroup = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_TaskGroup[ids[i]] = struct{}{}
	}
}

// RemovedTaskGroup returns the removed IDs of the "TaskGroup" edge to the TaskGroup entity.
func (m *TaskMutation) RemovedTaskGroupIDs() (ids []uuid.UUID) {
	for id := range m.removed_TaskGroup {
		ids = append(ids, id)
	}
	return
}

// TaskGroupIDs returns the "TaskGroup" edge IDs in the mutation.
func (m *TaskMutation) TaskGroupIDs() (ids []uuid.UUID) {
	for id := range m._TaskGroup {
		ids = append(ids, id)
	}
	return
}

// ResetTaskGroup resets all changes to the "TaskGroup" edge.
func (m *TaskMutation) ResetTaskGroup() {
	m._TaskGroup = nil
	m.cleared_TaskGroup = false
	m.removed_TaskGroup = nil
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m._StartTime != nil {
		fields = append(fields, task.FieldStartTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldUpdatedAt:
		return m.UpdatedAt()
	case task.FieldStartTime:
		return m.StartTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case task.FieldStartTime:
		return m.OldStartTime(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case task.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldStartTime) {
		fields = append(fields, task.FieldStartTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldStartTime:
		m.ClearStartTime()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case task.FieldStartTime:
		m.ResetStartTime()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._Product != nil {
		edges = append(edges, task.EdgeProduct)
	}
	if m._ProxyList != nil {
		edges = append(edges, task.EdgeProxyList)
	}
	if m._ProfileGroup != nil {
		edges = append(edges, task.EdgeProfileGroup)
	}
	if m._TaskGroup != nil {
		edges = append(edges, task.EdgeTaskGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeProduct:
		ids := make([]ent.Value, 0, len(m._Product))
		for id := range m._Product {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeProxyList:
		ids := make([]ent.Value, 0, len(m._ProxyList))
		for id := range m._ProxyList {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeProfileGroup:
		ids := make([]ent.Value, 0, len(m._ProfileGroup))
		for id := range m._ProfileGroup {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskGroup:
		ids := make([]ent.Value, 0, len(m._TaskGroup))
		for id := range m._TaskGroup {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_Product != nil {
		edges = append(edges, task.EdgeProduct)
	}
	if m.removed_ProxyList != nil {
		edges = append(edges, task.EdgeProxyList)
	}
	if m.removed_ProfileGroup != nil {
		edges = append(edges, task.EdgeProfileGroup)
	}
	if m.removed_TaskGroup != nil {
		edges = append(edges, task.EdgeTaskGroup)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.removed_Product))
		for id := range m.removed_Product {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeProxyList:
		ids := make([]ent.Value, 0, len(m.removed_ProxyList))
		for id := range m.removed_ProxyList {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeProfileGroup:
		ids := make([]ent.Value, 0, len(m.removed_ProfileGroup))
		for id := range m.removed_ProfileGroup {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskGroup:
		ids := make([]ent.Value, 0, len(m.removed_TaskGroup))
		for id := range m.removed_TaskGroup {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_Product {
		edges = append(edges, task.EdgeProduct)
	}
	if m.cleared_ProxyList {
		edges = append(edges, task.EdgeProxyList)
	}
	if m.cleared_ProfileGroup {
		edges = append(edges, task.EdgeProfileGroup)
	}
	if m.cleared_TaskGroup {
		edges = append(edges, task.EdgeTaskGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeProduct:
		return m.cleared_Product
	case task.EdgeProxyList:
		return m.cleared_ProxyList
	case task.EdgeProfileGroup:
		return m.cleared_ProfileGroup
	case task.EdgeTaskGroup:
		return m.cleared_TaskGroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeProduct:
		m.ResetProduct()
		return nil
	case task.EdgeProxyList:
		m.ResetProxyList()
		return nil
	case task.EdgeProfileGroup:
		m.ResetProfileGroup()
		return nil
	case task.EdgeTaskGroup:
		m.ResetTaskGroup()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}

// TaskGroupMutation represents an operation that mutates the TaskGroup nodes in the graph.
type TaskGroupMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	_Name         *string
	clearedFields map[string]struct{}
	_App          map[uuid.UUID]struct{}
	removed_App   map[uuid.UUID]struct{}
	cleared_App   bool
	_Tasks        map[uuid.UUID]struct{}
	removed_Tasks map[uuid.UUID]struct{}
	cleared_Tasks bool
	done          bool
	oldValue      func(context.Context) (*TaskGroup, error)
	predicates    []predicate.TaskGroup
}

var _ ent.Mutation = (*TaskGroupMutation)(nil)

// taskgroupOption allows management of the mutation configuration using functional options.
type taskgroupOption func(*TaskGroupMutation)

// newTaskGroupMutation creates new mutation for the TaskGroup entity.
func newTaskGroupMutation(c config, op Op, opts ...taskgroupOption) *TaskGroupMutation {
	m := &TaskGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskGroupID sets the ID field of the mutation.
func withTaskGroupID(id uuid.UUID) taskgroupOption {
	return func(m *TaskGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskGroup
		)
		m.oldValue = func(ctx context.Context) (*TaskGroup, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskGroup sets the old TaskGroup of the mutation.
func withTaskGroup(node *TaskGroup) taskgroupOption {
	return func(m *TaskGroupMutation) {
		m.oldValue = func(context.Context) (*TaskGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskGroup entities.
func (m *TaskGroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TaskGroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskGroup entity.
// If the TaskGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskGroup entity.
// If the TaskGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "Name" field.
func (m *TaskGroupMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *TaskGroupMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the TaskGroup entity.
// If the TaskGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *TaskGroupMutation) ResetName() {
	m._Name = nil
}

// AddAppIDs adds the "App" edge to the App entity by ids.
func (m *TaskGroupMutation) AddAppIDs(ids ...uuid.UUID) {
	if m._App == nil {
		m._App = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._App[ids[i]] = struct{}{}
	}
}

// ClearApp clears the "App" edge to the App entity.
func (m *TaskGroupMutation) ClearApp() {
	m.cleared_App = true
}

// AppCleared reports if the "App" edge to the App entity was cleared.
func (m *TaskGroupMutation) AppCleared() bool {
	return m.cleared_App
}

// RemoveAppIDs removes the "App" edge to the App entity by IDs.
func (m *TaskGroupMutation) RemoveAppIDs(ids ...uuid.UUID) {
	if m.removed_App == nil {
		m.removed_App = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_App[ids[i]] = struct{}{}
	}
}

// RemovedApp returns the removed IDs of the "App" edge to the App entity.
func (m *TaskGroupMutation) RemovedAppIDs() (ids []uuid.UUID) {
	for id := range m.removed_App {
		ids = append(ids, id)
	}
	return
}

// AppIDs returns the "App" edge IDs in the mutation.
func (m *TaskGroupMutation) AppIDs() (ids []uuid.UUID) {
	for id := range m._App {
		ids = append(ids, id)
	}
	return
}

// ResetApp resets all changes to the "App" edge.
func (m *TaskGroupMutation) ResetApp() {
	m._App = nil
	m.cleared_App = false
	m.removed_App = nil
}

// AddTaskIDs adds the "Tasks" edge to the Task entity by ids.
func (m *TaskGroupMutation) AddTaskIDs(ids ...uuid.UUID) {
	if m._Tasks == nil {
		m._Tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "Tasks" edge to the Task entity.
func (m *TaskGroupMutation) ClearTasks() {
	m.cleared_Tasks = true
}

// TasksCleared reports if the "Tasks" edge to the Task entity was cleared.
func (m *TaskGroupMutation) TasksCleared() bool {
	return m.cleared_Tasks
}

// RemoveTaskIDs removes the "Tasks" edge to the Task entity by IDs.
func (m *TaskGroupMutation) RemoveTaskIDs(ids ...uuid.UUID) {
	if m.removed_Tasks == nil {
		m.removed_Tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_Tasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "Tasks" edge to the Task entity.
func (m *TaskGroupMutation) RemovedTasksIDs() (ids []uuid.UUID) {
	for id := range m.removed_Tasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "Tasks" edge IDs in the mutation.
func (m *TaskGroupMutation) TasksIDs() (ids []uuid.UUID) {
	for id := range m._Tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "Tasks" edge.
func (m *TaskGroupMutation) ResetTasks() {
	m._Tasks = nil
	m.cleared_Tasks = false
	m.removed_Tasks = nil
}

// Op returns the operation name.
func (m *TaskGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TaskGroup).
func (m *TaskGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, taskgroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskgroup.FieldUpdatedAt)
	}
	if m._Name != nil {
		fields = append(fields, taskgroup.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskgroup.FieldCreatedAt:
		return m.CreatedAt()
	case taskgroup.FieldUpdatedAt:
		return m.UpdatedAt()
	case taskgroup.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskgroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskgroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case taskgroup.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown TaskGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskgroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case taskgroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown TaskGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskGroupMutation) ResetField(name string) error {
	switch name {
	case taskgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskgroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case taskgroup.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown TaskGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._App != nil {
		edges = append(edges, taskgroup.EdgeApp)
	}
	if m._Tasks != nil {
		edges = append(edges, taskgroup.EdgeTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case taskgroup.EdgeApp:
		ids := make([]ent.Value, 0, len(m._App))
		for id := range m._App {
			ids = append(ids, id)
		}
		return ids
	case taskgroup.EdgeTasks:
		ids := make([]ent.Value, 0, len(m._Tasks))
		for id := range m._Tasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_App != nil {
		edges = append(edges, taskgroup.EdgeApp)
	}
	if m.removed_Tasks != nil {
		edges = append(edges, taskgroup.EdgeTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case taskgroup.EdgeApp:
		ids := make([]ent.Value, 0, len(m.removed_App))
		for id := range m.removed_App {
			ids = append(ids, id)
		}
		return ids
	case taskgroup.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removed_Tasks))
		for id := range m.removed_Tasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_App {
		edges = append(edges, taskgroup.EdgeApp)
	}
	if m.cleared_Tasks {
		edges = append(edges, taskgroup.EdgeTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case taskgroup.EdgeApp:
		return m.cleared_App
	case taskgroup.EdgeTasks:
		return m.cleared_Tasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskGroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskGroupMutation) ResetEdge(name string) error {
	switch name {
	case taskgroup.EdgeApp:
		m.ResetApp()
		return nil
	case taskgroup.EdgeTasks:
		m.ResetTasks()
		return nil
	}
	return fmt.Errorf("unknown TaskGroup edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	_Disabled          *bool
	clearedFields      map[string]struct{}
	_License           *uuid.UUID
	cleared_License    bool
	_Statistics        map[uuid.UUID]struct{}
	removed_Statistics map[uuid.UUID]struct{}
	cleared_Statistics bool
	_App               *uuid.UUID
	cleared_App        bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDisabled sets the "Disabled" field.
func (m *UserMutation) SetDisabled(b bool) {
	m._Disabled = &b
}

// Disabled returns the value of the "Disabled" field in the mutation.
func (m *UserMutation) Disabled() (r bool, exists bool) {
	v := m._Disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "Disabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "Disabled" field.
func (m *UserMutation) ResetDisabled() {
	m._Disabled = nil
}

// SetLicenseID sets the "License" edge to the License entity by id.
func (m *UserMutation) SetLicenseID(id uuid.UUID) {
	m._License = &id
}

// ClearLicense clears the "License" edge to the License entity.
func (m *UserMutation) ClearLicense() {
	m.cleared_License = true
}

// LicenseCleared reports if the "License" edge to the License entity was cleared.
func (m *UserMutation) LicenseCleared() bool {
	return m.cleared_License
}

// LicenseID returns the "License" edge ID in the mutation.
func (m *UserMutation) LicenseID() (id uuid.UUID, exists bool) {
	if m._License != nil {
		return *m._License, true
	}
	return
}

// LicenseIDs returns the "License" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LicenseID instead. It exists only for internal usage by the builders.
func (m *UserMutation) LicenseIDs() (ids []uuid.UUID) {
	if id := m._License; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLicense resets all changes to the "License" edge.
func (m *UserMutation) ResetLicense() {
	m._License = nil
	m.cleared_License = false
}

// AddStatisticIDs adds the "Statistics" edge to the Statistic entity by ids.
func (m *UserMutation) AddStatisticIDs(ids ...uuid.UUID) {
	if m._Statistics == nil {
		m._Statistics = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Statistics[ids[i]] = struct{}{}
	}
}

// ClearStatistics clears the "Statistics" edge to the Statistic entity.
func (m *UserMutation) ClearStatistics() {
	m.cleared_Statistics = true
}

// StatisticsCleared reports if the "Statistics" edge to the Statistic entity was cleared.
func (m *UserMutation) StatisticsCleared() bool {
	return m.cleared_Statistics
}

// RemoveStatisticIDs removes the "Statistics" edge to the Statistic entity by IDs.
func (m *UserMutation) RemoveStatisticIDs(ids ...uuid.UUID) {
	if m.removed_Statistics == nil {
		m.removed_Statistics = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.removed_Statistics[ids[i]] = struct{}{}
	}
}

// RemovedStatistics returns the removed IDs of the "Statistics" edge to the Statistic entity.
func (m *UserMutation) RemovedStatisticsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Statistics {
		ids = append(ids, id)
	}
	return
}

// StatisticsIDs returns the "Statistics" edge IDs in the mutation.
func (m *UserMutation) StatisticsIDs() (ids []uuid.UUID) {
	for id := range m._Statistics {
		ids = append(ids, id)
	}
	return
}

// ResetStatistics resets all changes to the "Statistics" edge.
func (m *UserMutation) ResetStatistics() {
	m._Statistics = nil
	m.cleared_Statistics = false
	m.removed_Statistics = nil
}

// SetAppID sets the "App" edge to the App entity by id.
func (m *UserMutation) SetAppID(id uuid.UUID) {
	m._App = &id
}

// ClearApp clears the "App" edge to the App entity.
func (m *UserMutation) ClearApp() {
	m.cleared_App = true
}

// AppCleared reports if the "App" edge to the App entity was cleared.
func (m *UserMutation) AppCleared() bool {
	return m.cleared_App
}

// AppID returns the "App" edge ID in the mutation.
func (m *UserMutation) AppID() (id uuid.UUID, exists bool) {
	if m._App != nil {
		return *m._App, true
	}
	return
}

// AppIDs returns the "App" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *UserMutation) AppIDs() (ids []uuid.UUID) {
	if id := m._App; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "App" edge.
func (m *UserMutation) ResetApp() {
	m._App = nil
	m.cleared_App = false
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m._Disabled != nil {
		fields = append(fields, user.FieldDisabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDisabled:
		return m.Disabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDisabled:
		return m.OldDisabled(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDisabled:
		m.ResetDisabled()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._License != nil {
		edges = append(edges, user.EdgeLicense)
	}
	if m._Statistics != nil {
		edges = append(edges, user.EdgeStatistics)
	}
	if m._App != nil {
		edges = append(edges, user.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeLicense:
		if id := m._License; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeStatistics:
		ids := make([]ent.Value, 0, len(m._Statistics))
		for id := range m._Statistics {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApp:
		if id := m._App; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_Statistics != nil {
		edges = append(edges, user.EdgeStatistics)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeStatistics:
		ids := make([]ent.Value, 0, len(m.removed_Statistics))
		for id := range m.removed_Statistics {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_License {
		edges = append(edges, user.EdgeLicense)
	}
	if m.cleared_Statistics {
		edges = append(edges, user.EdgeStatistics)
	}
	if m.cleared_App {
		edges = append(edges, user.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeLicense:
		return m.cleared_License
	case user.EdgeStatistics:
		return m.cleared_Statistics
	case user.EdgeApp:
		return m.cleared_App
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeLicense:
		m.ClearLicense()
		return nil
	case user.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeLicense:
		m.ResetLicense()
		return nil
	case user.EdgeStatistics:
		m.ResetStatistics()
		return nil
	case user.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
