// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/ProjectAthenaa/sonic-core/sonic"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/accountgroup"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/address"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/app"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/billing"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/calendar"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/device"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/license"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/metadata"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/predicate"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/product"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/profile"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/profilegroup"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/proxy"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/proxylist"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/release"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/schema"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/session"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/settings"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/shipping"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/statistic"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/stripe"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/task"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/taskgroup"
	"github.com/ProjectAthenaa/sonic-core/sonic/database/ent/user"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccountGroup = "AccountGroup"
	TypeAddress      = "Address"
	TypeApp          = "App"
	TypeBilling      = "Billing"
	TypeCalendar     = "Calendar"
	TypeDevice       = "Device"
	TypeLicense      = "License"
	TypeMetadata     = "Metadata"
	TypeProduct      = "Product"
	TypeProfile      = "Profile"
	TypeProfileGroup = "ProfileGroup"
	TypeProxy        = "Proxy"
	TypeProxyList    = "ProxyList"
	TypeRelease      = "Release"
	TypeSession      = "Session"
	TypeSettings     = "Settings"
	TypeShipping     = "Shipping"
	TypeStatistic    = "Statistic"
	TypeStripe       = "Stripe"
	TypeTask         = "Task"
	TypeTaskGroup    = "TaskGroup"
	TypeUser         = "User"
)

// AccountGroupMutation represents an operation that mutates the AccountGroup nodes in the graph.
type AccountGroupMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	_Name         *string
	_Site         *accountgroup.Site
	_Accounts     *sonic.Map
	clearedFields map[string]struct{}
	_App          *uuid.UUID
	cleared_App   bool
	done          bool
	oldValue      func(context.Context) (*AccountGroup, error)
	predicates    []predicate.AccountGroup
}

var _ ent.Mutation = (*AccountGroupMutation)(nil)

// accountgroupOption allows management of the mutation configuration using functional options.
type accountgroupOption func(*AccountGroupMutation)

// newAccountGroupMutation creates new mutation for the AccountGroup entity.
func newAccountGroupMutation(c config, op Op, opts ...accountgroupOption) *AccountGroupMutation {
	m := &AccountGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountGroupID sets the ID field of the mutation.
func withAccountGroupID(id uuid.UUID) accountgroupOption {
	return func(m *AccountGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountGroup
		)
		m.oldValue = func(ctx context.Context) (*AccountGroup, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountGroup sets the old AccountGroup of the mutation.
func withAccountGroup(node *AccountGroup) accountgroupOption {
	return func(m *AccountGroupMutation) {
		m.oldValue = func(context.Context) (*AccountGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccountGroup entities.
func (m *AccountGroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountGroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccountGroup entity.
// If the AccountGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AccountGroup entity.
// If the AccountGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "Name" field.
func (m *AccountGroupMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *AccountGroupMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the AccountGroup entity.
// If the AccountGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *AccountGroupMutation) ResetName() {
	m._Name = nil
}

// SetSite sets the "Site" field.
func (m *AccountGroupMutation) SetSite(a accountgroup.Site) {
	m._Site = &a
}

// Site returns the value of the "Site" field in the mutation.
func (m *AccountGroupMutation) Site() (r accountgroup.Site, exists bool) {
	v := m._Site
	if v == nil {
		return
	}
	return *v, true
}

// OldSite returns the old "Site" field's value of the AccountGroup entity.
// If the AccountGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountGroupMutation) OldSite(ctx context.Context) (v accountgroup.Site, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSite: %w", err)
	}
	return oldValue.Site, nil
}

// ResetSite resets all changes to the "Site" field.
func (m *AccountGroupMutation) ResetSite() {
	m._Site = nil
}

// SetAccounts sets the "Accounts" field.
func (m *AccountGroupMutation) SetAccounts(s sonic.Map) {
	m._Accounts = &s
}

// Accounts returns the value of the "Accounts" field in the mutation.
func (m *AccountGroupMutation) Accounts() (r sonic.Map, exists bool) {
	v := m._Accounts
	if v == nil {
		return
	}
	return *v, true
}

// OldAccounts returns the old "Accounts" field's value of the AccountGroup entity.
// If the AccountGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountGroupMutation) OldAccounts(ctx context.Context) (v sonic.Map, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccounts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccounts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccounts: %w", err)
	}
	return oldValue.Accounts, nil
}

// ResetAccounts resets all changes to the "Accounts" field.
func (m *AccountGroupMutation) ResetAccounts() {
	m._Accounts = nil
}

// SetAppID sets the "App" edge to the App entity by id.
func (m *AccountGroupMutation) SetAppID(id uuid.UUID) {
	m._App = &id
}

// ClearApp clears the "App" edge to the App entity.
func (m *AccountGroupMutation) ClearApp() {
	m.cleared_App = true
}

// AppCleared reports if the "App" edge to the App entity was cleared.
func (m *AccountGroupMutation) AppCleared() bool {
	return m.cleared_App
}

// AppID returns the "App" edge ID in the mutation.
func (m *AccountGroupMutation) AppID() (id uuid.UUID, exists bool) {
	if m._App != nil {
		return *m._App, true
	}
	return
}

// AppIDs returns the "App" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AccountGroupMutation) AppIDs() (ids []uuid.UUID) {
	if id := m._App; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "App" edge.
func (m *AccountGroupMutation) ResetApp() {
	m._App = nil
	m.cleared_App = false
}

// Where appends a list predicates to the AccountGroupMutation builder.
func (m *AccountGroupMutation) Where(ps ...predicate.AccountGroup) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AccountGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AccountGroup).
func (m *AccountGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountGroupMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, accountgroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, accountgroup.FieldUpdatedAt)
	}
	if m._Name != nil {
		fields = append(fields, accountgroup.FieldName)
	}
	if m._Site != nil {
		fields = append(fields, accountgroup.FieldSite)
	}
	if m._Accounts != nil {
		fields = append(fields, accountgroup.FieldAccounts)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountgroup.FieldCreatedAt:
		return m.CreatedAt()
	case accountgroup.FieldUpdatedAt:
		return m.UpdatedAt()
	case accountgroup.FieldName:
		return m.Name()
	case accountgroup.FieldSite:
		return m.Site()
	case accountgroup.FieldAccounts:
		return m.Accounts()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountgroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accountgroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case accountgroup.FieldName:
		return m.OldName(ctx)
	case accountgroup.FieldSite:
		return m.OldSite(ctx)
	case accountgroup.FieldAccounts:
		return m.OldAccounts(ctx)
	}
	return nil, fmt.Errorf("unknown AccountGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accountgroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case accountgroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case accountgroup.FieldSite:
		v, ok := value.(accountgroup.Site)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSite(v)
		return nil
	case accountgroup.FieldAccounts:
		v, ok := value.(sonic.Map)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccounts(v)
		return nil
	}
	return fmt.Errorf("unknown AccountGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AccountGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccountGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountGroupMutation) ResetField(name string) error {
	switch name {
	case accountgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accountgroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case accountgroup.FieldName:
		m.ResetName()
		return nil
	case accountgroup.FieldSite:
		m.ResetSite()
		return nil
	case accountgroup.FieldAccounts:
		m.ResetAccounts()
		return nil
	}
	return fmt.Errorf("unknown AccountGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._App != nil {
		edges = append(edges, accountgroup.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountgroup.EdgeApp:
		if id := m._App; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_App {
		edges = append(edges, accountgroup.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case accountgroup.EdgeApp:
		return m.cleared_App
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountGroupMutation) ClearEdge(name string) error {
	switch name {
	case accountgroup.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AccountGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountGroupMutation) ResetEdge(name string) error {
	switch name {
	case accountgroup.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown AccountGroup edge %s", name)
}

// AddressMutation represents an operation that mutates the Address nodes in the graph.
type AddressMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *time.Time
	updated_at              *time.Time
	_AddressLine            *string
	_AddressLine2           *string
	_Country                *string
	_State                  *string
	_City                   *string
	_ZIP                    *string
	_StateCode              *string
	clearedFields           map[string]struct{}
	_ShippingAddress        *uuid.UUID
	cleared_ShippingAddress bool
	_BillingAddress         map[uuid.UUID]struct{}
	removed_BillingAddress  map[uuid.UUID]struct{}
	cleared_BillingAddress  bool
	done                    bool
	oldValue                func(context.Context) (*Address, error)
	predicates              []predicate.Address
}

var _ ent.Mutation = (*AddressMutation)(nil)

// addressOption allows management of the mutation configuration using functional options.
type addressOption func(*AddressMutation)

// newAddressMutation creates new mutation for the Address entity.
func newAddressMutation(c config, op Op, opts ...addressOption) *AddressMutation {
	m := &AddressMutation{
		config:        c,
		op:            op,
		typ:           TypeAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddressID sets the ID field of the mutation.
func withAddressID(id uuid.UUID) addressOption {
	return func(m *AddressMutation) {
		var (
			err   error
			once  sync.Once
			value *Address
		)
		m.oldValue = func(ctx context.Context) (*Address, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Address.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddress sets the old Address of the mutation.
func withAddress(node *Address) addressOption {
	return func(m *AddressMutation) {
		m.oldValue = func(context.Context) (*Address, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Address entities.
func (m *AddressMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AddressMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *AddressMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AddressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AddressMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AddressMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AddressMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AddressMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAddressLine sets the "AddressLine" field.
func (m *AddressMutation) SetAddressLine(s string) {
	m._AddressLine = &s
}

// AddressLine returns the value of the "AddressLine" field in the mutation.
func (m *AddressMutation) AddressLine() (r string, exists bool) {
	v := m._AddressLine
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressLine returns the old "AddressLine" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldAddressLine(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddressLine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddressLine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressLine: %w", err)
	}
	return oldValue.AddressLine, nil
}

// ResetAddressLine resets all changes to the "AddressLine" field.
func (m *AddressMutation) ResetAddressLine() {
	m._AddressLine = nil
}

// SetAddressLine2 sets the "AddressLine2" field.
func (m *AddressMutation) SetAddressLine2(s string) {
	m._AddressLine2 = &s
}

// AddressLine2 returns the value of the "AddressLine2" field in the mutation.
func (m *AddressMutation) AddressLine2() (r string, exists bool) {
	v := m._AddressLine2
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressLine2 returns the old "AddressLine2" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldAddressLine2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddressLine2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddressLine2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressLine2: %w", err)
	}
	return oldValue.AddressLine2, nil
}

// ClearAddressLine2 clears the value of the "AddressLine2" field.
func (m *AddressMutation) ClearAddressLine2() {
	m._AddressLine2 = nil
	m.clearedFields[address.FieldAddressLine2] = struct{}{}
}

// AddressLine2Cleared returns if the "AddressLine2" field was cleared in this mutation.
func (m *AddressMutation) AddressLine2Cleared() bool {
	_, ok := m.clearedFields[address.FieldAddressLine2]
	return ok
}

// ResetAddressLine2 resets all changes to the "AddressLine2" field.
func (m *AddressMutation) ResetAddressLine2() {
	m._AddressLine2 = nil
	delete(m.clearedFields, address.FieldAddressLine2)
}

// SetCountry sets the "Country" field.
func (m *AddressMutation) SetCountry(s string) {
	m._Country = &s
}

// Country returns the value of the "Country" field in the mutation.
func (m *AddressMutation) Country() (r string, exists bool) {
	v := m._Country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "Country" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "Country" field.
func (m *AddressMutation) ResetCountry() {
	m._Country = nil
}

// SetState sets the "State" field.
func (m *AddressMutation) SetState(s string) {
	m._State = &s
}

// State returns the value of the "State" field in the mutation.
func (m *AddressMutation) State() (r string, exists bool) {
	v := m._State
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "State" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "State" field.
func (m *AddressMutation) ResetState() {
	m._State = nil
}

// SetCity sets the "City" field.
func (m *AddressMutation) SetCity(s string) {
	m._City = &s
}

// City returns the value of the "City" field in the mutation.
func (m *AddressMutation) City() (r string, exists bool) {
	v := m._City
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "City" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "City" field.
func (m *AddressMutation) ResetCity() {
	m._City = nil
}

// SetZIP sets the "ZIP" field.
func (m *AddressMutation) SetZIP(s string) {
	m._ZIP = &s
}

// ZIP returns the value of the "ZIP" field in the mutation.
func (m *AddressMutation) ZIP() (r string, exists bool) {
	v := m._ZIP
	if v == nil {
		return
	}
	return *v, true
}

// OldZIP returns the old "ZIP" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldZIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldZIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldZIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZIP: %w", err)
	}
	return oldValue.ZIP, nil
}

// ResetZIP resets all changes to the "ZIP" field.
func (m *AddressMutation) ResetZIP() {
	m._ZIP = nil
}

// SetStateCode sets the "StateCode" field.
func (m *AddressMutation) SetStateCode(s string) {
	m._StateCode = &s
}

// StateCode returns the value of the "StateCode" field in the mutation.
func (m *AddressMutation) StateCode() (r string, exists bool) {
	v := m._StateCode
	if v == nil {
		return
	}
	return *v, true
}

// OldStateCode returns the old "StateCode" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldStateCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStateCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStateCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateCode: %w", err)
	}
	return oldValue.StateCode, nil
}

// ClearStateCode clears the value of the "StateCode" field.
func (m *AddressMutation) ClearStateCode() {
	m._StateCode = nil
	m.clearedFields[address.FieldStateCode] = struct{}{}
}

// StateCodeCleared returns if the "StateCode" field was cleared in this mutation.
func (m *AddressMutation) StateCodeCleared() bool {
	_, ok := m.clearedFields[address.FieldStateCode]
	return ok
}

// ResetStateCode resets all changes to the "StateCode" field.
func (m *AddressMutation) ResetStateCode() {
	m._StateCode = nil
	delete(m.clearedFields, address.FieldStateCode)
}

// SetShippingAddressID sets the "ShippingAddress" edge to the Shipping entity by id.
func (m *AddressMutation) SetShippingAddressID(id uuid.UUID) {
	m._ShippingAddress = &id
}

// ClearShippingAddress clears the "ShippingAddress" edge to the Shipping entity.
func (m *AddressMutation) ClearShippingAddress() {
	m.cleared_ShippingAddress = true
}

// ShippingAddressCleared reports if the "ShippingAddress" edge to the Shipping entity was cleared.
func (m *AddressMutation) ShippingAddressCleared() bool {
	return m.cleared_ShippingAddress
}

// ShippingAddressID returns the "ShippingAddress" edge ID in the mutation.
func (m *AddressMutation) ShippingAddressID() (id uuid.UUID, exists bool) {
	if m._ShippingAddress != nil {
		return *m._ShippingAddress, true
	}
	return
}

// ShippingAddressIDs returns the "ShippingAddress" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShippingAddressID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) ShippingAddressIDs() (ids []uuid.UUID) {
	if id := m._ShippingAddress; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShippingAddress resets all changes to the "ShippingAddress" edge.
func (m *AddressMutation) ResetShippingAddress() {
	m._ShippingAddress = nil
	m.cleared_ShippingAddress = false
}

// AddBillingAddresIDs adds the "BillingAddress" edge to the Shipping entity by ids.
func (m *AddressMutation) AddBillingAddresIDs(ids ...uuid.UUID) {
	if m._BillingAddress == nil {
		m._BillingAddress = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._BillingAddress[ids[i]] = struct{}{}
	}
}

// ClearBillingAddress clears the "BillingAddress" edge to the Shipping entity.
func (m *AddressMutation) ClearBillingAddress() {
	m.cleared_BillingAddress = true
}

// BillingAddressCleared reports if the "BillingAddress" edge to the Shipping entity was cleared.
func (m *AddressMutation) BillingAddressCleared() bool {
	return m.cleared_BillingAddress
}

// RemoveBillingAddresIDs removes the "BillingAddress" edge to the Shipping entity by IDs.
func (m *AddressMutation) RemoveBillingAddresIDs(ids ...uuid.UUID) {
	if m.removed_BillingAddress == nil {
		m.removed_BillingAddress = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._BillingAddress, ids[i])
		m.removed_BillingAddress[ids[i]] = struct{}{}
	}
}

// RemovedBillingAddress returns the removed IDs of the "BillingAddress" edge to the Shipping entity.
func (m *AddressMutation) RemovedBillingAddressIDs() (ids []uuid.UUID) {
	for id := range m.removed_BillingAddress {
		ids = append(ids, id)
	}
	return
}

// BillingAddressIDs returns the "BillingAddress" edge IDs in the mutation.
func (m *AddressMutation) BillingAddressIDs() (ids []uuid.UUID) {
	for id := range m._BillingAddress {
		ids = append(ids, id)
	}
	return
}

// ResetBillingAddress resets all changes to the "BillingAddress" edge.
func (m *AddressMutation) ResetBillingAddress() {
	m._BillingAddress = nil
	m.cleared_BillingAddress = false
	m.removed_BillingAddress = nil
}

// Where appends a list predicates to the AddressMutation builder.
func (m *AddressMutation) Where(ps ...predicate.Address) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AddressMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Address).
func (m *AddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddressMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, address.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, address.FieldUpdatedAt)
	}
	if m._AddressLine != nil {
		fields = append(fields, address.FieldAddressLine)
	}
	if m._AddressLine2 != nil {
		fields = append(fields, address.FieldAddressLine2)
	}
	if m._Country != nil {
		fields = append(fields, address.FieldCountry)
	}
	if m._State != nil {
		fields = append(fields, address.FieldState)
	}
	if m._City != nil {
		fields = append(fields, address.FieldCity)
	}
	if m._ZIP != nil {
		fields = append(fields, address.FieldZIP)
	}
	if m._StateCode != nil {
		fields = append(fields, address.FieldStateCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case address.FieldCreatedAt:
		return m.CreatedAt()
	case address.FieldUpdatedAt:
		return m.UpdatedAt()
	case address.FieldAddressLine:
		return m.AddressLine()
	case address.FieldAddressLine2:
		return m.AddressLine2()
	case address.FieldCountry:
		return m.Country()
	case address.FieldState:
		return m.State()
	case address.FieldCity:
		return m.City()
	case address.FieldZIP:
		return m.ZIP()
	case address.FieldStateCode:
		return m.StateCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case address.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case address.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case address.FieldAddressLine:
		return m.OldAddressLine(ctx)
	case address.FieldAddressLine2:
		return m.OldAddressLine2(ctx)
	case address.FieldCountry:
		return m.OldCountry(ctx)
	case address.FieldState:
		return m.OldState(ctx)
	case address.FieldCity:
		return m.OldCity(ctx)
	case address.FieldZIP:
		return m.OldZIP(ctx)
	case address.FieldStateCode:
		return m.OldStateCode(ctx)
	}
	return nil, fmt.Errorf("unknown Address field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case address.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case address.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case address.FieldAddressLine:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressLine(v)
		return nil
	case address.FieldAddressLine2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressLine2(v)
		return nil
	case address.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case address.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case address.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case address.FieldZIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZIP(v)
		return nil
	case address.FieldStateCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateCode(v)
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Address numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(address.FieldAddressLine2) {
		fields = append(fields, address.FieldAddressLine2)
	}
	if m.FieldCleared(address.FieldStateCode) {
		fields = append(fields, address.FieldStateCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddressMutation) ClearField(name string) error {
	switch name {
	case address.FieldAddressLine2:
		m.ClearAddressLine2()
		return nil
	case address.FieldStateCode:
		m.ClearStateCode()
		return nil
	}
	return fmt.Errorf("unknown Address nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddressMutation) ResetField(name string) error {
	switch name {
	case address.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case address.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case address.FieldAddressLine:
		m.ResetAddressLine()
		return nil
	case address.FieldAddressLine2:
		m.ResetAddressLine2()
		return nil
	case address.FieldCountry:
		m.ResetCountry()
		return nil
	case address.FieldState:
		m.ResetState()
		return nil
	case address.FieldCity:
		m.ResetCity()
		return nil
	case address.FieldZIP:
		m.ResetZIP()
		return nil
	case address.FieldStateCode:
		m.ResetStateCode()
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._ShippingAddress != nil {
		edges = append(edges, address.EdgeShippingAddress)
	}
	if m._BillingAddress != nil {
		edges = append(edges, address.EdgeBillingAddress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeShippingAddress:
		if id := m._ShippingAddress; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgeBillingAddress:
		ids := make([]ent.Value, 0, len(m._BillingAddress))
		for id := range m._BillingAddress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_BillingAddress != nil {
		edges = append(edges, address.EdgeBillingAddress)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeBillingAddress:
		ids := make([]ent.Value, 0, len(m.removed_BillingAddress))
		for id := range m.removed_BillingAddress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_ShippingAddress {
		edges = append(edges, address.EdgeShippingAddress)
	}
	if m.cleared_BillingAddress {
		edges = append(edges, address.EdgeBillingAddress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddressMutation) EdgeCleared(name string) bool {
	switch name {
	case address.EdgeShippingAddress:
		return m.cleared_ShippingAddress
	case address.EdgeBillingAddress:
		return m.cleared_BillingAddress
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddressMutation) ClearEdge(name string) error {
	switch name {
	case address.EdgeShippingAddress:
		m.ClearShippingAddress()
		return nil
	}
	return fmt.Errorf("unknown Address unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddressMutation) ResetEdge(name string) error {
	switch name {
	case address.EdgeShippingAddress:
		m.ResetShippingAddress()
		return nil
	case address.EdgeBillingAddress:
		m.ResetBillingAddress()
		return nil
	}
	return fmt.Errorf("unknown Address edge %s", name)
}

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	_User                 *uuid.UUID
	cleared_User          bool
	_Settings             map[uuid.UUID]struct{}
	removed_Settings      map[uuid.UUID]struct{}
	cleared_Settings      bool
	_ProxyLists           map[uuid.UUID]struct{}
	removed_ProxyLists    map[uuid.UUID]struct{}
	cleared_ProxyLists    bool
	_ProfileGroups        map[uuid.UUID]struct{}
	removed_ProfileGroups map[uuid.UUID]struct{}
	cleared_ProfileGroups bool
	_TaskGroups           map[uuid.UUID]struct{}
	removed_TaskGroups    map[uuid.UUID]struct{}
	cleared_TaskGroups    bool
	_AccountGroups        map[uuid.UUID]struct{}
	removed_AccountGroups map[uuid.UUID]struct{}
	cleared_AccountGroups bool
	done                  bool
	oldValue              func(context.Context) (*App, error)
	predicates            []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id uuid.UUID) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "User" edge to the User entity by id.
func (m *AppMutation) SetUserID(id uuid.UUID) {
	m._User = &id
}

// ClearUser clears the "User" edge to the User entity.
func (m *AppMutation) ClearUser() {
	m.cleared_User = true
}

// UserCleared reports if the "User" edge to the User entity was cleared.
func (m *AppMutation) UserCleared() bool {
	return m.cleared_User
}

// UserID returns the "User" edge ID in the mutation.
func (m *AppMutation) UserID() (id uuid.UUID, exists bool) {
	if m._User != nil {
		return *m._User, true
	}
	return
}

// UserIDs returns the "User" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AppMutation) UserIDs() (ids []uuid.UUID) {
	if id := m._User; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "User" edge.
func (m *AppMutation) ResetUser() {
	m._User = nil
	m.cleared_User = false
}

// AddSettingIDs adds the "Settings" edge to the Settings entity by ids.
func (m *AppMutation) AddSettingIDs(ids ...uuid.UUID) {
	if m._Settings == nil {
		m._Settings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Settings[ids[i]] = struct{}{}
	}
}

// ClearSettings clears the "Settings" edge to the Settings entity.
func (m *AppMutation) ClearSettings() {
	m.cleared_Settings = true
}

// SettingsCleared reports if the "Settings" edge to the Settings entity was cleared.
func (m *AppMutation) SettingsCleared() bool {
	return m.cleared_Settings
}

// RemoveSettingIDs removes the "Settings" edge to the Settings entity by IDs.
func (m *AppMutation) RemoveSettingIDs(ids ...uuid.UUID) {
	if m.removed_Settings == nil {
		m.removed_Settings = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Settings, ids[i])
		m.removed_Settings[ids[i]] = struct{}{}
	}
}

// RemovedSettings returns the removed IDs of the "Settings" edge to the Settings entity.
func (m *AppMutation) RemovedSettingsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Settings {
		ids = append(ids, id)
	}
	return
}

// SettingsIDs returns the "Settings" edge IDs in the mutation.
func (m *AppMutation) SettingsIDs() (ids []uuid.UUID) {
	for id := range m._Settings {
		ids = append(ids, id)
	}
	return
}

// ResetSettings resets all changes to the "Settings" edge.
func (m *AppMutation) ResetSettings() {
	m._Settings = nil
	m.cleared_Settings = false
	m.removed_Settings = nil
}

// AddProxyListIDs adds the "ProxyLists" edge to the ProxyList entity by ids.
func (m *AppMutation) AddProxyListIDs(ids ...uuid.UUID) {
	if m._ProxyLists == nil {
		m._ProxyLists = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ProxyLists[ids[i]] = struct{}{}
	}
}

// ClearProxyLists clears the "ProxyLists" edge to the ProxyList entity.
func (m *AppMutation) ClearProxyLists() {
	m.cleared_ProxyLists = true
}

// ProxyListsCleared reports if the "ProxyLists" edge to the ProxyList entity was cleared.
func (m *AppMutation) ProxyListsCleared() bool {
	return m.cleared_ProxyLists
}

// RemoveProxyListIDs removes the "ProxyLists" edge to the ProxyList entity by IDs.
func (m *AppMutation) RemoveProxyListIDs(ids ...uuid.UUID) {
	if m.removed_ProxyLists == nil {
		m.removed_ProxyLists = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ProxyLists, ids[i])
		m.removed_ProxyLists[ids[i]] = struct{}{}
	}
}

// RemovedProxyLists returns the removed IDs of the "ProxyLists" edge to the ProxyList entity.
func (m *AppMutation) RemovedProxyListsIDs() (ids []uuid.UUID) {
	for id := range m.removed_ProxyLists {
		ids = append(ids, id)
	}
	return
}

// ProxyListsIDs returns the "ProxyLists" edge IDs in the mutation.
func (m *AppMutation) ProxyListsIDs() (ids []uuid.UUID) {
	for id := range m._ProxyLists {
		ids = append(ids, id)
	}
	return
}

// ResetProxyLists resets all changes to the "ProxyLists" edge.
func (m *AppMutation) ResetProxyLists() {
	m._ProxyLists = nil
	m.cleared_ProxyLists = false
	m.removed_ProxyLists = nil
}

// AddProfileGroupIDs adds the "ProfileGroups" edge to the ProfileGroup entity by ids.
func (m *AppMutation) AddProfileGroupIDs(ids ...uuid.UUID) {
	if m._ProfileGroups == nil {
		m._ProfileGroups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ProfileGroups[ids[i]] = struct{}{}
	}
}

// ClearProfileGroups clears the "ProfileGroups" edge to the ProfileGroup entity.
func (m *AppMutation) ClearProfileGroups() {
	m.cleared_ProfileGroups = true
}

// ProfileGroupsCleared reports if the "ProfileGroups" edge to the ProfileGroup entity was cleared.
func (m *AppMutation) ProfileGroupsCleared() bool {
	return m.cleared_ProfileGroups
}

// RemoveProfileGroupIDs removes the "ProfileGroups" edge to the ProfileGroup entity by IDs.
func (m *AppMutation) RemoveProfileGroupIDs(ids ...uuid.UUID) {
	if m.removed_ProfileGroups == nil {
		m.removed_ProfileGroups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ProfileGroups, ids[i])
		m.removed_ProfileGroups[ids[i]] = struct{}{}
	}
}

// RemovedProfileGroups returns the removed IDs of the "ProfileGroups" edge to the ProfileGroup entity.
func (m *AppMutation) RemovedProfileGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removed_ProfileGroups {
		ids = append(ids, id)
	}
	return
}

// ProfileGroupsIDs returns the "ProfileGroups" edge IDs in the mutation.
func (m *AppMutation) ProfileGroupsIDs() (ids []uuid.UUID) {
	for id := range m._ProfileGroups {
		ids = append(ids, id)
	}
	return
}

// ResetProfileGroups resets all changes to the "ProfileGroups" edge.
func (m *AppMutation) ResetProfileGroups() {
	m._ProfileGroups = nil
	m.cleared_ProfileGroups = false
	m.removed_ProfileGroups = nil
}

// AddTaskGroupIDs adds the "TaskGroups" edge to the TaskGroup entity by ids.
func (m *AppMutation) AddTaskGroupIDs(ids ...uuid.UUID) {
	if m._TaskGroups == nil {
		m._TaskGroups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._TaskGroups[ids[i]] = struct{}{}
	}
}

// ClearTaskGroups clears the "TaskGroups" edge to the TaskGroup entity.
func (m *AppMutation) ClearTaskGroups() {
	m.cleared_TaskGroups = true
}

// TaskGroupsCleared reports if the "TaskGroups" edge to the TaskGroup entity was cleared.
func (m *AppMutation) TaskGroupsCleared() bool {
	return m.cleared_TaskGroups
}

// RemoveTaskGroupIDs removes the "TaskGroups" edge to the TaskGroup entity by IDs.
func (m *AppMutation) RemoveTaskGroupIDs(ids ...uuid.UUID) {
	if m.removed_TaskGroups == nil {
		m.removed_TaskGroups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._TaskGroups, ids[i])
		m.removed_TaskGroups[ids[i]] = struct{}{}
	}
}

// RemovedTaskGroups returns the removed IDs of the "TaskGroups" edge to the TaskGroup entity.
func (m *AppMutation) RemovedTaskGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removed_TaskGroups {
		ids = append(ids, id)
	}
	return
}

// TaskGroupsIDs returns the "TaskGroups" edge IDs in the mutation.
func (m *AppMutation) TaskGroupsIDs() (ids []uuid.UUID) {
	for id := range m._TaskGroups {
		ids = append(ids, id)
	}
	return
}

// ResetTaskGroups resets all changes to the "TaskGroups" edge.
func (m *AppMutation) ResetTaskGroups() {
	m._TaskGroups = nil
	m.cleared_TaskGroups = false
	m.removed_TaskGroups = nil
}

// AddAccountGroupIDs adds the "AccountGroups" edge to the AccountGroup entity by ids.
func (m *AppMutation) AddAccountGroupIDs(ids ...uuid.UUID) {
	if m._AccountGroups == nil {
		m._AccountGroups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._AccountGroups[ids[i]] = struct{}{}
	}
}

// ClearAccountGroups clears the "AccountGroups" edge to the AccountGroup entity.
func (m *AppMutation) ClearAccountGroups() {
	m.cleared_AccountGroups = true
}

// AccountGroupsCleared reports if the "AccountGroups" edge to the AccountGroup entity was cleared.
func (m *AppMutation) AccountGroupsCleared() bool {
	return m.cleared_AccountGroups
}

// RemoveAccountGroupIDs removes the "AccountGroups" edge to the AccountGroup entity by IDs.
func (m *AppMutation) RemoveAccountGroupIDs(ids ...uuid.UUID) {
	if m.removed_AccountGroups == nil {
		m.removed_AccountGroups = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._AccountGroups, ids[i])
		m.removed_AccountGroups[ids[i]] = struct{}{}
	}
}

// RemovedAccountGroups returns the removed IDs of the "AccountGroups" edge to the AccountGroup entity.
func (m *AppMutation) RemovedAccountGroupsIDs() (ids []uuid.UUID) {
	for id := range m.removed_AccountGroups {
		ids = append(ids, id)
	}
	return
}

// AccountGroupsIDs returns the "AccountGroups" edge IDs in the mutation.
func (m *AppMutation) AccountGroupsIDs() (ids []uuid.UUID) {
	for id := range m._AccountGroups {
		ids = append(ids, id)
	}
	return
}

// ResetAccountGroups resets all changes to the "AccountGroups" edge.
func (m *AppMutation) ResetAccountGroups() {
	m._AccountGroups = nil
	m.cleared_AccountGroups = false
	m.removed_AccountGroups = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreatedAt:
		return m.CreatedAt()
	case app.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case app.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case app.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m._User != nil {
		edges = append(edges, app.EdgeUser)
	}
	if m._Settings != nil {
		edges = append(edges, app.EdgeSettings)
	}
	if m._ProxyLists != nil {
		edges = append(edges, app.EdgeProxyLists)
	}
	if m._ProfileGroups != nil {
		edges = append(edges, app.EdgeProfileGroups)
	}
	if m._TaskGroups != nil {
		edges = append(edges, app.EdgeTaskGroups)
	}
	if m._AccountGroups != nil {
		edges = append(edges, app.EdgeAccountGroups)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeUser:
		if id := m._User; id != nil {
			return []ent.Value{*id}
		}
	case app.EdgeSettings:
		ids := make([]ent.Value, 0, len(m._Settings))
		for id := range m._Settings {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeProxyLists:
		ids := make([]ent.Value, 0, len(m._ProxyLists))
		for id := range m._ProxyLists {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeProfileGroups:
		ids := make([]ent.Value, 0, len(m._ProfileGroups))
		for id := range m._ProfileGroups {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeTaskGroups:
		ids := make([]ent.Value, 0, len(m._TaskGroups))
		for id := range m._TaskGroups {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeAccountGroups:
		ids := make([]ent.Value, 0, len(m._AccountGroups))
		for id := range m._AccountGroups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removed_Settings != nil {
		edges = append(edges, app.EdgeSettings)
	}
	if m.removed_ProxyLists != nil {
		edges = append(edges, app.EdgeProxyLists)
	}
	if m.removed_ProfileGroups != nil {
		edges = append(edges, app.EdgeProfileGroups)
	}
	if m.removed_TaskGroups != nil {
		edges = append(edges, app.EdgeTaskGroups)
	}
	if m.removed_AccountGroups != nil {
		edges = append(edges, app.EdgeAccountGroups)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeSettings:
		ids := make([]ent.Value, 0, len(m.removed_Settings))
		for id := range m.removed_Settings {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeProxyLists:
		ids := make([]ent.Value, 0, len(m.removed_ProxyLists))
		for id := range m.removed_ProxyLists {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeProfileGroups:
		ids := make([]ent.Value, 0, len(m.removed_ProfileGroups))
		for id := range m.removed_ProfileGroups {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeTaskGroups:
		ids := make([]ent.Value, 0, len(m.removed_TaskGroups))
		for id := range m.removed_TaskGroups {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeAccountGroups:
		ids := make([]ent.Value, 0, len(m.removed_AccountGroups))
		for id := range m.removed_AccountGroups {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleared_User {
		edges = append(edges, app.EdgeUser)
	}
	if m.cleared_Settings {
		edges = append(edges, app.EdgeSettings)
	}
	if m.cleared_ProxyLists {
		edges = append(edges, app.EdgeProxyLists)
	}
	if m.cleared_ProfileGroups {
		edges = append(edges, app.EdgeProfileGroups)
	}
	if m.cleared_TaskGroups {
		edges = append(edges, app.EdgeTaskGroups)
	}
	if m.cleared_AccountGroups {
		edges = append(edges, app.EdgeAccountGroups)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	case app.EdgeUser:
		return m.cleared_User
	case app.EdgeSettings:
		return m.cleared_Settings
	case app.EdgeProxyLists:
		return m.cleared_ProxyLists
	case app.EdgeProfileGroups:
		return m.cleared_ProfileGroups
	case app.EdgeTaskGroups:
		return m.cleared_TaskGroups
	case app.EdgeAccountGroups:
		return m.cleared_AccountGroups
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	case app.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case app.EdgeUser:
		m.ResetUser()
		return nil
	case app.EdgeSettings:
		m.ResetSettings()
		return nil
	case app.EdgeProxyLists:
		m.ResetProxyLists()
		return nil
	case app.EdgeProfileGroups:
		m.ResetProfileGroups()
		return nil
	case app.EdgeTaskGroups:
		m.ResetTaskGroups()
		return nil
	case app.EdgeAccountGroups:
		m.ResetAccountGroups()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// BillingMutation represents an operation that mutates the Billing nodes in the graph.
type BillingMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	_CardholderName *string
	_CardNumber     *string
	_ExpiryMonth    *string
	_ExpiryYear     *string
	_CVV            *string
	clearedFields   map[string]struct{}
	_Profile        map[uuid.UUID]struct{}
	removed_Profile map[uuid.UUID]struct{}
	cleared_Profile bool
	done            bool
	oldValue        func(context.Context) (*Billing, error)
	predicates      []predicate.Billing
}

var _ ent.Mutation = (*BillingMutation)(nil)

// billingOption allows management of the mutation configuration using functional options.
type billingOption func(*BillingMutation)

// newBillingMutation creates new mutation for the Billing entity.
func newBillingMutation(c config, op Op, opts ...billingOption) *BillingMutation {
	m := &BillingMutation{
		config:        c,
		op:            op,
		typ:           TypeBilling,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBillingID sets the ID field of the mutation.
func withBillingID(id uuid.UUID) billingOption {
	return func(m *BillingMutation) {
		var (
			err   error
			once  sync.Once
			value *Billing
		)
		m.oldValue = func(ctx context.Context) (*Billing, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Billing.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBilling sets the old Billing of the mutation.
func withBilling(node *Billing) billingOption {
	return func(m *BillingMutation) {
		m.oldValue = func(context.Context) (*Billing, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BillingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BillingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Billing entities.
func (m *BillingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BillingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *BillingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BillingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Billing entity.
// If the Billing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BillingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BillingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BillingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Billing entity.
// If the Billing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BillingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCardholderName sets the "CardholderName" field.
func (m *BillingMutation) SetCardholderName(s string) {
	m._CardholderName = &s
}

// CardholderName returns the value of the "CardholderName" field in the mutation.
func (m *BillingMutation) CardholderName() (r string, exists bool) {
	v := m._CardholderName
	if v == nil {
		return
	}
	return *v, true
}

// OldCardholderName returns the old "CardholderName" field's value of the Billing entity.
// If the Billing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingMutation) OldCardholderName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCardholderName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCardholderName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardholderName: %w", err)
	}
	return oldValue.CardholderName, nil
}

// ResetCardholderName resets all changes to the "CardholderName" field.
func (m *BillingMutation) ResetCardholderName() {
	m._CardholderName = nil
}

// SetCardNumber sets the "CardNumber" field.
func (m *BillingMutation) SetCardNumber(s string) {
	m._CardNumber = &s
}

// CardNumber returns the value of the "CardNumber" field in the mutation.
func (m *BillingMutation) CardNumber() (r string, exists bool) {
	v := m._CardNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldCardNumber returns the old "CardNumber" field's value of the Billing entity.
// If the Billing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingMutation) OldCardNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCardNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCardNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardNumber: %w", err)
	}
	return oldValue.CardNumber, nil
}

// ResetCardNumber resets all changes to the "CardNumber" field.
func (m *BillingMutation) ResetCardNumber() {
	m._CardNumber = nil
}

// SetExpiryMonth sets the "ExpiryMonth" field.
func (m *BillingMutation) SetExpiryMonth(s string) {
	m._ExpiryMonth = &s
}

// ExpiryMonth returns the value of the "ExpiryMonth" field in the mutation.
func (m *BillingMutation) ExpiryMonth() (r string, exists bool) {
	v := m._ExpiryMonth
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiryMonth returns the old "ExpiryMonth" field's value of the Billing entity.
// If the Billing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingMutation) OldExpiryMonth(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpiryMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpiryMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiryMonth: %w", err)
	}
	return oldValue.ExpiryMonth, nil
}

// ResetExpiryMonth resets all changes to the "ExpiryMonth" field.
func (m *BillingMutation) ResetExpiryMonth() {
	m._ExpiryMonth = nil
}

// SetExpiryYear sets the "ExpiryYear" field.
func (m *BillingMutation) SetExpiryYear(s string) {
	m._ExpiryYear = &s
}

// ExpiryYear returns the value of the "ExpiryYear" field in the mutation.
func (m *BillingMutation) ExpiryYear() (r string, exists bool) {
	v := m._ExpiryYear
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiryYear returns the old "ExpiryYear" field's value of the Billing entity.
// If the Billing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingMutation) OldExpiryYear(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpiryYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpiryYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiryYear: %w", err)
	}
	return oldValue.ExpiryYear, nil
}

// ResetExpiryYear resets all changes to the "ExpiryYear" field.
func (m *BillingMutation) ResetExpiryYear() {
	m._ExpiryYear = nil
}

// SetCVV sets the "CVV" field.
func (m *BillingMutation) SetCVV(s string) {
	m._CVV = &s
}

// CVV returns the value of the "CVV" field in the mutation.
func (m *BillingMutation) CVV() (r string, exists bool) {
	v := m._CVV
	if v == nil {
		return
	}
	return *v, true
}

// OldCVV returns the old "CVV" field's value of the Billing entity.
// If the Billing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BillingMutation) OldCVV(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCVV is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCVV requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCVV: %w", err)
	}
	return oldValue.CVV, nil
}

// ResetCVV resets all changes to the "CVV" field.
func (m *BillingMutation) ResetCVV() {
	m._CVV = nil
}

// AddProfileIDs adds the "Profile" edge to the Profile entity by ids.
func (m *BillingMutation) AddProfileIDs(ids ...uuid.UUID) {
	if m._Profile == nil {
		m._Profile = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Profile[ids[i]] = struct{}{}
	}
}

// ClearProfile clears the "Profile" edge to the Profile entity.
func (m *BillingMutation) ClearProfile() {
	m.cleared_Profile = true
}

// ProfileCleared reports if the "Profile" edge to the Profile entity was cleared.
func (m *BillingMutation) ProfileCleared() bool {
	return m.cleared_Profile
}

// RemoveProfileIDs removes the "Profile" edge to the Profile entity by IDs.
func (m *BillingMutation) RemoveProfileIDs(ids ...uuid.UUID) {
	if m.removed_Profile == nil {
		m.removed_Profile = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Profile, ids[i])
		m.removed_Profile[ids[i]] = struct{}{}
	}
}

// RemovedProfile returns the removed IDs of the "Profile" edge to the Profile entity.
func (m *BillingMutation) RemovedProfileIDs() (ids []uuid.UUID) {
	for id := range m.removed_Profile {
		ids = append(ids, id)
	}
	return
}

// ProfileIDs returns the "Profile" edge IDs in the mutation.
func (m *BillingMutation) ProfileIDs() (ids []uuid.UUID) {
	for id := range m._Profile {
		ids = append(ids, id)
	}
	return
}

// ResetProfile resets all changes to the "Profile" edge.
func (m *BillingMutation) ResetProfile() {
	m._Profile = nil
	m.cleared_Profile = false
	m.removed_Profile = nil
}

// Where appends a list predicates to the BillingMutation builder.
func (m *BillingMutation) Where(ps ...predicate.Billing) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BillingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Billing).
func (m *BillingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BillingMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, billing.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, billing.FieldUpdatedAt)
	}
	if m._CardholderName != nil {
		fields = append(fields, billing.FieldCardholderName)
	}
	if m._CardNumber != nil {
		fields = append(fields, billing.FieldCardNumber)
	}
	if m._ExpiryMonth != nil {
		fields = append(fields, billing.FieldExpiryMonth)
	}
	if m._ExpiryYear != nil {
		fields = append(fields, billing.FieldExpiryYear)
	}
	if m._CVV != nil {
		fields = append(fields, billing.FieldCVV)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BillingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case billing.FieldCreatedAt:
		return m.CreatedAt()
	case billing.FieldUpdatedAt:
		return m.UpdatedAt()
	case billing.FieldCardholderName:
		return m.CardholderName()
	case billing.FieldCardNumber:
		return m.CardNumber()
	case billing.FieldExpiryMonth:
		return m.ExpiryMonth()
	case billing.FieldExpiryYear:
		return m.ExpiryYear()
	case billing.FieldCVV:
		return m.CVV()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BillingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case billing.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case billing.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case billing.FieldCardholderName:
		return m.OldCardholderName(ctx)
	case billing.FieldCardNumber:
		return m.OldCardNumber(ctx)
	case billing.FieldExpiryMonth:
		return m.OldExpiryMonth(ctx)
	case billing.FieldExpiryYear:
		return m.OldExpiryYear(ctx)
	case billing.FieldCVV:
		return m.OldCVV(ctx)
	}
	return nil, fmt.Errorf("unknown Billing field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case billing.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case billing.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case billing.FieldCardholderName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardholderName(v)
		return nil
	case billing.FieldCardNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardNumber(v)
		return nil
	case billing.FieldExpiryMonth:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiryMonth(v)
		return nil
	case billing.FieldExpiryYear:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiryYear(v)
		return nil
	case billing.FieldCVV:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCVV(v)
		return nil
	}
	return fmt.Errorf("unknown Billing field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BillingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BillingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BillingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Billing numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BillingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BillingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BillingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Billing nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BillingMutation) ResetField(name string) error {
	switch name {
	case billing.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case billing.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case billing.FieldCardholderName:
		m.ResetCardholderName()
		return nil
	case billing.FieldCardNumber:
		m.ResetCardNumber()
		return nil
	case billing.FieldExpiryMonth:
		m.ResetExpiryMonth()
		return nil
	case billing.FieldExpiryYear:
		m.ResetExpiryYear()
		return nil
	case billing.FieldCVV:
		m.ResetCVV()
		return nil
	}
	return fmt.Errorf("unknown Billing field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BillingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Profile != nil {
		edges = append(edges, billing.EdgeProfile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BillingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case billing.EdgeProfile:
		ids := make([]ent.Value, 0, len(m._Profile))
		for id := range m._Profile {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BillingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Profile != nil {
		edges = append(edges, billing.EdgeProfile)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BillingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case billing.EdgeProfile:
		ids := make([]ent.Value, 0, len(m.removed_Profile))
		for id := range m.removed_Profile {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BillingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Profile {
		edges = append(edges, billing.EdgeProfile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BillingMutation) EdgeCleared(name string) bool {
	switch name {
	case billing.EdgeProfile:
		return m.cleared_Profile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BillingMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Billing unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BillingMutation) ResetEdge(name string) error {
	switch name {
	case billing.EdgeProfile:
		m.ResetProfile()
		return nil
	}
	return fmt.Errorf("unknown Billing edge %s", name)
}

// CalendarMutation represents an operation that mutates the Calendar nodes in the graph.
type CalendarMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	_ReleaseDate      *time.Time
	_ProductImage     *string
	_ProductName      *string
	_HypedRelease     *bool
	_UsersRunning     *int
	add_UsersRunning  *int
	clearedFields     map[string]struct{}
	_QuickTask        *uuid.UUID
	cleared_QuickTask bool
	done              bool
	oldValue          func(context.Context) (*Calendar, error)
	predicates        []predicate.Calendar
}

var _ ent.Mutation = (*CalendarMutation)(nil)

// calendarOption allows management of the mutation configuration using functional options.
type calendarOption func(*CalendarMutation)

// newCalendarMutation creates new mutation for the Calendar entity.
func newCalendarMutation(c config, op Op, opts ...calendarOption) *CalendarMutation {
	m := &CalendarMutation{
		config:        c,
		op:            op,
		typ:           TypeCalendar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCalendarID sets the ID field of the mutation.
func withCalendarID(id uuid.UUID) calendarOption {
	return func(m *CalendarMutation) {
		var (
			err   error
			once  sync.Once
			value *Calendar
		)
		m.oldValue = func(ctx context.Context) (*Calendar, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Calendar.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCalendar sets the old Calendar of the mutation.
func withCalendar(node *Calendar) calendarOption {
	return func(m *CalendarMutation) {
		m.oldValue = func(context.Context) (*Calendar, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CalendarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CalendarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Calendar entities.
func (m *CalendarMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CalendarMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *CalendarMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CalendarMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Calendar entity.
// If the Calendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CalendarMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CalendarMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CalendarMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CalendarMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Calendar entity.
// If the Calendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CalendarMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CalendarMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetReleaseDate sets the "ReleaseDate" field.
func (m *CalendarMutation) SetReleaseDate(t time.Time) {
	m._ReleaseDate = &t
}

// ReleaseDate returns the value of the "ReleaseDate" field in the mutation.
func (m *CalendarMutation) ReleaseDate() (r time.Time, exists bool) {
	v := m._ReleaseDate
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseDate returns the old "ReleaseDate" field's value of the Calendar entity.
// If the Calendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CalendarMutation) OldReleaseDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReleaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReleaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseDate: %w", err)
	}
	return oldValue.ReleaseDate, nil
}

// ResetReleaseDate resets all changes to the "ReleaseDate" field.
func (m *CalendarMutation) ResetReleaseDate() {
	m._ReleaseDate = nil
}

// SetProductImage sets the "ProductImage" field.
func (m *CalendarMutation) SetProductImage(s string) {
	m._ProductImage = &s
}

// ProductImage returns the value of the "ProductImage" field in the mutation.
func (m *CalendarMutation) ProductImage() (r string, exists bool) {
	v := m._ProductImage
	if v == nil {
		return
	}
	return *v, true
}

// OldProductImage returns the old "ProductImage" field's value of the Calendar entity.
// If the Calendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CalendarMutation) OldProductImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductImage: %w", err)
	}
	return oldValue.ProductImage, nil
}

// ResetProductImage resets all changes to the "ProductImage" field.
func (m *CalendarMutation) ResetProductImage() {
	m._ProductImage = nil
}

// SetProductName sets the "ProductName" field.
func (m *CalendarMutation) SetProductName(s string) {
	m._ProductName = &s
}

// ProductName returns the value of the "ProductName" field in the mutation.
func (m *CalendarMutation) ProductName() (r string, exists bool) {
	v := m._ProductName
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "ProductName" field's value of the Calendar entity.
// If the Calendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CalendarMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ResetProductName resets all changes to the "ProductName" field.
func (m *CalendarMutation) ResetProductName() {
	m._ProductName = nil
}

// SetHypedRelease sets the "HypedRelease" field.
func (m *CalendarMutation) SetHypedRelease(b bool) {
	m._HypedRelease = &b
}

// HypedRelease returns the value of the "HypedRelease" field in the mutation.
func (m *CalendarMutation) HypedRelease() (r bool, exists bool) {
	v := m._HypedRelease
	if v == nil {
		return
	}
	return *v, true
}

// OldHypedRelease returns the old "HypedRelease" field's value of the Calendar entity.
// If the Calendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CalendarMutation) OldHypedRelease(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHypedRelease is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHypedRelease requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHypedRelease: %w", err)
	}
	return oldValue.HypedRelease, nil
}

// ResetHypedRelease resets all changes to the "HypedRelease" field.
func (m *CalendarMutation) ResetHypedRelease() {
	m._HypedRelease = nil
}

// SetUsersRunning sets the "UsersRunning" field.
func (m *CalendarMutation) SetUsersRunning(i int) {
	m._UsersRunning = &i
	m.add_UsersRunning = nil
}

// UsersRunning returns the value of the "UsersRunning" field in the mutation.
func (m *CalendarMutation) UsersRunning() (r int, exists bool) {
	v := m._UsersRunning
	if v == nil {
		return
	}
	return *v, true
}

// OldUsersRunning returns the old "UsersRunning" field's value of the Calendar entity.
// If the Calendar object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CalendarMutation) OldUsersRunning(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsersRunning is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsersRunning requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsersRunning: %w", err)
	}
	return oldValue.UsersRunning, nil
}

// AddUsersRunning adds i to the "UsersRunning" field.
func (m *CalendarMutation) AddUsersRunning(i int) {
	if m.add_UsersRunning != nil {
		*m.add_UsersRunning += i
	} else {
		m.add_UsersRunning = &i
	}
}

// AddedUsersRunning returns the value that was added to the "UsersRunning" field in this mutation.
func (m *CalendarMutation) AddedUsersRunning() (r int, exists bool) {
	v := m.add_UsersRunning
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsersRunning resets all changes to the "UsersRunning" field.
func (m *CalendarMutation) ResetUsersRunning() {
	m._UsersRunning = nil
	m.add_UsersRunning = nil
}

// SetQuickTaskID sets the "QuickTask" edge to the Product entity by id.
func (m *CalendarMutation) SetQuickTaskID(id uuid.UUID) {
	m._QuickTask = &id
}

// ClearQuickTask clears the "QuickTask" edge to the Product entity.
func (m *CalendarMutation) ClearQuickTask() {
	m.cleared_QuickTask = true
}

// QuickTaskCleared reports if the "QuickTask" edge to the Product entity was cleared.
func (m *CalendarMutation) QuickTaskCleared() bool {
	return m.cleared_QuickTask
}

// QuickTaskID returns the "QuickTask" edge ID in the mutation.
func (m *CalendarMutation) QuickTaskID() (id uuid.UUID, exists bool) {
	if m._QuickTask != nil {
		return *m._QuickTask, true
	}
	return
}

// QuickTaskIDs returns the "QuickTask" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// QuickTaskID instead. It exists only for internal usage by the builders.
func (m *CalendarMutation) QuickTaskIDs() (ids []uuid.UUID) {
	if id := m._QuickTask; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetQuickTask resets all changes to the "QuickTask" edge.
func (m *CalendarMutation) ResetQuickTask() {
	m._QuickTask = nil
	m.cleared_QuickTask = false
}

// Where appends a list predicates to the CalendarMutation builder.
func (m *CalendarMutation) Where(ps ...predicate.Calendar) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CalendarMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Calendar).
func (m *CalendarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CalendarMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, calendar.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, calendar.FieldUpdatedAt)
	}
	if m._ReleaseDate != nil {
		fields = append(fields, calendar.FieldReleaseDate)
	}
	if m._ProductImage != nil {
		fields = append(fields, calendar.FieldProductImage)
	}
	if m._ProductName != nil {
		fields = append(fields, calendar.FieldProductName)
	}
	if m._HypedRelease != nil {
		fields = append(fields, calendar.FieldHypedRelease)
	}
	if m._UsersRunning != nil {
		fields = append(fields, calendar.FieldUsersRunning)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CalendarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case calendar.FieldCreatedAt:
		return m.CreatedAt()
	case calendar.FieldUpdatedAt:
		return m.UpdatedAt()
	case calendar.FieldReleaseDate:
		return m.ReleaseDate()
	case calendar.FieldProductImage:
		return m.ProductImage()
	case calendar.FieldProductName:
		return m.ProductName()
	case calendar.FieldHypedRelease:
		return m.HypedRelease()
	case calendar.FieldUsersRunning:
		return m.UsersRunning()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CalendarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case calendar.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case calendar.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case calendar.FieldReleaseDate:
		return m.OldReleaseDate(ctx)
	case calendar.FieldProductImage:
		return m.OldProductImage(ctx)
	case calendar.FieldProductName:
		return m.OldProductName(ctx)
	case calendar.FieldHypedRelease:
		return m.OldHypedRelease(ctx)
	case calendar.FieldUsersRunning:
		return m.OldUsersRunning(ctx)
	}
	return nil, fmt.Errorf("unknown Calendar field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CalendarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case calendar.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case calendar.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case calendar.FieldReleaseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseDate(v)
		return nil
	case calendar.FieldProductImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductImage(v)
		return nil
	case calendar.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case calendar.FieldHypedRelease:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHypedRelease(v)
		return nil
	case calendar.FieldUsersRunning:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsersRunning(v)
		return nil
	}
	return fmt.Errorf("unknown Calendar field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CalendarMutation) AddedFields() []string {
	var fields []string
	if m.add_UsersRunning != nil {
		fields = append(fields, calendar.FieldUsersRunning)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CalendarMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case calendar.FieldUsersRunning:
		return m.AddedUsersRunning()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CalendarMutation) AddField(name string, value ent.Value) error {
	switch name {
	case calendar.FieldUsersRunning:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsersRunning(v)
		return nil
	}
	return fmt.Errorf("unknown Calendar numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CalendarMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CalendarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CalendarMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Calendar nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CalendarMutation) ResetField(name string) error {
	switch name {
	case calendar.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case calendar.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case calendar.FieldReleaseDate:
		m.ResetReleaseDate()
		return nil
	case calendar.FieldProductImage:
		m.ResetProductImage()
		return nil
	case calendar.FieldProductName:
		m.ResetProductName()
		return nil
	case calendar.FieldHypedRelease:
		m.ResetHypedRelease()
		return nil
	case calendar.FieldUsersRunning:
		m.ResetUsersRunning()
		return nil
	}
	return fmt.Errorf("unknown Calendar field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CalendarMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._QuickTask != nil {
		edges = append(edges, calendar.EdgeQuickTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CalendarMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case calendar.EdgeQuickTask:
		if id := m._QuickTask; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CalendarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CalendarMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CalendarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_QuickTask {
		edges = append(edges, calendar.EdgeQuickTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CalendarMutation) EdgeCleared(name string) bool {
	switch name {
	case calendar.EdgeQuickTask:
		return m.cleared_QuickTask
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CalendarMutation) ClearEdge(name string) error {
	switch name {
	case calendar.EdgeQuickTask:
		m.ClearQuickTask()
		return nil
	}
	return fmt.Errorf("unknown Calendar unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CalendarMutation) ResetEdge(name string) error {
	switch name {
	case calendar.EdgeQuickTask:
		m.ResetQuickTask()
		return nil
	}
	return fmt.Errorf("unknown Calendar edge %s", name)
}

// DeviceMutation represents an operation that mutates the Device nodes in the graph.
type DeviceMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	gpuVendor     *string
	plugins       *[]string
	adevice       *sonic.Map
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Device, error)
	predicates    []predicate.Device
}

var _ ent.Mutation = (*DeviceMutation)(nil)

// deviceOption allows management of the mutation configuration using functional options.
type deviceOption func(*DeviceMutation)

// newDeviceMutation creates new mutation for the Device entity.
func newDeviceMutation(c config, op Op, opts ...deviceOption) *DeviceMutation {
	m := &DeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeviceID sets the ID field of the mutation.
func withDeviceID(id uuid.UUID) deviceOption {
	return func(m *DeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *Device
		)
		m.oldValue = func(ctx context.Context) (*Device, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Device.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDevice sets the old Device of the mutation.
func withDevice(node *Device) deviceOption {
	return func(m *DeviceMutation) {
		m.oldValue = func(context.Context) (*Device, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Device entities.
func (m *DeviceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeviceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGpuVendor sets the "gpuVendor" field.
func (m *DeviceMutation) SetGpuVendor(s string) {
	m.gpuVendor = &s
}

// GpuVendor returns the value of the "gpuVendor" field in the mutation.
func (m *DeviceMutation) GpuVendor() (r string, exists bool) {
	v := m.gpuVendor
	if v == nil {
		return
	}
	return *v, true
}

// OldGpuVendor returns the old "gpuVendor" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldGpuVendor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGpuVendor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGpuVendor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGpuVendor: %w", err)
	}
	return oldValue.GpuVendor, nil
}

// ResetGpuVendor resets all changes to the "gpuVendor" field.
func (m *DeviceMutation) ResetGpuVendor() {
	m.gpuVendor = nil
}

// SetPlugins sets the "plugins" field.
func (m *DeviceMutation) SetPlugins(s []string) {
	m.plugins = &s
}

// Plugins returns the value of the "plugins" field in the mutation.
func (m *DeviceMutation) Plugins() (r []string, exists bool) {
	v := m.plugins
	if v == nil {
		return
	}
	return *v, true
}

// OldPlugins returns the old "plugins" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldPlugins(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPlugins is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPlugins requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlugins: %w", err)
	}
	return oldValue.Plugins, nil
}

// ResetPlugins resets all changes to the "plugins" field.
func (m *DeviceMutation) ResetPlugins() {
	m.plugins = nil
}

// SetAdevice sets the "adevice" field.
func (m *DeviceMutation) SetAdevice(s sonic.Map) {
	m.adevice = &s
}

// Adevice returns the value of the "adevice" field in the mutation.
func (m *DeviceMutation) Adevice() (r sonic.Map, exists bool) {
	v := m.adevice
	if v == nil {
		return
	}
	return *v, true
}

// OldAdevice returns the old "adevice" field's value of the Device entity.
// If the Device object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeviceMutation) OldAdevice(ctx context.Context) (v *sonic.Map, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdevice: %w", err)
	}
	return oldValue.Adevice, nil
}

// ClearAdevice clears the value of the "adevice" field.
func (m *DeviceMutation) ClearAdevice() {
	m.adevice = nil
	m.clearedFields[device.FieldAdevice] = struct{}{}
}

// AdeviceCleared returns if the "adevice" field was cleared in this mutation.
func (m *DeviceMutation) AdeviceCleared() bool {
	_, ok := m.clearedFields[device.FieldAdevice]
	return ok
}

// ResetAdevice resets all changes to the "adevice" field.
func (m *DeviceMutation) ResetAdevice() {
	m.adevice = nil
	delete(m.clearedFields, device.FieldAdevice)
}

// Where appends a list predicates to the DeviceMutation builder.
func (m *DeviceMutation) Where(ps ...predicate.Device) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DeviceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Device).
func (m *DeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeviceMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.gpuVendor != nil {
		fields = append(fields, device.FieldGpuVendor)
	}
	if m.plugins != nil {
		fields = append(fields, device.FieldPlugins)
	}
	if m.adevice != nil {
		fields = append(fields, device.FieldAdevice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case device.FieldGpuVendor:
		return m.GpuVendor()
	case device.FieldPlugins:
		return m.Plugins()
	case device.FieldAdevice:
		return m.Adevice()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case device.FieldGpuVendor:
		return m.OldGpuVendor(ctx)
	case device.FieldPlugins:
		return m.OldPlugins(ctx)
	case device.FieldAdevice:
		return m.OldAdevice(ctx)
	}
	return nil, fmt.Errorf("unknown Device field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case device.FieldGpuVendor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGpuVendor(v)
		return nil
	case device.FieldPlugins:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlugins(v)
		return nil
	case device.FieldAdevice:
		v, ok := value.(sonic.Map)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdevice(v)
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeviceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeviceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Device numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(device.FieldAdevice) {
		fields = append(fields, device.FieldAdevice)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeviceMutation) ClearField(name string) error {
	switch name {
	case device.FieldAdevice:
		m.ClearAdevice()
		return nil
	}
	return fmt.Errorf("unknown Device nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeviceMutation) ResetField(name string) error {
	switch name {
	case device.FieldGpuVendor:
		m.ResetGpuVendor()
		return nil
	case device.FieldPlugins:
		m.ResetPlugins()
		return nil
	case device.FieldAdevice:
		m.ResetAdevice()
		return nil
	}
	return fmt.Errorf("unknown Device field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeviceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeviceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeviceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeviceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Device unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeviceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Device edge %s", name)
}

// LicenseMutation represents an operation that mutates the License nodes in the graph.
type LicenseMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	_Key              *string
	_HardwareID       *string
	_MobileHardwareID *string
	_Type             *license.Type
	clearedFields     map[string]struct{}
	_User             *uuid.UUID
	cleared_User      bool
	_Stripe           map[uuid.UUID]struct{}
	removed_Stripe    map[uuid.UUID]struct{}
	cleared_Stripe    bool
	done              bool
	oldValue          func(context.Context) (*License, error)
	predicates        []predicate.License
}

var _ ent.Mutation = (*LicenseMutation)(nil)

// licenseOption allows management of the mutation configuration using functional options.
type licenseOption func(*LicenseMutation)

// newLicenseMutation creates new mutation for the License entity.
func newLicenseMutation(c config, op Op, opts ...licenseOption) *LicenseMutation {
	m := &LicenseMutation{
		config:        c,
		op:            op,
		typ:           TypeLicense,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLicenseID sets the ID field of the mutation.
func withLicenseID(id uuid.UUID) licenseOption {
	return func(m *LicenseMutation) {
		var (
			err   error
			once  sync.Once
			value *License
		)
		m.oldValue = func(ctx context.Context) (*License, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().License.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLicense sets the old License of the mutation.
func withLicense(node *License) licenseOption {
	return func(m *LicenseMutation) {
		m.oldValue = func(context.Context) (*License, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LicenseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LicenseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of License entities.
func (m *LicenseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LicenseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *LicenseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LicenseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LicenseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LicenseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LicenseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LicenseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetKey sets the "Key" field.
func (m *LicenseMutation) SetKey(s string) {
	m._Key = &s
}

// Key returns the value of the "Key" field in the mutation.
func (m *LicenseMutation) Key() (r string, exists bool) {
	v := m._Key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "Key" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "Key" field.
func (m *LicenseMutation) ResetKey() {
	m._Key = nil
}

// SetHardwareID sets the "HardwareID" field.
func (m *LicenseMutation) SetHardwareID(s string) {
	m._HardwareID = &s
}

// HardwareID returns the value of the "HardwareID" field in the mutation.
func (m *LicenseMutation) HardwareID() (r string, exists bool) {
	v := m._HardwareID
	if v == nil {
		return
	}
	return *v, true
}

// OldHardwareID returns the old "HardwareID" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldHardwareID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHardwareID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHardwareID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHardwareID: %w", err)
	}
	return oldValue.HardwareID, nil
}

// ClearHardwareID clears the value of the "HardwareID" field.
func (m *LicenseMutation) ClearHardwareID() {
	m._HardwareID = nil
	m.clearedFields[license.FieldHardwareID] = struct{}{}
}

// HardwareIDCleared returns if the "HardwareID" field was cleared in this mutation.
func (m *LicenseMutation) HardwareIDCleared() bool {
	_, ok := m.clearedFields[license.FieldHardwareID]
	return ok
}

// ResetHardwareID resets all changes to the "HardwareID" field.
func (m *LicenseMutation) ResetHardwareID() {
	m._HardwareID = nil
	delete(m.clearedFields, license.FieldHardwareID)
}

// SetMobileHardwareID sets the "MobileHardwareID" field.
func (m *LicenseMutation) SetMobileHardwareID(s string) {
	m._MobileHardwareID = &s
}

// MobileHardwareID returns the value of the "MobileHardwareID" field in the mutation.
func (m *LicenseMutation) MobileHardwareID() (r string, exists bool) {
	v := m._MobileHardwareID
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileHardwareID returns the old "MobileHardwareID" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldMobileHardwareID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMobileHardwareID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMobileHardwareID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileHardwareID: %w", err)
	}
	return oldValue.MobileHardwareID, nil
}

// ClearMobileHardwareID clears the value of the "MobileHardwareID" field.
func (m *LicenseMutation) ClearMobileHardwareID() {
	m._MobileHardwareID = nil
	m.clearedFields[license.FieldMobileHardwareID] = struct{}{}
}

// MobileHardwareIDCleared returns if the "MobileHardwareID" field was cleared in this mutation.
func (m *LicenseMutation) MobileHardwareIDCleared() bool {
	_, ok := m.clearedFields[license.FieldMobileHardwareID]
	return ok
}

// ResetMobileHardwareID resets all changes to the "MobileHardwareID" field.
func (m *LicenseMutation) ResetMobileHardwareID() {
	m._MobileHardwareID = nil
	delete(m.clearedFields, license.FieldMobileHardwareID)
}

// SetType sets the "Type" field.
func (m *LicenseMutation) SetType(l license.Type) {
	m._Type = &l
}

// GetType returns the value of the "Type" field in the mutation.
func (m *LicenseMutation) GetType() (r license.Type, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the License entity.
// If the License object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LicenseMutation) OldType(ctx context.Context) (v license.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "Type" field.
func (m *LicenseMutation) ResetType() {
	m._Type = nil
}

// SetUserID sets the "User" edge to the User entity by id.
func (m *LicenseMutation) SetUserID(id uuid.UUID) {
	m._User = &id
}

// ClearUser clears the "User" edge to the User entity.
func (m *LicenseMutation) ClearUser() {
	m.cleared_User = true
}

// UserCleared reports if the "User" edge to the User entity was cleared.
func (m *LicenseMutation) UserCleared() bool {
	return m.cleared_User
}

// UserID returns the "User" edge ID in the mutation.
func (m *LicenseMutation) UserID() (id uuid.UUID, exists bool) {
	if m._User != nil {
		return *m._User, true
	}
	return
}

// UserIDs returns the "User" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *LicenseMutation) UserIDs() (ids []uuid.UUID) {
	if id := m._User; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "User" edge.
func (m *LicenseMutation) ResetUser() {
	m._User = nil
	m.cleared_User = false
}

// AddStripeIDs adds the "Stripe" edge to the Stripe entity by ids.
func (m *LicenseMutation) AddStripeIDs(ids ...uuid.UUID) {
	if m._Stripe == nil {
		m._Stripe = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Stripe[ids[i]] = struct{}{}
	}
}

// ClearStripe clears the "Stripe" edge to the Stripe entity.
func (m *LicenseMutation) ClearStripe() {
	m.cleared_Stripe = true
}

// StripeCleared reports if the "Stripe" edge to the Stripe entity was cleared.
func (m *LicenseMutation) StripeCleared() bool {
	return m.cleared_Stripe
}

// RemoveStripeIDs removes the "Stripe" edge to the Stripe entity by IDs.
func (m *LicenseMutation) RemoveStripeIDs(ids ...uuid.UUID) {
	if m.removed_Stripe == nil {
		m.removed_Stripe = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Stripe, ids[i])
		m.removed_Stripe[ids[i]] = struct{}{}
	}
}

// RemovedStripe returns the removed IDs of the "Stripe" edge to the Stripe entity.
func (m *LicenseMutation) RemovedStripeIDs() (ids []uuid.UUID) {
	for id := range m.removed_Stripe {
		ids = append(ids, id)
	}
	return
}

// StripeIDs returns the "Stripe" edge IDs in the mutation.
func (m *LicenseMutation) StripeIDs() (ids []uuid.UUID) {
	for id := range m._Stripe {
		ids = append(ids, id)
	}
	return
}

// ResetStripe resets all changes to the "Stripe" edge.
func (m *LicenseMutation) ResetStripe() {
	m._Stripe = nil
	m.cleared_Stripe = false
	m.removed_Stripe = nil
}

// Where appends a list predicates to the LicenseMutation builder.
func (m *LicenseMutation) Where(ps ...predicate.License) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LicenseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (License).
func (m *LicenseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LicenseMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, license.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, license.FieldUpdatedAt)
	}
	if m._Key != nil {
		fields = append(fields, license.FieldKey)
	}
	if m._HardwareID != nil {
		fields = append(fields, license.FieldHardwareID)
	}
	if m._MobileHardwareID != nil {
		fields = append(fields, license.FieldMobileHardwareID)
	}
	if m._Type != nil {
		fields = append(fields, license.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LicenseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case license.FieldCreatedAt:
		return m.CreatedAt()
	case license.FieldUpdatedAt:
		return m.UpdatedAt()
	case license.FieldKey:
		return m.Key()
	case license.FieldHardwareID:
		return m.HardwareID()
	case license.FieldMobileHardwareID:
		return m.MobileHardwareID()
	case license.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LicenseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case license.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case license.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case license.FieldKey:
		return m.OldKey(ctx)
	case license.FieldHardwareID:
		return m.OldHardwareID(ctx)
	case license.FieldMobileHardwareID:
		return m.OldMobileHardwareID(ctx)
	case license.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown License field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case license.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case license.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case license.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case license.FieldHardwareID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHardwareID(v)
		return nil
	case license.FieldMobileHardwareID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileHardwareID(v)
		return nil
	case license.FieldType:
		v, ok := value.(license.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LicenseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LicenseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LicenseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown License numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LicenseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(license.FieldHardwareID) {
		fields = append(fields, license.FieldHardwareID)
	}
	if m.FieldCleared(license.FieldMobileHardwareID) {
		fields = append(fields, license.FieldMobileHardwareID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LicenseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LicenseMutation) ClearField(name string) error {
	switch name {
	case license.FieldHardwareID:
		m.ClearHardwareID()
		return nil
	case license.FieldMobileHardwareID:
		m.ClearMobileHardwareID()
		return nil
	}
	return fmt.Errorf("unknown License nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LicenseMutation) ResetField(name string) error {
	switch name {
	case license.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case license.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case license.FieldKey:
		m.ResetKey()
		return nil
	case license.FieldHardwareID:
		m.ResetHardwareID()
		return nil
	case license.FieldMobileHardwareID:
		m.ResetMobileHardwareID()
		return nil
	case license.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown License field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LicenseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._User != nil {
		edges = append(edges, license.EdgeUser)
	}
	if m._Stripe != nil {
		edges = append(edges, license.EdgeStripe)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LicenseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case license.EdgeUser:
		if id := m._User; id != nil {
			return []ent.Value{*id}
		}
	case license.EdgeStripe:
		ids := make([]ent.Value, 0, len(m._Stripe))
		for id := range m._Stripe {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LicenseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_Stripe != nil {
		edges = append(edges, license.EdgeStripe)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LicenseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case license.EdgeStripe:
		ids := make([]ent.Value, 0, len(m.removed_Stripe))
		for id := range m.removed_Stripe {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LicenseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_User {
		edges = append(edges, license.EdgeUser)
	}
	if m.cleared_Stripe {
		edges = append(edges, license.EdgeStripe)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LicenseMutation) EdgeCleared(name string) bool {
	switch name {
	case license.EdgeUser:
		return m.cleared_User
	case license.EdgeStripe:
		return m.cleared_Stripe
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LicenseMutation) ClearEdge(name string) error {
	switch name {
	case license.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown License unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LicenseMutation) ResetEdge(name string) error {
	switch name {
	case license.EdgeUser:
		m.ResetUser()
		return nil
	case license.EdgeStripe:
		m.ResetStripe()
		return nil
	}
	return fmt.Errorf("unknown License edge %s", name)
}

// MetadataMutation represents an operation that mutates the Metadata nodes in the graph.
type MetadataMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	_FirstLogin           *bool
	_FirstLoginMobile     *bool
	_Theme                *metadata.Theme
	_DiscordID            *string
	_DiscordAccessToken   *string
	_DiscordRefreshToken  *string
	_DiscordUsername      *string
	_DiscordAvatar        *string
	_DiscordDiscriminator *string
	_DiscordExpiryTime    *time.Time
	clearedFields         map[string]struct{}
	user                  *uuid.UUID
	cleareduser           bool
	done                  bool
	oldValue              func(context.Context) (*Metadata, error)
	predicates            []predicate.Metadata
}

var _ ent.Mutation = (*MetadataMutation)(nil)

// metadataOption allows management of the mutation configuration using functional options.
type metadataOption func(*MetadataMutation)

// newMetadataMutation creates new mutation for the Metadata entity.
func newMetadataMutation(c config, op Op, opts ...metadataOption) *MetadataMutation {
	m := &MetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetadataID sets the ID field of the mutation.
func withMetadataID(id uuid.UUID) metadataOption {
	return func(m *MetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *Metadata
		)
		m.oldValue = func(ctx context.Context) (*Metadata, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Metadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMetadata sets the old Metadata of the mutation.
func withMetadata(node *Metadata) metadataOption {
	return func(m *MetadataMutation) {
		m.oldValue = func(context.Context) (*Metadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Metadata entities.
func (m *MetadataMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetadataMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *MetadataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MetadataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MetadataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MetadataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MetadataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MetadataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFirstLogin sets the "FirstLogin" field.
func (m *MetadataMutation) SetFirstLogin(b bool) {
	m._FirstLogin = &b
}

// FirstLogin returns the value of the "FirstLogin" field in the mutation.
func (m *MetadataMutation) FirstLogin() (r bool, exists bool) {
	v := m._FirstLogin
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstLogin returns the old "FirstLogin" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldFirstLogin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstLogin: %w", err)
	}
	return oldValue.FirstLogin, nil
}

// ResetFirstLogin resets all changes to the "FirstLogin" field.
func (m *MetadataMutation) ResetFirstLogin() {
	m._FirstLogin = nil
}

// SetFirstLoginMobile sets the "FirstLoginMobile" field.
func (m *MetadataMutation) SetFirstLoginMobile(b bool) {
	m._FirstLoginMobile = &b
}

// FirstLoginMobile returns the value of the "FirstLoginMobile" field in the mutation.
func (m *MetadataMutation) FirstLoginMobile() (r bool, exists bool) {
	v := m._FirstLoginMobile
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstLoginMobile returns the old "FirstLoginMobile" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldFirstLoginMobile(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstLoginMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstLoginMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstLoginMobile: %w", err)
	}
	return oldValue.FirstLoginMobile, nil
}

// ResetFirstLoginMobile resets all changes to the "FirstLoginMobile" field.
func (m *MetadataMutation) ResetFirstLoginMobile() {
	m._FirstLoginMobile = nil
}

// SetTheme sets the "Theme" field.
func (m *MetadataMutation) SetTheme(value metadata.Theme) {
	m._Theme = &value
}

// Theme returns the value of the "Theme" field in the mutation.
func (m *MetadataMutation) Theme() (r metadata.Theme, exists bool) {
	v := m._Theme
	if v == nil {
		return
	}
	return *v, true
}

// OldTheme returns the old "Theme" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldTheme(ctx context.Context) (v metadata.Theme, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTheme is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTheme requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTheme: %w", err)
	}
	return oldValue.Theme, nil
}

// ResetTheme resets all changes to the "Theme" field.
func (m *MetadataMutation) ResetTheme() {
	m._Theme = nil
}

// SetDiscordID sets the "DiscordID" field.
func (m *MetadataMutation) SetDiscordID(s string) {
	m._DiscordID = &s
}

// DiscordID returns the value of the "DiscordID" field in the mutation.
func (m *MetadataMutation) DiscordID() (r string, exists bool) {
	v := m._DiscordID
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscordID returns the old "DiscordID" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldDiscordID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiscordID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiscordID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscordID: %w", err)
	}
	return oldValue.DiscordID, nil
}

// ResetDiscordID resets all changes to the "DiscordID" field.
func (m *MetadataMutation) ResetDiscordID() {
	m._DiscordID = nil
}

// SetDiscordAccessToken sets the "DiscordAccessToken" field.
func (m *MetadataMutation) SetDiscordAccessToken(s string) {
	m._DiscordAccessToken = &s
}

// DiscordAccessToken returns the value of the "DiscordAccessToken" field in the mutation.
func (m *MetadataMutation) DiscordAccessToken() (r string, exists bool) {
	v := m._DiscordAccessToken
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscordAccessToken returns the old "DiscordAccessToken" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldDiscordAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiscordAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiscordAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscordAccessToken: %w", err)
	}
	return oldValue.DiscordAccessToken, nil
}

// ResetDiscordAccessToken resets all changes to the "DiscordAccessToken" field.
func (m *MetadataMutation) ResetDiscordAccessToken() {
	m._DiscordAccessToken = nil
}

// SetDiscordRefreshToken sets the "DiscordRefreshToken" field.
func (m *MetadataMutation) SetDiscordRefreshToken(s string) {
	m._DiscordRefreshToken = &s
}

// DiscordRefreshToken returns the value of the "DiscordRefreshToken" field in the mutation.
func (m *MetadataMutation) DiscordRefreshToken() (r string, exists bool) {
	v := m._DiscordRefreshToken
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscordRefreshToken returns the old "DiscordRefreshToken" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldDiscordRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiscordRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiscordRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscordRefreshToken: %w", err)
	}
	return oldValue.DiscordRefreshToken, nil
}

// ResetDiscordRefreshToken resets all changes to the "DiscordRefreshToken" field.
func (m *MetadataMutation) ResetDiscordRefreshToken() {
	m._DiscordRefreshToken = nil
}

// SetDiscordUsername sets the "DiscordUsername" field.
func (m *MetadataMutation) SetDiscordUsername(s string) {
	m._DiscordUsername = &s
}

// DiscordUsername returns the value of the "DiscordUsername" field in the mutation.
func (m *MetadataMutation) DiscordUsername() (r string, exists bool) {
	v := m._DiscordUsername
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscordUsername returns the old "DiscordUsername" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldDiscordUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiscordUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiscordUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscordUsername: %w", err)
	}
	return oldValue.DiscordUsername, nil
}

// ResetDiscordUsername resets all changes to the "DiscordUsername" field.
func (m *MetadataMutation) ResetDiscordUsername() {
	m._DiscordUsername = nil
}

// SetDiscordAvatar sets the "DiscordAvatar" field.
func (m *MetadataMutation) SetDiscordAvatar(s string) {
	m._DiscordAvatar = &s
}

// DiscordAvatar returns the value of the "DiscordAvatar" field in the mutation.
func (m *MetadataMutation) DiscordAvatar() (r string, exists bool) {
	v := m._DiscordAvatar
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscordAvatar returns the old "DiscordAvatar" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldDiscordAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiscordAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiscordAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscordAvatar: %w", err)
	}
	return oldValue.DiscordAvatar, nil
}

// ResetDiscordAvatar resets all changes to the "DiscordAvatar" field.
func (m *MetadataMutation) ResetDiscordAvatar() {
	m._DiscordAvatar = nil
}

// SetDiscordDiscriminator sets the "DiscordDiscriminator" field.
func (m *MetadataMutation) SetDiscordDiscriminator(s string) {
	m._DiscordDiscriminator = &s
}

// DiscordDiscriminator returns the value of the "DiscordDiscriminator" field in the mutation.
func (m *MetadataMutation) DiscordDiscriminator() (r string, exists bool) {
	v := m._DiscordDiscriminator
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscordDiscriminator returns the old "DiscordDiscriminator" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldDiscordDiscriminator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiscordDiscriminator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiscordDiscriminator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscordDiscriminator: %w", err)
	}
	return oldValue.DiscordDiscriminator, nil
}

// ResetDiscordDiscriminator resets all changes to the "DiscordDiscriminator" field.
func (m *MetadataMutation) ResetDiscordDiscriminator() {
	m._DiscordDiscriminator = nil
}

// SetDiscordExpiryTime sets the "DiscordExpiryTime" field.
func (m *MetadataMutation) SetDiscordExpiryTime(t time.Time) {
	m._DiscordExpiryTime = &t
}

// DiscordExpiryTime returns the value of the "DiscordExpiryTime" field in the mutation.
func (m *MetadataMutation) DiscordExpiryTime() (r time.Time, exists bool) {
	v := m._DiscordExpiryTime
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscordExpiryTime returns the old "DiscordExpiryTime" field's value of the Metadata entity.
// If the Metadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetadataMutation) OldDiscordExpiryTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiscordExpiryTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiscordExpiryTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscordExpiryTime: %w", err)
	}
	return oldValue.DiscordExpiryTime, nil
}

// ResetDiscordExpiryTime resets all changes to the "DiscordExpiryTime" field.
func (m *MetadataMutation) ResetDiscordExpiryTime() {
	m._DiscordExpiryTime = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *MetadataMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *MetadataMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MetadataMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *MetadataMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MetadataMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MetadataMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the MetadataMutation builder.
func (m *MetadataMutation) Where(ps ...predicate.Metadata) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MetadataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Metadata).
func (m *MetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetadataMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, metadata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, metadata.FieldUpdatedAt)
	}
	if m._FirstLogin != nil {
		fields = append(fields, metadata.FieldFirstLogin)
	}
	if m._FirstLoginMobile != nil {
		fields = append(fields, metadata.FieldFirstLoginMobile)
	}
	if m._Theme != nil {
		fields = append(fields, metadata.FieldTheme)
	}
	if m._DiscordID != nil {
		fields = append(fields, metadata.FieldDiscordID)
	}
	if m._DiscordAccessToken != nil {
		fields = append(fields, metadata.FieldDiscordAccessToken)
	}
	if m._DiscordRefreshToken != nil {
		fields = append(fields, metadata.FieldDiscordRefreshToken)
	}
	if m._DiscordUsername != nil {
		fields = append(fields, metadata.FieldDiscordUsername)
	}
	if m._DiscordAvatar != nil {
		fields = append(fields, metadata.FieldDiscordAvatar)
	}
	if m._DiscordDiscriminator != nil {
		fields = append(fields, metadata.FieldDiscordDiscriminator)
	}
	if m._DiscordExpiryTime != nil {
		fields = append(fields, metadata.FieldDiscordExpiryTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case metadata.FieldCreatedAt:
		return m.CreatedAt()
	case metadata.FieldUpdatedAt:
		return m.UpdatedAt()
	case metadata.FieldFirstLogin:
		return m.FirstLogin()
	case metadata.FieldFirstLoginMobile:
		return m.FirstLoginMobile()
	case metadata.FieldTheme:
		return m.Theme()
	case metadata.FieldDiscordID:
		return m.DiscordID()
	case metadata.FieldDiscordAccessToken:
		return m.DiscordAccessToken()
	case metadata.FieldDiscordRefreshToken:
		return m.DiscordRefreshToken()
	case metadata.FieldDiscordUsername:
		return m.DiscordUsername()
	case metadata.FieldDiscordAvatar:
		return m.DiscordAvatar()
	case metadata.FieldDiscordDiscriminator:
		return m.DiscordDiscriminator()
	case metadata.FieldDiscordExpiryTime:
		return m.DiscordExpiryTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case metadata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case metadata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case metadata.FieldFirstLogin:
		return m.OldFirstLogin(ctx)
	case metadata.FieldFirstLoginMobile:
		return m.OldFirstLoginMobile(ctx)
	case metadata.FieldTheme:
		return m.OldTheme(ctx)
	case metadata.FieldDiscordID:
		return m.OldDiscordID(ctx)
	case metadata.FieldDiscordAccessToken:
		return m.OldDiscordAccessToken(ctx)
	case metadata.FieldDiscordRefreshToken:
		return m.OldDiscordRefreshToken(ctx)
	case metadata.FieldDiscordUsername:
		return m.OldDiscordUsername(ctx)
	case metadata.FieldDiscordAvatar:
		return m.OldDiscordAvatar(ctx)
	case metadata.FieldDiscordDiscriminator:
		return m.OldDiscordDiscriminator(ctx)
	case metadata.FieldDiscordExpiryTime:
		return m.OldDiscordExpiryTime(ctx)
	}
	return nil, fmt.Errorf("unknown Metadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case metadata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case metadata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case metadata.FieldFirstLogin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstLogin(v)
		return nil
	case metadata.FieldFirstLoginMobile:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstLoginMobile(v)
		return nil
	case metadata.FieldTheme:
		v, ok := value.(metadata.Theme)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTheme(v)
		return nil
	case metadata.FieldDiscordID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscordID(v)
		return nil
	case metadata.FieldDiscordAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscordAccessToken(v)
		return nil
	case metadata.FieldDiscordRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscordRefreshToken(v)
		return nil
	case metadata.FieldDiscordUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscordUsername(v)
		return nil
	case metadata.FieldDiscordAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscordAvatar(v)
		return nil
	case metadata.FieldDiscordDiscriminator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscordDiscriminator(v)
		return nil
	case metadata.FieldDiscordExpiryTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscordExpiryTime(v)
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetadataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetadataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Metadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetadataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetadataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Metadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetadataMutation) ResetField(name string) error {
	switch name {
	case metadata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case metadata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case metadata.FieldFirstLogin:
		m.ResetFirstLogin()
		return nil
	case metadata.FieldFirstLoginMobile:
		m.ResetFirstLoginMobile()
		return nil
	case metadata.FieldTheme:
		m.ResetTheme()
		return nil
	case metadata.FieldDiscordID:
		m.ResetDiscordID()
		return nil
	case metadata.FieldDiscordAccessToken:
		m.ResetDiscordAccessToken()
		return nil
	case metadata.FieldDiscordRefreshToken:
		m.ResetDiscordRefreshToken()
		return nil
	case metadata.FieldDiscordUsername:
		m.ResetDiscordUsername()
		return nil
	case metadata.FieldDiscordAvatar:
		m.ResetDiscordAvatar()
		return nil
	case metadata.FieldDiscordDiscriminator:
		m.ResetDiscordDiscriminator()
		return nil
	case metadata.FieldDiscordExpiryTime:
		m.ResetDiscordExpiryTime()
		return nil
	}
	return fmt.Errorf("unknown Metadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, metadata.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetadataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case metadata.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetadataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, metadata.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetadataMutation) EdgeCleared(name string) bool {
	switch name {
	case metadata.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetadataMutation) ClearEdge(name string) error {
	switch name {
	case metadata.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Metadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetadataMutation) ResetEdge(name string) error {
	switch name {
	case metadata.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Metadata edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	_Name             *string
	_Image            *string
	_LookupType       *product.LookupType
	_PositiveKeywords *[]string
	_NegativeKeywords *[]string
	_Link             *string
	_Quantity         *int32
	add_Quantity      *int32
	_Sizes            *[]string
	_Colors           *[]string
	_Site             *product.Site
	_Metadata         *sonic.Map
	clearedFields     map[string]struct{}
	_Task             map[uuid.UUID]struct{}
	removed_Task      map[uuid.UUID]struct{}
	cleared_Task      bool
	_Statistic        map[uuid.UUID]struct{}
	removed_Statistic map[uuid.UUID]struct{}
	cleared_Statistic bool
	_Calendar         *uuid.UUID
	cleared_Calendar  bool
	done              bool
	oldValue          func(context.Context) (*Product, error)
	predicates        []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id uuid.UUID) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Product entities.
func (m *ProductMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "Name" field.
func (m *ProductMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *ProductMutation) ResetName() {
	m._Name = nil
}

// SetImage sets the "Image" field.
func (m *ProductMutation) SetImage(s string) {
	m._Image = &s
}

// Image returns the value of the "Image" field in the mutation.
func (m *ProductMutation) Image() (r string, exists bool) {
	v := m._Image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "Image" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ClearImage clears the value of the "Image" field.
func (m *ProductMutation) ClearImage() {
	m._Image = nil
	m.clearedFields[product.FieldImage] = struct{}{}
}

// ImageCleared returns if the "Image" field was cleared in this mutation.
func (m *ProductMutation) ImageCleared() bool {
	_, ok := m.clearedFields[product.FieldImage]
	return ok
}

// ResetImage resets all changes to the "Image" field.
func (m *ProductMutation) ResetImage() {
	m._Image = nil
	delete(m.clearedFields, product.FieldImage)
}

// SetLookupType sets the "LookupType" field.
func (m *ProductMutation) SetLookupType(pt product.LookupType) {
	m._LookupType = &pt
}

// LookupType returns the value of the "LookupType" field in the mutation.
func (m *ProductMutation) LookupType() (r product.LookupType, exists bool) {
	v := m._LookupType
	if v == nil {
		return
	}
	return *v, true
}

// OldLookupType returns the old "LookupType" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldLookupType(ctx context.Context) (v product.LookupType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLookupType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLookupType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLookupType: %w", err)
	}
	return oldValue.LookupType, nil
}

// ResetLookupType resets all changes to the "LookupType" field.
func (m *ProductMutation) ResetLookupType() {
	m._LookupType = nil
}

// SetPositiveKeywords sets the "PositiveKeywords" field.
func (m *ProductMutation) SetPositiveKeywords(s []string) {
	m._PositiveKeywords = &s
}

// PositiveKeywords returns the value of the "PositiveKeywords" field in the mutation.
func (m *ProductMutation) PositiveKeywords() (r []string, exists bool) {
	v := m._PositiveKeywords
	if v == nil {
		return
	}
	return *v, true
}

// OldPositiveKeywords returns the old "PositiveKeywords" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPositiveKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPositiveKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPositiveKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositiveKeywords: %w", err)
	}
	return oldValue.PositiveKeywords, nil
}

// ClearPositiveKeywords clears the value of the "PositiveKeywords" field.
func (m *ProductMutation) ClearPositiveKeywords() {
	m._PositiveKeywords = nil
	m.clearedFields[product.FieldPositiveKeywords] = struct{}{}
}

// PositiveKeywordsCleared returns if the "PositiveKeywords" field was cleared in this mutation.
func (m *ProductMutation) PositiveKeywordsCleared() bool {
	_, ok := m.clearedFields[product.FieldPositiveKeywords]
	return ok
}

// ResetPositiveKeywords resets all changes to the "PositiveKeywords" field.
func (m *ProductMutation) ResetPositiveKeywords() {
	m._PositiveKeywords = nil
	delete(m.clearedFields, product.FieldPositiveKeywords)
}

// SetNegativeKeywords sets the "NegativeKeywords" field.
func (m *ProductMutation) SetNegativeKeywords(s []string) {
	m._NegativeKeywords = &s
}

// NegativeKeywords returns the value of the "NegativeKeywords" field in the mutation.
func (m *ProductMutation) NegativeKeywords() (r []string, exists bool) {
	v := m._NegativeKeywords
	if v == nil {
		return
	}
	return *v, true
}

// OldNegativeKeywords returns the old "NegativeKeywords" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldNegativeKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNegativeKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNegativeKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNegativeKeywords: %w", err)
	}
	return oldValue.NegativeKeywords, nil
}

// ClearNegativeKeywords clears the value of the "NegativeKeywords" field.
func (m *ProductMutation) ClearNegativeKeywords() {
	m._NegativeKeywords = nil
	m.clearedFields[product.FieldNegativeKeywords] = struct{}{}
}

// NegativeKeywordsCleared returns if the "NegativeKeywords" field was cleared in this mutation.
func (m *ProductMutation) NegativeKeywordsCleared() bool {
	_, ok := m.clearedFields[product.FieldNegativeKeywords]
	return ok
}

// ResetNegativeKeywords resets all changes to the "NegativeKeywords" field.
func (m *ProductMutation) ResetNegativeKeywords() {
	m._NegativeKeywords = nil
	delete(m.clearedFields, product.FieldNegativeKeywords)
}

// SetLink sets the "Link" field.
func (m *ProductMutation) SetLink(s string) {
	m._Link = &s
}

// Link returns the value of the "Link" field in the mutation.
func (m *ProductMutation) Link() (r string, exists bool) {
	v := m._Link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "Link" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "Link" field.
func (m *ProductMutation) ClearLink() {
	m._Link = nil
	m.clearedFields[product.FieldLink] = struct{}{}
}

// LinkCleared returns if the "Link" field was cleared in this mutation.
func (m *ProductMutation) LinkCleared() bool {
	_, ok := m.clearedFields[product.FieldLink]
	return ok
}

// ResetLink resets all changes to the "Link" field.
func (m *ProductMutation) ResetLink() {
	m._Link = nil
	delete(m.clearedFields, product.FieldLink)
}

// SetQuantity sets the "Quantity" field.
func (m *ProductMutation) SetQuantity(i int32) {
	m._Quantity = &i
	m.add_Quantity = nil
}

// Quantity returns the value of the "Quantity" field in the mutation.
func (m *ProductMutation) Quantity() (r int32, exists bool) {
	v := m._Quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "Quantity" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldQuantity(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "Quantity" field.
func (m *ProductMutation) AddQuantity(i int32) {
	if m.add_Quantity != nil {
		*m.add_Quantity += i
	} else {
		m.add_Quantity = &i
	}
}

// AddedQuantity returns the value that was added to the "Quantity" field in this mutation.
func (m *ProductMutation) AddedQuantity() (r int32, exists bool) {
	v := m.add_Quantity
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuantity resets all changes to the "Quantity" field.
func (m *ProductMutation) ResetQuantity() {
	m._Quantity = nil
	m.add_Quantity = nil
}

// SetSizes sets the "Sizes" field.
func (m *ProductMutation) SetSizes(s []string) {
	m._Sizes = &s
}

// Sizes returns the value of the "Sizes" field in the mutation.
func (m *ProductMutation) Sizes() (r []string, exists bool) {
	v := m._Sizes
	if v == nil {
		return
	}
	return *v, true
}

// OldSizes returns the old "Sizes" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSizes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSizes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSizes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizes: %w", err)
	}
	return oldValue.Sizes, nil
}

// ClearSizes clears the value of the "Sizes" field.
func (m *ProductMutation) ClearSizes() {
	m._Sizes = nil
	m.clearedFields[product.FieldSizes] = struct{}{}
}

// SizesCleared returns if the "Sizes" field was cleared in this mutation.
func (m *ProductMutation) SizesCleared() bool {
	_, ok := m.clearedFields[product.FieldSizes]
	return ok
}

// ResetSizes resets all changes to the "Sizes" field.
func (m *ProductMutation) ResetSizes() {
	m._Sizes = nil
	delete(m.clearedFields, product.FieldSizes)
}

// SetColors sets the "Colors" field.
func (m *ProductMutation) SetColors(s []string) {
	m._Colors = &s
}

// Colors returns the value of the "Colors" field in the mutation.
func (m *ProductMutation) Colors() (r []string, exists bool) {
	v := m._Colors
	if v == nil {
		return
	}
	return *v, true
}

// OldColors returns the old "Colors" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldColors(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldColors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldColors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColors: %w", err)
	}
	return oldValue.Colors, nil
}

// ClearColors clears the value of the "Colors" field.
func (m *ProductMutation) ClearColors() {
	m._Colors = nil
	m.clearedFields[product.FieldColors] = struct{}{}
}

// ColorsCleared returns if the "Colors" field was cleared in this mutation.
func (m *ProductMutation) ColorsCleared() bool {
	_, ok := m.clearedFields[product.FieldColors]
	return ok
}

// ResetColors resets all changes to the "Colors" field.
func (m *ProductMutation) ResetColors() {
	m._Colors = nil
	delete(m.clearedFields, product.FieldColors)
}

// SetSite sets the "Site" field.
func (m *ProductMutation) SetSite(pr product.Site) {
	m._Site = &pr
}

// Site returns the value of the "Site" field in the mutation.
func (m *ProductMutation) Site() (r product.Site, exists bool) {
	v := m._Site
	if v == nil {
		return
	}
	return *v, true
}

// OldSite returns the old "Site" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSite(ctx context.Context) (v product.Site, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSite: %w", err)
	}
	return oldValue.Site, nil
}

// ResetSite resets all changes to the "Site" field.
func (m *ProductMutation) ResetSite() {
	m._Site = nil
}

// SetMetadata sets the "Metadata" field.
func (m *ProductMutation) SetMetadata(s sonic.Map) {
	m._Metadata = &s
}

// Metadata returns the value of the "Metadata" field in the mutation.
func (m *ProductMutation) Metadata() (r sonic.Map, exists bool) {
	v := m._Metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "Metadata" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMetadata(ctx context.Context) (v sonic.Map, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "Metadata" field.
func (m *ProductMutation) ClearMetadata() {
	m._Metadata = nil
	m.clearedFields[product.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "Metadata" field was cleared in this mutation.
func (m *ProductMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[product.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "Metadata" field.
func (m *ProductMutation) ResetMetadata() {
	m._Metadata = nil
	delete(m.clearedFields, product.FieldMetadata)
}

// AddTaskIDs adds the "Task" edge to the Task entity by ids.
func (m *ProductMutation) AddTaskIDs(ids ...uuid.UUID) {
	if m._Task == nil {
		m._Task = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Task[ids[i]] = struct{}{}
	}
}

// ClearTask clears the "Task" edge to the Task entity.
func (m *ProductMutation) ClearTask() {
	m.cleared_Task = true
}

// TaskCleared reports if the "Task" edge to the Task entity was cleared.
func (m *ProductMutation) TaskCleared() bool {
	return m.cleared_Task
}

// RemoveTaskIDs removes the "Task" edge to the Task entity by IDs.
func (m *ProductMutation) RemoveTaskIDs(ids ...uuid.UUID) {
	if m.removed_Task == nil {
		m.removed_Task = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Task, ids[i])
		m.removed_Task[ids[i]] = struct{}{}
	}
}

// RemovedTask returns the removed IDs of the "Task" edge to the Task entity.
func (m *ProductMutation) RemovedTaskIDs() (ids []uuid.UUID) {
	for id := range m.removed_Task {
		ids = append(ids, id)
	}
	return
}

// TaskIDs returns the "Task" edge IDs in the mutation.
func (m *ProductMutation) TaskIDs() (ids []uuid.UUID) {
	for id := range m._Task {
		ids = append(ids, id)
	}
	return
}

// ResetTask resets all changes to the "Task" edge.
func (m *ProductMutation) ResetTask() {
	m._Task = nil
	m.cleared_Task = false
	m.removed_Task = nil
}

// AddStatisticIDs adds the "Statistic" edge to the Statistic entity by ids.
func (m *ProductMutation) AddStatisticIDs(ids ...uuid.UUID) {
	if m._Statistic == nil {
		m._Statistic = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Statistic[ids[i]] = struct{}{}
	}
}

// ClearStatistic clears the "Statistic" edge to the Statistic entity.
func (m *ProductMutation) ClearStatistic() {
	m.cleared_Statistic = true
}

// StatisticCleared reports if the "Statistic" edge to the Statistic entity was cleared.
func (m *ProductMutation) StatisticCleared() bool {
	return m.cleared_Statistic
}

// RemoveStatisticIDs removes the "Statistic" edge to the Statistic entity by IDs.
func (m *ProductMutation) RemoveStatisticIDs(ids ...uuid.UUID) {
	if m.removed_Statistic == nil {
		m.removed_Statistic = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Statistic, ids[i])
		m.removed_Statistic[ids[i]] = struct{}{}
	}
}

// RemovedStatistic returns the removed IDs of the "Statistic" edge to the Statistic entity.
func (m *ProductMutation) RemovedStatisticIDs() (ids []uuid.UUID) {
	for id := range m.removed_Statistic {
		ids = append(ids, id)
	}
	return
}

// StatisticIDs returns the "Statistic" edge IDs in the mutation.
func (m *ProductMutation) StatisticIDs() (ids []uuid.UUID) {
	for id := range m._Statistic {
		ids = append(ids, id)
	}
	return
}

// ResetStatistic resets all changes to the "Statistic" edge.
func (m *ProductMutation) ResetStatistic() {
	m._Statistic = nil
	m.cleared_Statistic = false
	m.removed_Statistic = nil
}

// SetCalendarID sets the "Calendar" edge to the Calendar entity by id.
func (m *ProductMutation) SetCalendarID(id uuid.UUID) {
	m._Calendar = &id
}

// ClearCalendar clears the "Calendar" edge to the Calendar entity.
func (m *ProductMutation) ClearCalendar() {
	m.cleared_Calendar = true
}

// CalendarCleared reports if the "Calendar" edge to the Calendar entity was cleared.
func (m *ProductMutation) CalendarCleared() bool {
	return m.cleared_Calendar
}

// CalendarID returns the "Calendar" edge ID in the mutation.
func (m *ProductMutation) CalendarID() (id uuid.UUID, exists bool) {
	if m._Calendar != nil {
		return *m._Calendar, true
	}
	return
}

// CalendarIDs returns the "Calendar" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CalendarID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) CalendarIDs() (ids []uuid.UUID) {
	if id := m._Calendar; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCalendar resets all changes to the "Calendar" edge.
func (m *ProductMutation) ResetCalendar() {
	m._Calendar = nil
	m.cleared_Calendar = false
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m._Name != nil {
		fields = append(fields, product.FieldName)
	}
	if m._Image != nil {
		fields = append(fields, product.FieldImage)
	}
	if m._LookupType != nil {
		fields = append(fields, product.FieldLookupType)
	}
	if m._PositiveKeywords != nil {
		fields = append(fields, product.FieldPositiveKeywords)
	}
	if m._NegativeKeywords != nil {
		fields = append(fields, product.FieldNegativeKeywords)
	}
	if m._Link != nil {
		fields = append(fields, product.FieldLink)
	}
	if m._Quantity != nil {
		fields = append(fields, product.FieldQuantity)
	}
	if m._Sizes != nil {
		fields = append(fields, product.FieldSizes)
	}
	if m._Colors != nil {
		fields = append(fields, product.FieldColors)
	}
	if m._Site != nil {
		fields = append(fields, product.FieldSite)
	}
	if m._Metadata != nil {
		fields = append(fields, product.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldName:
		return m.Name()
	case product.FieldImage:
		return m.Image()
	case product.FieldLookupType:
		return m.LookupType()
	case product.FieldPositiveKeywords:
		return m.PositiveKeywords()
	case product.FieldNegativeKeywords:
		return m.NegativeKeywords()
	case product.FieldLink:
		return m.Link()
	case product.FieldQuantity:
		return m.Quantity()
	case product.FieldSizes:
		return m.Sizes()
	case product.FieldColors:
		return m.Colors()
	case product.FieldSite:
		return m.Site()
	case product.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldImage:
		return m.OldImage(ctx)
	case product.FieldLookupType:
		return m.OldLookupType(ctx)
	case product.FieldPositiveKeywords:
		return m.OldPositiveKeywords(ctx)
	case product.FieldNegativeKeywords:
		return m.OldNegativeKeywords(ctx)
	case product.FieldLink:
		return m.OldLink(ctx)
	case product.FieldQuantity:
		return m.OldQuantity(ctx)
	case product.FieldSizes:
		return m.OldSizes(ctx)
	case product.FieldColors:
		return m.OldColors(ctx)
	case product.FieldSite:
		return m.OldSite(ctx)
	case product.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case product.FieldLookupType:
		v, ok := value.(product.LookupType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLookupType(v)
		return nil
	case product.FieldPositiveKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositiveKeywords(v)
		return nil
	case product.FieldNegativeKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNegativeKeywords(v)
		return nil
	case product.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case product.FieldQuantity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case product.FieldSizes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizes(v)
		return nil
	case product.FieldColors:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColors(v)
		return nil
	case product.FieldSite:
		v, ok := value.(product.Site)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSite(v)
		return nil
	case product.FieldMetadata:
		v, ok := value.(sonic.Map)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.add_Quantity != nil {
		fields = append(fields, product.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldQuantity:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldImage) {
		fields = append(fields, product.FieldImage)
	}
	if m.FieldCleared(product.FieldPositiveKeywords) {
		fields = append(fields, product.FieldPositiveKeywords)
	}
	if m.FieldCleared(product.FieldNegativeKeywords) {
		fields = append(fields, product.FieldNegativeKeywords)
	}
	if m.FieldCleared(product.FieldLink) {
		fields = append(fields, product.FieldLink)
	}
	if m.FieldCleared(product.FieldSizes) {
		fields = append(fields, product.FieldSizes)
	}
	if m.FieldCleared(product.FieldColors) {
		fields = append(fields, product.FieldColors)
	}
	if m.FieldCleared(product.FieldMetadata) {
		fields = append(fields, product.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldImage:
		m.ClearImage()
		return nil
	case product.FieldPositiveKeywords:
		m.ClearPositiveKeywords()
		return nil
	case product.FieldNegativeKeywords:
		m.ClearNegativeKeywords()
		return nil
	case product.FieldLink:
		m.ClearLink()
		return nil
	case product.FieldSizes:
		m.ClearSizes()
		return nil
	case product.FieldColors:
		m.ClearColors()
		return nil
	case product.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldImage:
		m.ResetImage()
		return nil
	case product.FieldLookupType:
		m.ResetLookupType()
		return nil
	case product.FieldPositiveKeywords:
		m.ResetPositiveKeywords()
		return nil
	case product.FieldNegativeKeywords:
		m.ResetNegativeKeywords()
		return nil
	case product.FieldLink:
		m.ResetLink()
		return nil
	case product.FieldQuantity:
		m.ResetQuantity()
		return nil
	case product.FieldSizes:
		m.ResetSizes()
		return nil
	case product.FieldColors:
		m.ResetColors()
		return nil
	case product.FieldSite:
		m.ResetSite()
		return nil
	case product.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Task != nil {
		edges = append(edges, product.EdgeTask)
	}
	if m._Statistic != nil {
		edges = append(edges, product.EdgeStatistic)
	}
	if m._Calendar != nil {
		edges = append(edges, product.EdgeCalendar)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeTask:
		ids := make([]ent.Value, 0, len(m._Task))
		for id := range m._Task {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeStatistic:
		ids := make([]ent.Value, 0, len(m._Statistic))
		for id := range m._Statistic {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeCalendar:
		if id := m._Calendar; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_Task != nil {
		edges = append(edges, product.EdgeTask)
	}
	if m.removed_Statistic != nil {
		edges = append(edges, product.EdgeStatistic)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeTask:
		ids := make([]ent.Value, 0, len(m.removed_Task))
		for id := range m.removed_Task {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeStatistic:
		ids := make([]ent.Value, 0, len(m.removed_Statistic))
		for id := range m.removed_Statistic {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Task {
		edges = append(edges, product.EdgeTask)
	}
	if m.cleared_Statistic {
		edges = append(edges, product.EdgeStatistic)
	}
	if m.cleared_Calendar {
		edges = append(edges, product.EdgeCalendar)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeTask:
		return m.cleared_Task
	case product.EdgeStatistic:
		return m.cleared_Statistic
	case product.EdgeCalendar:
		return m.cleared_Calendar
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeCalendar:
		m.ClearCalendar()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeTask:
		m.ResetTask()
		return nil
	case product.EdgeStatistic:
		m.ResetStatistic()
		return nil
	case product.EdgeCalendar:
		m.ResetCalendar()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProfileMutation represents an operation that mutates the Profile nodes in the graph.
type ProfileMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	_Name                *string
	_Email               *string
	clearedFields        map[string]struct{}
	_ProfileGroup        *uuid.UUID
	cleared_ProfileGroup bool
	_Shipping            map[uuid.UUID]struct{}
	removed_Shipping     map[uuid.UUID]struct{}
	cleared_Shipping     bool
	_Billing             map[uuid.UUID]struct{}
	removed_Billing      map[uuid.UUID]struct{}
	cleared_Billing      bool
	done                 bool
	oldValue             func(context.Context) (*Profile, error)
	predicates           []predicate.Profile
}

var _ ent.Mutation = (*ProfileMutation)(nil)

// profileOption allows management of the mutation configuration using functional options.
type profileOption func(*ProfileMutation)

// newProfileMutation creates new mutation for the Profile entity.
func newProfileMutation(c config, op Op, opts ...profileOption) *ProfileMutation {
	m := &ProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfileID sets the ID field of the mutation.
func withProfileID(id uuid.UUID) profileOption {
	return func(m *ProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *Profile
		)
		m.oldValue = func(ctx context.Context) (*Profile, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Profile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfile sets the old Profile of the mutation.
func withProfile(node *Profile) profileOption {
	return func(m *ProfileMutation) {
		m.oldValue = func(context.Context) (*Profile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Profile entities.
func (m *ProfileMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfileMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProfileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProfileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProfileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProfileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProfileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProfileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "Name" field.
func (m *ProfileMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *ProfileMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *ProfileMutation) ResetName() {
	m._Name = nil
}

// SetEmail sets the "Email" field.
func (m *ProfileMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the value of the "Email" field in the mutation.
func (m *ProfileMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "Email" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "Email" field.
func (m *ProfileMutation) ResetEmail() {
	m._Email = nil
}

// SetProfileGroupID sets the "ProfileGroup" edge to the ProfileGroup entity by id.
func (m *ProfileMutation) SetProfileGroupID(id uuid.UUID) {
	m._ProfileGroup = &id
}

// ClearProfileGroup clears the "ProfileGroup" edge to the ProfileGroup entity.
func (m *ProfileMutation) ClearProfileGroup() {
	m.cleared_ProfileGroup = true
}

// ProfileGroupCleared reports if the "ProfileGroup" edge to the ProfileGroup entity was cleared.
func (m *ProfileMutation) ProfileGroupCleared() bool {
	return m.cleared_ProfileGroup
}

// ProfileGroupID returns the "ProfileGroup" edge ID in the mutation.
func (m *ProfileMutation) ProfileGroupID() (id uuid.UUID, exists bool) {
	if m._ProfileGroup != nil {
		return *m._ProfileGroup, true
	}
	return
}

// ProfileGroupIDs returns the "ProfileGroup" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileGroupID instead. It exists only for internal usage by the builders.
func (m *ProfileMutation) ProfileGroupIDs() (ids []uuid.UUID) {
	if id := m._ProfileGroup; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfileGroup resets all changes to the "ProfileGroup" edge.
func (m *ProfileMutation) ResetProfileGroup() {
	m._ProfileGroup = nil
	m.cleared_ProfileGroup = false
}

// AddShippingIDs adds the "Shipping" edge to the Shipping entity by ids.
func (m *ProfileMutation) AddShippingIDs(ids ...uuid.UUID) {
	if m._Shipping == nil {
		m._Shipping = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Shipping[ids[i]] = struct{}{}
	}
}

// ClearShipping clears the "Shipping" edge to the Shipping entity.
func (m *ProfileMutation) ClearShipping() {
	m.cleared_Shipping = true
}

// ShippingCleared reports if the "Shipping" edge to the Shipping entity was cleared.
func (m *ProfileMutation) ShippingCleared() bool {
	return m.cleared_Shipping
}

// RemoveShippingIDs removes the "Shipping" edge to the Shipping entity by IDs.
func (m *ProfileMutation) RemoveShippingIDs(ids ...uuid.UUID) {
	if m.removed_Shipping == nil {
		m.removed_Shipping = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Shipping, ids[i])
		m.removed_Shipping[ids[i]] = struct{}{}
	}
}

// RemovedShipping returns the removed IDs of the "Shipping" edge to the Shipping entity.
func (m *ProfileMutation) RemovedShippingIDs() (ids []uuid.UUID) {
	for id := range m.removed_Shipping {
		ids = append(ids, id)
	}
	return
}

// ShippingIDs returns the "Shipping" edge IDs in the mutation.
func (m *ProfileMutation) ShippingIDs() (ids []uuid.UUID) {
	for id := range m._Shipping {
		ids = append(ids, id)
	}
	return
}

// ResetShipping resets all changes to the "Shipping" edge.
func (m *ProfileMutation) ResetShipping() {
	m._Shipping = nil
	m.cleared_Shipping = false
	m.removed_Shipping = nil
}

// AddBillingIDs adds the "Billing" edge to the Billing entity by ids.
func (m *ProfileMutation) AddBillingIDs(ids ...uuid.UUID) {
	if m._Billing == nil {
		m._Billing = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Billing[ids[i]] = struct{}{}
	}
}

// ClearBilling clears the "Billing" edge to the Billing entity.
func (m *ProfileMutation) ClearBilling() {
	m.cleared_Billing = true
}

// BillingCleared reports if the "Billing" edge to the Billing entity was cleared.
func (m *ProfileMutation) BillingCleared() bool {
	return m.cleared_Billing
}

// RemoveBillingIDs removes the "Billing" edge to the Billing entity by IDs.
func (m *ProfileMutation) RemoveBillingIDs(ids ...uuid.UUID) {
	if m.removed_Billing == nil {
		m.removed_Billing = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Billing, ids[i])
		m.removed_Billing[ids[i]] = struct{}{}
	}
}

// RemovedBilling returns the removed IDs of the "Billing" edge to the Billing entity.
func (m *ProfileMutation) RemovedBillingIDs() (ids []uuid.UUID) {
	for id := range m.removed_Billing {
		ids = append(ids, id)
	}
	return
}

// BillingIDs returns the "Billing" edge IDs in the mutation.
func (m *ProfileMutation) BillingIDs() (ids []uuid.UUID) {
	for id := range m._Billing {
		ids = append(ids, id)
	}
	return
}

// ResetBilling resets all changes to the "Billing" edge.
func (m *ProfileMutation) ResetBilling() {
	m._Billing = nil
	m.cleared_Billing = false
	m.removed_Billing = nil
}

// Where appends a list predicates to the ProfileMutation builder.
func (m *ProfileMutation) Where(ps ...predicate.Profile) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProfileMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Profile).
func (m *ProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfileMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, profile.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, profile.FieldUpdatedAt)
	}
	if m._Name != nil {
		fields = append(fields, profile.FieldName)
	}
	if m._Email != nil {
		fields = append(fields, profile.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profile.FieldCreatedAt:
		return m.CreatedAt()
	case profile.FieldUpdatedAt:
		return m.UpdatedAt()
	case profile.FieldName:
		return m.Name()
	case profile.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case profile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case profile.FieldName:
		return m.OldName(ctx)
	case profile.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown Profile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case profile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case profile.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case profile.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Profile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfileMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfileMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Profile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfileMutation) ResetField(name string) error {
	switch name {
	case profile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case profile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case profile.FieldName:
		m.ResetName()
		return nil
	case profile.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._ProfileGroup != nil {
		edges = append(edges, profile.EdgeProfileGroup)
	}
	if m._Shipping != nil {
		edges = append(edges, profile.EdgeShipping)
	}
	if m._Billing != nil {
		edges = append(edges, profile.EdgeBilling)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeProfileGroup:
		if id := m._ProfileGroup; id != nil {
			return []ent.Value{*id}
		}
	case profile.EdgeShipping:
		ids := make([]ent.Value, 0, len(m._Shipping))
		for id := range m._Shipping {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeBilling:
		ids := make([]ent.Value, 0, len(m._Billing))
		for id := range m._Billing {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_Shipping != nil {
		edges = append(edges, profile.EdgeShipping)
	}
	if m.removed_Billing != nil {
		edges = append(edges, profile.EdgeBilling)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeShipping:
		ids := make([]ent.Value, 0, len(m.removed_Shipping))
		for id := range m.removed_Shipping {
			ids = append(ids, id)
		}
		return ids
	case profile.EdgeBilling:
		ids := make([]ent.Value, 0, len(m.removed_Billing))
		for id := range m.removed_Billing {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_ProfileGroup {
		edges = append(edges, profile.EdgeProfileGroup)
	}
	if m.cleared_Shipping {
		edges = append(edges, profile.EdgeShipping)
	}
	if m.cleared_Billing {
		edges = append(edges, profile.EdgeBilling)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case profile.EdgeProfileGroup:
		return m.cleared_ProfileGroup
	case profile.EdgeShipping:
		return m.cleared_Shipping
	case profile.EdgeBilling:
		return m.cleared_Billing
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfileMutation) ClearEdge(name string) error {
	switch name {
	case profile.EdgeProfileGroup:
		m.ClearProfileGroup()
		return nil
	}
	return fmt.Errorf("unknown Profile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfileMutation) ResetEdge(name string) error {
	switch name {
	case profile.EdgeProfileGroup:
		m.ResetProfileGroup()
		return nil
	case profile.EdgeShipping:
		m.ResetShipping()
		return nil
	case profile.EdgeBilling:
		m.ResetBilling()
		return nil
	}
	return fmt.Errorf("unknown Profile edge %s", name)
}

// ProfileGroupMutation represents an operation that mutates the ProfileGroup nodes in the graph.
type ProfileGroupMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	_Name            *string
	clearedFields    map[string]struct{}
	_Profiles        map[uuid.UUID]struct{}
	removed_Profiles map[uuid.UUID]struct{}
	cleared_Profiles bool
	_App             map[uuid.UUID]struct{}
	removed_App      map[uuid.UUID]struct{}
	cleared_App      bool
	_Task            *uuid.UUID
	cleared_Task     bool
	done             bool
	oldValue         func(context.Context) (*ProfileGroup, error)
	predicates       []predicate.ProfileGroup
}

var _ ent.Mutation = (*ProfileGroupMutation)(nil)

// profilegroupOption allows management of the mutation configuration using functional options.
type profilegroupOption func(*ProfileGroupMutation)

// newProfileGroupMutation creates new mutation for the ProfileGroup entity.
func newProfileGroupMutation(c config, op Op, opts ...profilegroupOption) *ProfileGroupMutation {
	m := &ProfileGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeProfileGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfileGroupID sets the ID field of the mutation.
func withProfileGroupID(id uuid.UUID) profilegroupOption {
	return func(m *ProfileGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *ProfileGroup
		)
		m.oldValue = func(ctx context.Context) (*ProfileGroup, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProfileGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfileGroup sets the old ProfileGroup of the mutation.
func withProfileGroup(node *ProfileGroup) profilegroupOption {
	return func(m *ProfileGroupMutation) {
		m.oldValue = func(context.Context) (*ProfileGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfileGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfileGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProfileGroup entities.
func (m *ProfileGroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfileGroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProfileGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProfileGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProfileGroup entity.
// If the ProfileGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProfileGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProfileGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProfileGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProfileGroup entity.
// If the ProfileGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProfileGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "Name" field.
func (m *ProfileGroupMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *ProfileGroupMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the ProfileGroup entity.
// If the ProfileGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *ProfileGroupMutation) ResetName() {
	m._Name = nil
}

// AddProfileIDs adds the "Profiles" edge to the Profile entity by ids.
func (m *ProfileGroupMutation) AddProfileIDs(ids ...uuid.UUID) {
	if m._Profiles == nil {
		m._Profiles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Profiles[ids[i]] = struct{}{}
	}
}

// ClearProfiles clears the "Profiles" edge to the Profile entity.
func (m *ProfileGroupMutation) ClearProfiles() {
	m.cleared_Profiles = true
}

// ProfilesCleared reports if the "Profiles" edge to the Profile entity was cleared.
func (m *ProfileGroupMutation) ProfilesCleared() bool {
	return m.cleared_Profiles
}

// RemoveProfileIDs removes the "Profiles" edge to the Profile entity by IDs.
func (m *ProfileGroupMutation) RemoveProfileIDs(ids ...uuid.UUID) {
	if m.removed_Profiles == nil {
		m.removed_Profiles = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Profiles, ids[i])
		m.removed_Profiles[ids[i]] = struct{}{}
	}
}

// RemovedProfiles returns the removed IDs of the "Profiles" edge to the Profile entity.
func (m *ProfileGroupMutation) RemovedProfilesIDs() (ids []uuid.UUID) {
	for id := range m.removed_Profiles {
		ids = append(ids, id)
	}
	return
}

// ProfilesIDs returns the "Profiles" edge IDs in the mutation.
func (m *ProfileGroupMutation) ProfilesIDs() (ids []uuid.UUID) {
	for id := range m._Profiles {
		ids = append(ids, id)
	}
	return
}

// ResetProfiles resets all changes to the "Profiles" edge.
func (m *ProfileGroupMutation) ResetProfiles() {
	m._Profiles = nil
	m.cleared_Profiles = false
	m.removed_Profiles = nil
}

// AddAppIDs adds the "App" edge to the App entity by ids.
func (m *ProfileGroupMutation) AddAppIDs(ids ...uuid.UUID) {
	if m._App == nil {
		m._App = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._App[ids[i]] = struct{}{}
	}
}

// ClearApp clears the "App" edge to the App entity.
func (m *ProfileGroupMutation) ClearApp() {
	m.cleared_App = true
}

// AppCleared reports if the "App" edge to the App entity was cleared.
func (m *ProfileGroupMutation) AppCleared() bool {
	return m.cleared_App
}

// RemoveAppIDs removes the "App" edge to the App entity by IDs.
func (m *ProfileGroupMutation) RemoveAppIDs(ids ...uuid.UUID) {
	if m.removed_App == nil {
		m.removed_App = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._App, ids[i])
		m.removed_App[ids[i]] = struct{}{}
	}
}

// RemovedApp returns the removed IDs of the "App" edge to the App entity.
func (m *ProfileGroupMutation) RemovedAppIDs() (ids []uuid.UUID) {
	for id := range m.removed_App {
		ids = append(ids, id)
	}
	return
}

// AppIDs returns the "App" edge IDs in the mutation.
func (m *ProfileGroupMutation) AppIDs() (ids []uuid.UUID) {
	for id := range m._App {
		ids = append(ids, id)
	}
	return
}

// ResetApp resets all changes to the "App" edge.
func (m *ProfileGroupMutation) ResetApp() {
	m._App = nil
	m.cleared_App = false
	m.removed_App = nil
}

// SetTaskID sets the "Task" edge to the Task entity by id.
func (m *ProfileGroupMutation) SetTaskID(id uuid.UUID) {
	m._Task = &id
}

// ClearTask clears the "Task" edge to the Task entity.
func (m *ProfileGroupMutation) ClearTask() {
	m.cleared_Task = true
}

// TaskCleared reports if the "Task" edge to the Task entity was cleared.
func (m *ProfileGroupMutation) TaskCleared() bool {
	return m.cleared_Task
}

// TaskID returns the "Task" edge ID in the mutation.
func (m *ProfileGroupMutation) TaskID() (id uuid.UUID, exists bool) {
	if m._Task != nil {
		return *m._Task, true
	}
	return
}

// TaskIDs returns the "Task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *ProfileGroupMutation) TaskIDs() (ids []uuid.UUID) {
	if id := m._Task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "Task" edge.
func (m *ProfileGroupMutation) ResetTask() {
	m._Task = nil
	m.cleared_Task = false
}

// Where appends a list predicates to the ProfileGroupMutation builder.
func (m *ProfileGroupMutation) Where(ps ...predicate.ProfileGroup) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProfileGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProfileGroup).
func (m *ProfileGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfileGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, profilegroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, profilegroup.FieldUpdatedAt)
	}
	if m._Name != nil {
		fields = append(fields, profilegroup.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfileGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profilegroup.FieldCreatedAt:
		return m.CreatedAt()
	case profilegroup.FieldUpdatedAt:
		return m.UpdatedAt()
	case profilegroup.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfileGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profilegroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case profilegroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case profilegroup.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ProfileGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profilegroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case profilegroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case profilegroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ProfileGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfileGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfileGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProfileGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfileGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfileGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfileGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProfileGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfileGroupMutation) ResetField(name string) error {
	switch name {
	case profilegroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case profilegroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case profilegroup.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ProfileGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfileGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Profiles != nil {
		edges = append(edges, profilegroup.EdgeProfiles)
	}
	if m._App != nil {
		edges = append(edges, profilegroup.EdgeApp)
	}
	if m._Task != nil {
		edges = append(edges, profilegroup.EdgeTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfileGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profilegroup.EdgeProfiles:
		ids := make([]ent.Value, 0, len(m._Profiles))
		for id := range m._Profiles {
			ids = append(ids, id)
		}
		return ids
	case profilegroup.EdgeApp:
		ids := make([]ent.Value, 0, len(m._App))
		for id := range m._App {
			ids = append(ids, id)
		}
		return ids
	case profilegroup.EdgeTask:
		if id := m._Task; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfileGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_Profiles != nil {
		edges = append(edges, profilegroup.EdgeProfiles)
	}
	if m.removed_App != nil {
		edges = append(edges, profilegroup.EdgeApp)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfileGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case profilegroup.EdgeProfiles:
		ids := make([]ent.Value, 0, len(m.removed_Profiles))
		for id := range m.removed_Profiles {
			ids = append(ids, id)
		}
		return ids
	case profilegroup.EdgeApp:
		ids := make([]ent.Value, 0, len(m.removed_App))
		for id := range m.removed_App {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfileGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Profiles {
		edges = append(edges, profilegroup.EdgeProfiles)
	}
	if m.cleared_App {
		edges = append(edges, profilegroup.EdgeApp)
	}
	if m.cleared_Task {
		edges = append(edges, profilegroup.EdgeTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfileGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case profilegroup.EdgeProfiles:
		return m.cleared_Profiles
	case profilegroup.EdgeApp:
		return m.cleared_App
	case profilegroup.EdgeTask:
		return m.cleared_Task
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfileGroupMutation) ClearEdge(name string) error {
	switch name {
	case profilegroup.EdgeTask:
		m.ClearTask()
		return nil
	}
	return fmt.Errorf("unknown ProfileGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfileGroupMutation) ResetEdge(name string) error {
	switch name {
	case profilegroup.EdgeProfiles:
		m.ResetProfiles()
		return nil
	case profilegroup.EdgeApp:
		m.ResetApp()
		return nil
	case profilegroup.EdgeTask:
		m.ResetTask()
		return nil
	}
	return fmt.Errorf("unknown ProfileGroup edge %s", name)
}

// ProxyMutation represents an operation that mutates the Proxy nodes in the graph.
type ProxyMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	_Username         *string
	_Password         *string
	_IP               *string
	_Port             *string
	clearedFields     map[string]struct{}
	_ProxyList        *uuid.UUID
	cleared_ProxyList bool
	done              bool
	oldValue          func(context.Context) (*Proxy, error)
	predicates        []predicate.Proxy
}

var _ ent.Mutation = (*ProxyMutation)(nil)

// proxyOption allows management of the mutation configuration using functional options.
type proxyOption func(*ProxyMutation)

// newProxyMutation creates new mutation for the Proxy entity.
func newProxyMutation(c config, op Op, opts ...proxyOption) *ProxyMutation {
	m := &ProxyMutation{
		config:        c,
		op:            op,
		typ:           TypeProxy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProxyID sets the ID field of the mutation.
func withProxyID(id uuid.UUID) proxyOption {
	return func(m *ProxyMutation) {
		var (
			err   error
			once  sync.Once
			value *Proxy
		)
		m.oldValue = func(ctx context.Context) (*Proxy, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Proxy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProxy sets the old Proxy of the mutation.
func withProxy(node *Proxy) proxyOption {
	return func(m *ProxyMutation) {
		m.oldValue = func(context.Context) (*Proxy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProxyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProxyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Proxy entities.
func (m *ProxyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProxyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProxyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProxyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProxyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProxyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProxyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProxyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "Username" field.
func (m *ProxyMutation) SetUsername(s string) {
	m._Username = &s
}

// Username returns the value of the "Username" field in the mutation.
func (m *ProxyMutation) Username() (r string, exists bool) {
	v := m._Username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "Username" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "Username" field.
func (m *ProxyMutation) ClearUsername() {
	m._Username = nil
	m.clearedFields[proxy.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "Username" field was cleared in this mutation.
func (m *ProxyMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[proxy.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "Username" field.
func (m *ProxyMutation) ResetUsername() {
	m._Username = nil
	delete(m.clearedFields, proxy.FieldUsername)
}

// SetPassword sets the "Password" field.
func (m *ProxyMutation) SetPassword(s string) {
	m._Password = &s
}

// Password returns the value of the "Password" field in the mutation.
func (m *ProxyMutation) Password() (r string, exists bool) {
	v := m._Password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "Password" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "Password" field.
func (m *ProxyMutation) ClearPassword() {
	m._Password = nil
	m.clearedFields[proxy.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "Password" field was cleared in this mutation.
func (m *ProxyMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[proxy.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "Password" field.
func (m *ProxyMutation) ResetPassword() {
	m._Password = nil
	delete(m.clearedFields, proxy.FieldPassword)
}

// SetIP sets the "IP" field.
func (m *ProxyMutation) SetIP(s string) {
	m._IP = &s
}

// IP returns the value of the "IP" field in the mutation.
func (m *ProxyMutation) IP() (r string, exists bool) {
	v := m._IP
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "IP" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "IP" field.
func (m *ProxyMutation) ResetIP() {
	m._IP = nil
}

// SetPort sets the "Port" field.
func (m *ProxyMutation) SetPort(s string) {
	m._Port = &s
}

// Port returns the value of the "Port" field in the mutation.
func (m *ProxyMutation) Port() (r string, exists bool) {
	v := m._Port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "Port" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldPort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// ResetPort resets all changes to the "Port" field.
func (m *ProxyMutation) ResetPort() {
	m._Port = nil
}

// SetProxyListID sets the "ProxyList" edge to the ProxyList entity by id.
func (m *ProxyMutation) SetProxyListID(id uuid.UUID) {
	m._ProxyList = &id
}

// ClearProxyList clears the "ProxyList" edge to the ProxyList entity.
func (m *ProxyMutation) ClearProxyList() {
	m.cleared_ProxyList = true
}

// ProxyListCleared reports if the "ProxyList" edge to the ProxyList entity was cleared.
func (m *ProxyMutation) ProxyListCleared() bool {
	return m.cleared_ProxyList
}

// ProxyListID returns the "ProxyList" edge ID in the mutation.
func (m *ProxyMutation) ProxyListID() (id uuid.UUID, exists bool) {
	if m._ProxyList != nil {
		return *m._ProxyList, true
	}
	return
}

// ProxyListIDs returns the "ProxyList" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProxyListID instead. It exists only for internal usage by the builders.
func (m *ProxyMutation) ProxyListIDs() (ids []uuid.UUID) {
	if id := m._ProxyList; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProxyList resets all changes to the "ProxyList" edge.
func (m *ProxyMutation) ResetProxyList() {
	m._ProxyList = nil
	m.cleared_ProxyList = false
}

// Where appends a list predicates to the ProxyMutation builder.
func (m *ProxyMutation) Where(ps ...predicate.Proxy) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProxyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Proxy).
func (m *ProxyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProxyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, proxy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, proxy.FieldUpdatedAt)
	}
	if m._Username != nil {
		fields = append(fields, proxy.FieldUsername)
	}
	if m._Password != nil {
		fields = append(fields, proxy.FieldPassword)
	}
	if m._IP != nil {
		fields = append(fields, proxy.FieldIP)
	}
	if m._Port != nil {
		fields = append(fields, proxy.FieldPort)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProxyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case proxy.FieldCreatedAt:
		return m.CreatedAt()
	case proxy.FieldUpdatedAt:
		return m.UpdatedAt()
	case proxy.FieldUsername:
		return m.Username()
	case proxy.FieldPassword:
		return m.Password()
	case proxy.FieldIP:
		return m.IP()
	case proxy.FieldPort:
		return m.Port()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProxyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case proxy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case proxy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case proxy.FieldUsername:
		return m.OldUsername(ctx)
	case proxy.FieldPassword:
		return m.OldPassword(ctx)
	case proxy.FieldIP:
		return m.OldIP(ctx)
	case proxy.FieldPort:
		return m.OldPort(ctx)
	}
	return nil, fmt.Errorf("unknown Proxy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProxyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case proxy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case proxy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case proxy.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case proxy.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case proxy.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case proxy.FieldPort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	}
	return fmt.Errorf("unknown Proxy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProxyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProxyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProxyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Proxy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProxyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(proxy.FieldUsername) {
		fields = append(fields, proxy.FieldUsername)
	}
	if m.FieldCleared(proxy.FieldPassword) {
		fields = append(fields, proxy.FieldPassword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProxyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProxyMutation) ClearField(name string) error {
	switch name {
	case proxy.FieldUsername:
		m.ClearUsername()
		return nil
	case proxy.FieldPassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown Proxy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProxyMutation) ResetField(name string) error {
	switch name {
	case proxy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case proxy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case proxy.FieldUsername:
		m.ResetUsername()
		return nil
	case proxy.FieldPassword:
		m.ResetPassword()
		return nil
	case proxy.FieldIP:
		m.ResetIP()
		return nil
	case proxy.FieldPort:
		m.ResetPort()
		return nil
	}
	return fmt.Errorf("unknown Proxy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProxyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._ProxyList != nil {
		edges = append(edges, proxy.EdgeProxyList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProxyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case proxy.EdgeProxyList:
		if id := m._ProxyList; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProxyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProxyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProxyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_ProxyList {
		edges = append(edges, proxy.EdgeProxyList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProxyMutation) EdgeCleared(name string) bool {
	switch name {
	case proxy.EdgeProxyList:
		return m.cleared_ProxyList
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProxyMutation) ClearEdge(name string) error {
	switch name {
	case proxy.EdgeProxyList:
		m.ClearProxyList()
		return nil
	}
	return fmt.Errorf("unknown Proxy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProxyMutation) ResetEdge(name string) error {
	switch name {
	case proxy.EdgeProxyList:
		m.ResetProxyList()
		return nil
	}
	return fmt.Errorf("unknown Proxy edge %s", name)
}

// ProxyListMutation represents an operation that mutates the ProxyList nodes in the graph.
type ProxyListMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	_Name           *string
	_Type           *proxylist.Type
	clearedFields   map[string]struct{}
	_App            map[uuid.UUID]struct{}
	removed_App     map[uuid.UUID]struct{}
	cleared_App     bool
	_Proxies        map[uuid.UUID]struct{}
	removed_Proxies map[uuid.UUID]struct{}
	cleared_Proxies bool
	_Task           map[uuid.UUID]struct{}
	removed_Task    map[uuid.UUID]struct{}
	cleared_Task    bool
	done            bool
	oldValue        func(context.Context) (*ProxyList, error)
	predicates      []predicate.ProxyList
}

var _ ent.Mutation = (*ProxyListMutation)(nil)

// proxylistOption allows management of the mutation configuration using functional options.
type proxylistOption func(*ProxyListMutation)

// newProxyListMutation creates new mutation for the ProxyList entity.
func newProxyListMutation(c config, op Op, opts ...proxylistOption) *ProxyListMutation {
	m := &ProxyListMutation{
		config:        c,
		op:            op,
		typ:           TypeProxyList,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProxyListID sets the ID field of the mutation.
func withProxyListID(id uuid.UUID) proxylistOption {
	return func(m *ProxyListMutation) {
		var (
			err   error
			once  sync.Once
			value *ProxyList
		)
		m.oldValue = func(ctx context.Context) (*ProxyList, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProxyList.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProxyList sets the old ProxyList of the mutation.
func withProxyList(node *ProxyList) proxylistOption {
	return func(m *ProxyListMutation) {
		m.oldValue = func(context.Context) (*ProxyList, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProxyListMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProxyListMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProxyList entities.
func (m *ProxyListMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProxyListMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ProxyListMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProxyListMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProxyList entity.
// If the ProxyList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyListMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProxyListMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProxyListMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProxyListMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProxyList entity.
// If the ProxyList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyListMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProxyListMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "Name" field.
func (m *ProxyListMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *ProxyListMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the ProxyList entity.
// If the ProxyList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyListMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *ProxyListMutation) ResetName() {
	m._Name = nil
}

// SetType sets the "Type" field.
func (m *ProxyListMutation) SetType(pr proxylist.Type) {
	m._Type = &pr
}

// GetType returns the value of the "Type" field in the mutation.
func (m *ProxyListMutation) GetType() (r proxylist.Type, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the ProxyList entity.
// If the ProxyList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyListMutation) OldType(ctx context.Context) (v proxylist.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "Type" field.
func (m *ProxyListMutation) ResetType() {
	m._Type = nil
}

// AddAppIDs adds the "App" edge to the App entity by ids.
func (m *ProxyListMutation) AddAppIDs(ids ...uuid.UUID) {
	if m._App == nil {
		m._App = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._App[ids[i]] = struct{}{}
	}
}

// ClearApp clears the "App" edge to the App entity.
func (m *ProxyListMutation) ClearApp() {
	m.cleared_App = true
}

// AppCleared reports if the "App" edge to the App entity was cleared.
func (m *ProxyListMutation) AppCleared() bool {
	return m.cleared_App
}

// RemoveAppIDs removes the "App" edge to the App entity by IDs.
func (m *ProxyListMutation) RemoveAppIDs(ids ...uuid.UUID) {
	if m.removed_App == nil {
		m.removed_App = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._App, ids[i])
		m.removed_App[ids[i]] = struct{}{}
	}
}

// RemovedApp returns the removed IDs of the "App" edge to the App entity.
func (m *ProxyListMutation) RemovedAppIDs() (ids []uuid.UUID) {
	for id := range m.removed_App {
		ids = append(ids, id)
	}
	return
}

// AppIDs returns the "App" edge IDs in the mutation.
func (m *ProxyListMutation) AppIDs() (ids []uuid.UUID) {
	for id := range m._App {
		ids = append(ids, id)
	}
	return
}

// ResetApp resets all changes to the "App" edge.
func (m *ProxyListMutation) ResetApp() {
	m._App = nil
	m.cleared_App = false
	m.removed_App = nil
}

// AddProxyIDs adds the "Proxies" edge to the Proxy entity by ids.
func (m *ProxyListMutation) AddProxyIDs(ids ...uuid.UUID) {
	if m._Proxies == nil {
		m._Proxies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Proxies[ids[i]] = struct{}{}
	}
}

// ClearProxies clears the "Proxies" edge to the Proxy entity.
func (m *ProxyListMutation) ClearProxies() {
	m.cleared_Proxies = true
}

// ProxiesCleared reports if the "Proxies" edge to the Proxy entity was cleared.
func (m *ProxyListMutation) ProxiesCleared() bool {
	return m.cleared_Proxies
}

// RemoveProxyIDs removes the "Proxies" edge to the Proxy entity by IDs.
func (m *ProxyListMutation) RemoveProxyIDs(ids ...uuid.UUID) {
	if m.removed_Proxies == nil {
		m.removed_Proxies = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Proxies, ids[i])
		m.removed_Proxies[ids[i]] = struct{}{}
	}
}

// RemovedProxies returns the removed IDs of the "Proxies" edge to the Proxy entity.
func (m *ProxyListMutation) RemovedProxiesIDs() (ids []uuid.UUID) {
	for id := range m.removed_Proxies {
		ids = append(ids, id)
	}
	return
}

// ProxiesIDs returns the "Proxies" edge IDs in the mutation.
func (m *ProxyListMutation) ProxiesIDs() (ids []uuid.UUID) {
	for id := range m._Proxies {
		ids = append(ids, id)
	}
	return
}

// ResetProxies resets all changes to the "Proxies" edge.
func (m *ProxyListMutation) ResetProxies() {
	m._Proxies = nil
	m.cleared_Proxies = false
	m.removed_Proxies = nil
}

// AddTaskIDs adds the "Task" edge to the Task entity by ids.
func (m *ProxyListMutation) AddTaskIDs(ids ...uuid.UUID) {
	if m._Task == nil {
		m._Task = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Task[ids[i]] = struct{}{}
	}
}

// ClearTask clears the "Task" edge to the Task entity.
func (m *ProxyListMutation) ClearTask() {
	m.cleared_Task = true
}

// TaskCleared reports if the "Task" edge to the Task entity was cleared.
func (m *ProxyListMutation) TaskCleared() bool {
	return m.cleared_Task
}

// RemoveTaskIDs removes the "Task" edge to the Task entity by IDs.
func (m *ProxyListMutation) RemoveTaskIDs(ids ...uuid.UUID) {
	if m.removed_Task == nil {
		m.removed_Task = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Task, ids[i])
		m.removed_Task[ids[i]] = struct{}{}
	}
}

// RemovedTask returns the removed IDs of the "Task" edge to the Task entity.
func (m *ProxyListMutation) RemovedTaskIDs() (ids []uuid.UUID) {
	for id := range m.removed_Task {
		ids = append(ids, id)
	}
	return
}

// TaskIDs returns the "Task" edge IDs in the mutation.
func (m *ProxyListMutation) TaskIDs() (ids []uuid.UUID) {
	for id := range m._Task {
		ids = append(ids, id)
	}
	return
}

// ResetTask resets all changes to the "Task" edge.
func (m *ProxyListMutation) ResetTask() {
	m._Task = nil
	m.cleared_Task = false
	m.removed_Task = nil
}

// Where appends a list predicates to the ProxyListMutation builder.
func (m *ProxyListMutation) Where(ps ...predicate.ProxyList) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProxyListMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProxyList).
func (m *ProxyListMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProxyListMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, proxylist.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, proxylist.FieldUpdatedAt)
	}
	if m._Name != nil {
		fields = append(fields, proxylist.FieldName)
	}
	if m._Type != nil {
		fields = append(fields, proxylist.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProxyListMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case proxylist.FieldCreatedAt:
		return m.CreatedAt()
	case proxylist.FieldUpdatedAt:
		return m.UpdatedAt()
	case proxylist.FieldName:
		return m.Name()
	case proxylist.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProxyListMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case proxylist.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case proxylist.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case proxylist.FieldName:
		return m.OldName(ctx)
	case proxylist.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown ProxyList field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProxyListMutation) SetField(name string, value ent.Value) error {
	switch name {
	case proxylist.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case proxylist.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case proxylist.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case proxylist.FieldType:
		v, ok := value.(proxylist.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown ProxyList field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProxyListMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProxyListMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProxyListMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProxyList numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProxyListMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProxyListMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProxyListMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProxyList nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProxyListMutation) ResetField(name string) error {
	switch name {
	case proxylist.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case proxylist.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case proxylist.FieldName:
		m.ResetName()
		return nil
	case proxylist.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown ProxyList field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProxyListMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._App != nil {
		edges = append(edges, proxylist.EdgeApp)
	}
	if m._Proxies != nil {
		edges = append(edges, proxylist.EdgeProxies)
	}
	if m._Task != nil {
		edges = append(edges, proxylist.EdgeTask)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProxyListMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case proxylist.EdgeApp:
		ids := make([]ent.Value, 0, len(m._App))
		for id := range m._App {
			ids = append(ids, id)
		}
		return ids
	case proxylist.EdgeProxies:
		ids := make([]ent.Value, 0, len(m._Proxies))
		for id := range m._Proxies {
			ids = append(ids, id)
		}
		return ids
	case proxylist.EdgeTask:
		ids := make([]ent.Value, 0, len(m._Task))
		for id := range m._Task {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProxyListMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_App != nil {
		edges = append(edges, proxylist.EdgeApp)
	}
	if m.removed_Proxies != nil {
		edges = append(edges, proxylist.EdgeProxies)
	}
	if m.removed_Task != nil {
		edges = append(edges, proxylist.EdgeTask)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProxyListMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case proxylist.EdgeApp:
		ids := make([]ent.Value, 0, len(m.removed_App))
		for id := range m.removed_App {
			ids = append(ids, id)
		}
		return ids
	case proxylist.EdgeProxies:
		ids := make([]ent.Value, 0, len(m.removed_Proxies))
		for id := range m.removed_Proxies {
			ids = append(ids, id)
		}
		return ids
	case proxylist.EdgeTask:
		ids := make([]ent.Value, 0, len(m.removed_Task))
		for id := range m.removed_Task {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProxyListMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_App {
		edges = append(edges, proxylist.EdgeApp)
	}
	if m.cleared_Proxies {
		edges = append(edges, proxylist.EdgeProxies)
	}
	if m.cleared_Task {
		edges = append(edges, proxylist.EdgeTask)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProxyListMutation) EdgeCleared(name string) bool {
	switch name {
	case proxylist.EdgeApp:
		return m.cleared_App
	case proxylist.EdgeProxies:
		return m.cleared_Proxies
	case proxylist.EdgeTask:
		return m.cleared_Task
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProxyListMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProxyList unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProxyListMutation) ResetEdge(name string) error {
	switch name {
	case proxylist.EdgeApp:
		m.ResetApp()
		return nil
	case proxylist.EdgeProxies:
		m.ResetProxies()
		return nil
	case proxylist.EdgeTask:
		m.ResetTask()
		return nil
	}
	return fmt.Errorf("unknown ProxyList edge %s", name)
}

// ReleaseMutation represents an operation that mutates the Release nodes in the graph.
type ReleaseMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	_ReleaseDate         *time.Time
	_StockLevel          *int32
	add_StockLevel       *int32
	_Code                *string
	_Type                *release.Type
	_OneTimeFeeAmount    *int64
	add_OneTimeFeeAmount *int64
	_SubscriptionFee     *int64
	add_SubscriptionFee  *int64
	_ProductPriceID      *string
	_SubscriptionPriceID *string
	clearedFields        map[string]struct{}
	_Customers           map[uuid.UUID]struct{}
	removed_Customers    map[uuid.UUID]struct{}
	cleared_Customers    bool
	done                 bool
	oldValue             func(context.Context) (*Release, error)
	predicates           []predicate.Release
}

var _ ent.Mutation = (*ReleaseMutation)(nil)

// releaseOption allows management of the mutation configuration using functional options.
type releaseOption func(*ReleaseMutation)

// newReleaseMutation creates new mutation for the Release entity.
func newReleaseMutation(c config, op Op, opts ...releaseOption) *ReleaseMutation {
	m := &ReleaseMutation{
		config:        c,
		op:            op,
		typ:           TypeRelease,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReleaseID sets the ID field of the mutation.
func withReleaseID(id uuid.UUID) releaseOption {
	return func(m *ReleaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Release
		)
		m.oldValue = func(ctx context.Context) (*Release, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Release.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRelease sets the old Release of the mutation.
func withRelease(node *Release) releaseOption {
	return func(m *ReleaseMutation) {
		m.oldValue = func(context.Context) (*Release, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReleaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReleaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Release entities.
func (m *ReleaseMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReleaseMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ReleaseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReleaseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReleaseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetReleaseDate sets the "ReleaseDate" field.
func (m *ReleaseMutation) SetReleaseDate(t time.Time) {
	m._ReleaseDate = &t
}

// ReleaseDate returns the value of the "ReleaseDate" field in the mutation.
func (m *ReleaseMutation) ReleaseDate() (r time.Time, exists bool) {
	v := m._ReleaseDate
	if v == nil {
		return
	}
	return *v, true
}

// OldReleaseDate returns the old "ReleaseDate" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldReleaseDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReleaseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReleaseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleaseDate: %w", err)
	}
	return oldValue.ReleaseDate, nil
}

// ResetReleaseDate resets all changes to the "ReleaseDate" field.
func (m *ReleaseMutation) ResetReleaseDate() {
	m._ReleaseDate = nil
}

// SetStockLevel sets the "StockLevel" field.
func (m *ReleaseMutation) SetStockLevel(i int32) {
	m._StockLevel = &i
	m.add_StockLevel = nil
}

// StockLevel returns the value of the "StockLevel" field in the mutation.
func (m *ReleaseMutation) StockLevel() (r int32, exists bool) {
	v := m._StockLevel
	if v == nil {
		return
	}
	return *v, true
}

// OldStockLevel returns the old "StockLevel" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldStockLevel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStockLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStockLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStockLevel: %w", err)
	}
	return oldValue.StockLevel, nil
}

// AddStockLevel adds i to the "StockLevel" field.
func (m *ReleaseMutation) AddStockLevel(i int32) {
	if m.add_StockLevel != nil {
		*m.add_StockLevel += i
	} else {
		m.add_StockLevel = &i
	}
}

// AddedStockLevel returns the value that was added to the "StockLevel" field in this mutation.
func (m *ReleaseMutation) AddedStockLevel() (r int32, exists bool) {
	v := m.add_StockLevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetStockLevel resets all changes to the "StockLevel" field.
func (m *ReleaseMutation) ResetStockLevel() {
	m._StockLevel = nil
	m.add_StockLevel = nil
}

// SetCode sets the "Code" field.
func (m *ReleaseMutation) SetCode(s string) {
	m._Code = &s
}

// Code returns the value of the "Code" field in the mutation.
func (m *ReleaseMutation) Code() (r string, exists bool) {
	v := m._Code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "Code" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "Code" field.
func (m *ReleaseMutation) ResetCode() {
	m._Code = nil
}

// SetType sets the "Type" field.
func (m *ReleaseMutation) SetType(r release.Type) {
	m._Type = &r
}

// GetType returns the value of the "Type" field in the mutation.
func (m *ReleaseMutation) GetType() (r release.Type, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldType(ctx context.Context) (v release.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "Type" field.
func (m *ReleaseMutation) ResetType() {
	m._Type = nil
}

// SetOneTimeFeeAmount sets the "OneTimeFeeAmount" field.
func (m *ReleaseMutation) SetOneTimeFeeAmount(i int64) {
	m._OneTimeFeeAmount = &i
	m.add_OneTimeFeeAmount = nil
}

// OneTimeFeeAmount returns the value of the "OneTimeFeeAmount" field in the mutation.
func (m *ReleaseMutation) OneTimeFeeAmount() (r int64, exists bool) {
	v := m._OneTimeFeeAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldOneTimeFeeAmount returns the old "OneTimeFeeAmount" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldOneTimeFeeAmount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOneTimeFeeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOneTimeFeeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOneTimeFeeAmount: %w", err)
	}
	return oldValue.OneTimeFeeAmount, nil
}

// AddOneTimeFeeAmount adds i to the "OneTimeFeeAmount" field.
func (m *ReleaseMutation) AddOneTimeFeeAmount(i int64) {
	if m.add_OneTimeFeeAmount != nil {
		*m.add_OneTimeFeeAmount += i
	} else {
		m.add_OneTimeFeeAmount = &i
	}
}

// AddedOneTimeFeeAmount returns the value that was added to the "OneTimeFeeAmount" field in this mutation.
func (m *ReleaseMutation) AddedOneTimeFeeAmount() (r int64, exists bool) {
	v := m.add_OneTimeFeeAmount
	if v == nil {
		return
	}
	return *v, true
}

// ResetOneTimeFeeAmount resets all changes to the "OneTimeFeeAmount" field.
func (m *ReleaseMutation) ResetOneTimeFeeAmount() {
	m._OneTimeFeeAmount = nil
	m.add_OneTimeFeeAmount = nil
}

// SetSubscriptionFee sets the "SubscriptionFee" field.
func (m *ReleaseMutation) SetSubscriptionFee(i int64) {
	m._SubscriptionFee = &i
	m.add_SubscriptionFee = nil
}

// SubscriptionFee returns the value of the "SubscriptionFee" field in the mutation.
func (m *ReleaseMutation) SubscriptionFee() (r int64, exists bool) {
	v := m._SubscriptionFee
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionFee returns the old "SubscriptionFee" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldSubscriptionFee(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubscriptionFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubscriptionFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionFee: %w", err)
	}
	return oldValue.SubscriptionFee, nil
}

// AddSubscriptionFee adds i to the "SubscriptionFee" field.
func (m *ReleaseMutation) AddSubscriptionFee(i int64) {
	if m.add_SubscriptionFee != nil {
		*m.add_SubscriptionFee += i
	} else {
		m.add_SubscriptionFee = &i
	}
}

// AddedSubscriptionFee returns the value that was added to the "SubscriptionFee" field in this mutation.
func (m *ReleaseMutation) AddedSubscriptionFee() (r int64, exists bool) {
	v := m.add_SubscriptionFee
	if v == nil {
		return
	}
	return *v, true
}

// ClearSubscriptionFee clears the value of the "SubscriptionFee" field.
func (m *ReleaseMutation) ClearSubscriptionFee() {
	m._SubscriptionFee = nil
	m.add_SubscriptionFee = nil
	m.clearedFields[release.FieldSubscriptionFee] = struct{}{}
}

// SubscriptionFeeCleared returns if the "SubscriptionFee" field was cleared in this mutation.
func (m *ReleaseMutation) SubscriptionFeeCleared() bool {
	_, ok := m.clearedFields[release.FieldSubscriptionFee]
	return ok
}

// ResetSubscriptionFee resets all changes to the "SubscriptionFee" field.
func (m *ReleaseMutation) ResetSubscriptionFee() {
	m._SubscriptionFee = nil
	m.add_SubscriptionFee = nil
	delete(m.clearedFields, release.FieldSubscriptionFee)
}

// SetProductPriceID sets the "ProductPriceID" field.
func (m *ReleaseMutation) SetProductPriceID(s string) {
	m._ProductPriceID = &s
}

// ProductPriceID returns the value of the "ProductPriceID" field in the mutation.
func (m *ReleaseMutation) ProductPriceID() (r string, exists bool) {
	v := m._ProductPriceID
	if v == nil {
		return
	}
	return *v, true
}

// OldProductPriceID returns the old "ProductPriceID" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldProductPriceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProductPriceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProductPriceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductPriceID: %w", err)
	}
	return oldValue.ProductPriceID, nil
}

// ResetProductPriceID resets all changes to the "ProductPriceID" field.
func (m *ReleaseMutation) ResetProductPriceID() {
	m._ProductPriceID = nil
}

// SetSubscriptionPriceID sets the "SubscriptionPriceID" field.
func (m *ReleaseMutation) SetSubscriptionPriceID(s string) {
	m._SubscriptionPriceID = &s
}

// SubscriptionPriceID returns the value of the "SubscriptionPriceID" field in the mutation.
func (m *ReleaseMutation) SubscriptionPriceID() (r string, exists bool) {
	v := m._SubscriptionPriceID
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionPriceID returns the old "SubscriptionPriceID" field's value of the Release entity.
// If the Release object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReleaseMutation) OldSubscriptionPriceID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubscriptionPriceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubscriptionPriceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionPriceID: %w", err)
	}
	return oldValue.SubscriptionPriceID, nil
}

// ClearSubscriptionPriceID clears the value of the "SubscriptionPriceID" field.
func (m *ReleaseMutation) ClearSubscriptionPriceID() {
	m._SubscriptionPriceID = nil
	m.clearedFields[release.FieldSubscriptionPriceID] = struct{}{}
}

// SubscriptionPriceIDCleared returns if the "SubscriptionPriceID" field was cleared in this mutation.
func (m *ReleaseMutation) SubscriptionPriceIDCleared() bool {
	_, ok := m.clearedFields[release.FieldSubscriptionPriceID]
	return ok
}

// ResetSubscriptionPriceID resets all changes to the "SubscriptionPriceID" field.
func (m *ReleaseMutation) ResetSubscriptionPriceID() {
	m._SubscriptionPriceID = nil
	delete(m.clearedFields, release.FieldSubscriptionPriceID)
}

// AddCustomerIDs adds the "Customers" edge to the User entity by ids.
func (m *ReleaseMutation) AddCustomerIDs(ids ...uuid.UUID) {
	if m._Customers == nil {
		m._Customers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Customers[ids[i]] = struct{}{}
	}
}

// ClearCustomers clears the "Customers" edge to the User entity.
func (m *ReleaseMutation) ClearCustomers() {
	m.cleared_Customers = true
}

// CustomersCleared reports if the "Customers" edge to the User entity was cleared.
func (m *ReleaseMutation) CustomersCleared() bool {
	return m.cleared_Customers
}

// RemoveCustomerIDs removes the "Customers" edge to the User entity by IDs.
func (m *ReleaseMutation) RemoveCustomerIDs(ids ...uuid.UUID) {
	if m.removed_Customers == nil {
		m.removed_Customers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Customers, ids[i])
		m.removed_Customers[ids[i]] = struct{}{}
	}
}

// RemovedCustomers returns the removed IDs of the "Customers" edge to the User entity.
func (m *ReleaseMutation) RemovedCustomersIDs() (ids []uuid.UUID) {
	for id := range m.removed_Customers {
		ids = append(ids, id)
	}
	return
}

// CustomersIDs returns the "Customers" edge IDs in the mutation.
func (m *ReleaseMutation) CustomersIDs() (ids []uuid.UUID) {
	for id := range m._Customers {
		ids = append(ids, id)
	}
	return
}

// ResetCustomers resets all changes to the "Customers" edge.
func (m *ReleaseMutation) ResetCustomers() {
	m._Customers = nil
	m.cleared_Customers = false
	m.removed_Customers = nil
}

// Where appends a list predicates to the ReleaseMutation builder.
func (m *ReleaseMutation) Where(ps ...predicate.Release) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReleaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Release).
func (m *ReleaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReleaseMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, release.FieldCreatedAt)
	}
	if m._ReleaseDate != nil {
		fields = append(fields, release.FieldReleaseDate)
	}
	if m._StockLevel != nil {
		fields = append(fields, release.FieldStockLevel)
	}
	if m._Code != nil {
		fields = append(fields, release.FieldCode)
	}
	if m._Type != nil {
		fields = append(fields, release.FieldType)
	}
	if m._OneTimeFeeAmount != nil {
		fields = append(fields, release.FieldOneTimeFeeAmount)
	}
	if m._SubscriptionFee != nil {
		fields = append(fields, release.FieldSubscriptionFee)
	}
	if m._ProductPriceID != nil {
		fields = append(fields, release.FieldProductPriceID)
	}
	if m._SubscriptionPriceID != nil {
		fields = append(fields, release.FieldSubscriptionPriceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReleaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case release.FieldCreatedAt:
		return m.CreatedAt()
	case release.FieldReleaseDate:
		return m.ReleaseDate()
	case release.FieldStockLevel:
		return m.StockLevel()
	case release.FieldCode:
		return m.Code()
	case release.FieldType:
		return m.GetType()
	case release.FieldOneTimeFeeAmount:
		return m.OneTimeFeeAmount()
	case release.FieldSubscriptionFee:
		return m.SubscriptionFee()
	case release.FieldProductPriceID:
		return m.ProductPriceID()
	case release.FieldSubscriptionPriceID:
		return m.SubscriptionPriceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReleaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case release.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case release.FieldReleaseDate:
		return m.OldReleaseDate(ctx)
	case release.FieldStockLevel:
		return m.OldStockLevel(ctx)
	case release.FieldCode:
		return m.OldCode(ctx)
	case release.FieldType:
		return m.OldType(ctx)
	case release.FieldOneTimeFeeAmount:
		return m.OldOneTimeFeeAmount(ctx)
	case release.FieldSubscriptionFee:
		return m.OldSubscriptionFee(ctx)
	case release.FieldProductPriceID:
		return m.OldProductPriceID(ctx)
	case release.FieldSubscriptionPriceID:
		return m.OldSubscriptionPriceID(ctx)
	}
	return nil, fmt.Errorf("unknown Release field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case release.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case release.FieldReleaseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleaseDate(v)
		return nil
	case release.FieldStockLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStockLevel(v)
		return nil
	case release.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case release.FieldType:
		v, ok := value.(release.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case release.FieldOneTimeFeeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOneTimeFeeAmount(v)
		return nil
	case release.FieldSubscriptionFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionFee(v)
		return nil
	case release.FieldProductPriceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductPriceID(v)
		return nil
	case release.FieldSubscriptionPriceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionPriceID(v)
		return nil
	}
	return fmt.Errorf("unknown Release field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReleaseMutation) AddedFields() []string {
	var fields []string
	if m.add_StockLevel != nil {
		fields = append(fields, release.FieldStockLevel)
	}
	if m.add_OneTimeFeeAmount != nil {
		fields = append(fields, release.FieldOneTimeFeeAmount)
	}
	if m.add_SubscriptionFee != nil {
		fields = append(fields, release.FieldSubscriptionFee)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReleaseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case release.FieldStockLevel:
		return m.AddedStockLevel()
	case release.FieldOneTimeFeeAmount:
		return m.AddedOneTimeFeeAmount()
	case release.FieldSubscriptionFee:
		return m.AddedSubscriptionFee()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReleaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case release.FieldStockLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStockLevel(v)
		return nil
	case release.FieldOneTimeFeeAmount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOneTimeFeeAmount(v)
		return nil
	case release.FieldSubscriptionFee:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSubscriptionFee(v)
		return nil
	}
	return fmt.Errorf("unknown Release numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReleaseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(release.FieldSubscriptionFee) {
		fields = append(fields, release.FieldSubscriptionFee)
	}
	if m.FieldCleared(release.FieldSubscriptionPriceID) {
		fields = append(fields, release.FieldSubscriptionPriceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReleaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReleaseMutation) ClearField(name string) error {
	switch name {
	case release.FieldSubscriptionFee:
		m.ClearSubscriptionFee()
		return nil
	case release.FieldSubscriptionPriceID:
		m.ClearSubscriptionPriceID()
		return nil
	}
	return fmt.Errorf("unknown Release nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReleaseMutation) ResetField(name string) error {
	switch name {
	case release.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case release.FieldReleaseDate:
		m.ResetReleaseDate()
		return nil
	case release.FieldStockLevel:
		m.ResetStockLevel()
		return nil
	case release.FieldCode:
		m.ResetCode()
		return nil
	case release.FieldType:
		m.ResetType()
		return nil
	case release.FieldOneTimeFeeAmount:
		m.ResetOneTimeFeeAmount()
		return nil
	case release.FieldSubscriptionFee:
		m.ResetSubscriptionFee()
		return nil
	case release.FieldProductPriceID:
		m.ResetProductPriceID()
		return nil
	case release.FieldSubscriptionPriceID:
		m.ResetSubscriptionPriceID()
		return nil
	}
	return fmt.Errorf("unknown Release field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReleaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Customers != nil {
		edges = append(edges, release.EdgeCustomers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReleaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case release.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m._Customers))
		for id := range m._Customers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReleaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Customers != nil {
		edges = append(edges, release.EdgeCustomers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReleaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case release.EdgeCustomers:
		ids := make([]ent.Value, 0, len(m.removed_Customers))
		for id := range m.removed_Customers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReleaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Customers {
		edges = append(edges, release.EdgeCustomers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReleaseMutation) EdgeCleared(name string) bool {
	switch name {
	case release.EdgeCustomers:
		return m.cleared_Customers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReleaseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Release unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReleaseMutation) ResetEdge(name string) error {
	switch name {
	case release.EdgeCustomers:
		m.ResetCustomers()
		return nil
	}
	return fmt.Errorf("unknown Release edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	_DeviceName   *string
	_OS           *string
	_DeviceType   *session.DeviceType
	_IP           *string
	_Expired      *bool
	clearedFields map[string]struct{}
	user          *uuid.UUID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Session, error)
	predicates    []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id uuid.UUID) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeviceName sets the "DeviceName" field.
func (m *SessionMutation) SetDeviceName(s string) {
	m._DeviceName = &s
}

// DeviceName returns the value of the "DeviceName" field in the mutation.
func (m *SessionMutation) DeviceName() (r string, exists bool) {
	v := m._DeviceName
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceName returns the old "DeviceName" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldDeviceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceName: %w", err)
	}
	return oldValue.DeviceName, nil
}

// ResetDeviceName resets all changes to the "DeviceName" field.
func (m *SessionMutation) ResetDeviceName() {
	m._DeviceName = nil
}

// SetOS sets the "OS" field.
func (m *SessionMutation) SetOS(s string) {
	m._OS = &s
}

// OS returns the value of the "OS" field in the mutation.
func (m *SessionMutation) OS() (r string, exists bool) {
	v := m._OS
	if v == nil {
		return
	}
	return *v, true
}

// OldOS returns the old "OS" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldOS(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOS: %w", err)
	}
	return oldValue.OS, nil
}

// ResetOS resets all changes to the "OS" field.
func (m *SessionMutation) ResetOS() {
	m._OS = nil
}

// SetDeviceType sets the "DeviceType" field.
func (m *SessionMutation) SetDeviceType(st session.DeviceType) {
	m._DeviceType = &st
}

// DeviceType returns the value of the "DeviceType" field in the mutation.
func (m *SessionMutation) DeviceType() (r session.DeviceType, exists bool) {
	v := m._DeviceType
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceType returns the old "DeviceType" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldDeviceType(ctx context.Context) (v session.DeviceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeviceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeviceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceType: %w", err)
	}
	return oldValue.DeviceType, nil
}

// ResetDeviceType resets all changes to the "DeviceType" field.
func (m *SessionMutation) ResetDeviceType() {
	m._DeviceType = nil
}

// SetIP sets the "IP" field.
func (m *SessionMutation) SetIP(s string) {
	m._IP = &s
}

// IP returns the value of the "IP" field in the mutation.
func (m *SessionMutation) IP() (r string, exists bool) {
	v := m._IP
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "IP" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "IP" field.
func (m *SessionMutation) ResetIP() {
	m._IP = nil
}

// SetExpired sets the "Expired" field.
func (m *SessionMutation) SetExpired(b bool) {
	m._Expired = &b
}

// Expired returns the value of the "Expired" field in the mutation.
func (m *SessionMutation) Expired() (r bool, exists bool) {
	v := m._Expired
	if v == nil {
		return
	}
	return *v, true
}

// OldExpired returns the old "Expired" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpired: %w", err)
	}
	return oldValue.Expired, nil
}

// ResetExpired resets all changes to the "Expired" field.
func (m *SessionMutation) ResetExpired() {
	m._Expired = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *SessionMutation) SetUserID(id uuid.UUID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *SessionMutation) UserID() (id uuid.UUID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m._DeviceName != nil {
		fields = append(fields, session.FieldDeviceName)
	}
	if m._OS != nil {
		fields = append(fields, session.FieldOS)
	}
	if m._DeviceType != nil {
		fields = append(fields, session.FieldDeviceType)
	}
	if m._IP != nil {
		fields = append(fields, session.FieldIP)
	}
	if m._Expired != nil {
		fields = append(fields, session.FieldExpired)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldDeviceName:
		return m.DeviceName()
	case session.FieldOS:
		return m.OS()
	case session.FieldDeviceType:
		return m.DeviceType()
	case session.FieldIP:
		return m.IP()
	case session.FieldExpired:
		return m.Expired()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldDeviceName:
		return m.OldDeviceName(ctx)
	case session.FieldOS:
		return m.OldOS(ctx)
	case session.FieldDeviceType:
		return m.OldDeviceType(ctx)
	case session.FieldIP:
		return m.OldIP(ctx)
	case session.FieldExpired:
		return m.OldExpired(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldDeviceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceName(v)
		return nil
	case session.FieldOS:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOS(v)
		return nil
	case session.FieldDeviceType:
		v, ok := value.(session.DeviceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceType(v)
		return nil
	case session.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case session.FieldExpired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpired(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldDeviceName:
		m.ResetDeviceName()
		return nil
	case session.FieldOS:
		m.ResetOS()
		return nil
	case session.FieldDeviceType:
		m.ResetDeviceType()
		return nil
	case session.FieldIP:
		m.ResetIP()
		return nil
	case session.FieldExpired:
		m.ResetExpired()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// SettingsMutation represents an operation that mutates the Settings nodes in the graph.
type SettingsMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	created_at        *time.Time
	updated_at        *time.Time
	_SuccessWebhook   *string
	_DeclineWebhook   *string
	_CheckoutDelay    *int32
	add_CheckoutDelay *int32
	_ATCDelay         *int32
	add_ATCDelay      *int32
	clearedFields     map[string]struct{}
	_App              *uuid.UUID
	cleared_App       bool
	done              bool
	oldValue          func(context.Context) (*Settings, error)
	predicates        []predicate.Settings
}

var _ ent.Mutation = (*SettingsMutation)(nil)

// settingsOption allows management of the mutation configuration using functional options.
type settingsOption func(*SettingsMutation)

// newSettingsMutation creates new mutation for the Settings entity.
func newSettingsMutation(c config, op Op, opts ...settingsOption) *SettingsMutation {
	m := &SettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingsID sets the ID field of the mutation.
func withSettingsID(id uuid.UUID) settingsOption {
	return func(m *SettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *Settings
		)
		m.oldValue = func(ctx context.Context) (*Settings, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Settings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSettings sets the old Settings of the mutation.
func withSettings(node *Settings) settingsOption {
	return func(m *SettingsMutation) {
		m.oldValue = func(context.Context) (*Settings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Settings entities.
func (m *SettingsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *SettingsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettingsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettingsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSuccessWebhook sets the "SuccessWebhook" field.
func (m *SettingsMutation) SetSuccessWebhook(s string) {
	m._SuccessWebhook = &s
}

// SuccessWebhook returns the value of the "SuccessWebhook" field in the mutation.
func (m *SettingsMutation) SuccessWebhook() (r string, exists bool) {
	v := m._SuccessWebhook
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccessWebhook returns the old "SuccessWebhook" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldSuccessWebhook(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSuccessWebhook is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSuccessWebhook requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccessWebhook: %w", err)
	}
	return oldValue.SuccessWebhook, nil
}

// ResetSuccessWebhook resets all changes to the "SuccessWebhook" field.
func (m *SettingsMutation) ResetSuccessWebhook() {
	m._SuccessWebhook = nil
}

// SetDeclineWebhook sets the "DeclineWebhook" field.
func (m *SettingsMutation) SetDeclineWebhook(s string) {
	m._DeclineWebhook = &s
}

// DeclineWebhook returns the value of the "DeclineWebhook" field in the mutation.
func (m *SettingsMutation) DeclineWebhook() (r string, exists bool) {
	v := m._DeclineWebhook
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclineWebhook returns the old "DeclineWebhook" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldDeclineWebhook(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeclineWebhook is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeclineWebhook requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclineWebhook: %w", err)
	}
	return oldValue.DeclineWebhook, nil
}

// ResetDeclineWebhook resets all changes to the "DeclineWebhook" field.
func (m *SettingsMutation) ResetDeclineWebhook() {
	m._DeclineWebhook = nil
}

// SetCheckoutDelay sets the "CheckoutDelay" field.
func (m *SettingsMutation) SetCheckoutDelay(i int32) {
	m._CheckoutDelay = &i
	m.add_CheckoutDelay = nil
}

// CheckoutDelay returns the value of the "CheckoutDelay" field in the mutation.
func (m *SettingsMutation) CheckoutDelay() (r int32, exists bool) {
	v := m._CheckoutDelay
	if v == nil {
		return
	}
	return *v, true
}

// OldCheckoutDelay returns the old "CheckoutDelay" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldCheckoutDelay(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCheckoutDelay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCheckoutDelay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCheckoutDelay: %w", err)
	}
	return oldValue.CheckoutDelay, nil
}

// AddCheckoutDelay adds i to the "CheckoutDelay" field.
func (m *SettingsMutation) AddCheckoutDelay(i int32) {
	if m.add_CheckoutDelay != nil {
		*m.add_CheckoutDelay += i
	} else {
		m.add_CheckoutDelay = &i
	}
}

// AddedCheckoutDelay returns the value that was added to the "CheckoutDelay" field in this mutation.
func (m *SettingsMutation) AddedCheckoutDelay() (r int32, exists bool) {
	v := m.add_CheckoutDelay
	if v == nil {
		return
	}
	return *v, true
}

// ResetCheckoutDelay resets all changes to the "CheckoutDelay" field.
func (m *SettingsMutation) ResetCheckoutDelay() {
	m._CheckoutDelay = nil
	m.add_CheckoutDelay = nil
}

// SetATCDelay sets the "ATCDelay" field.
func (m *SettingsMutation) SetATCDelay(i int32) {
	m._ATCDelay = &i
	m.add_ATCDelay = nil
}

// ATCDelay returns the value of the "ATCDelay" field in the mutation.
func (m *SettingsMutation) ATCDelay() (r int32, exists bool) {
	v := m._ATCDelay
	if v == nil {
		return
	}
	return *v, true
}

// OldATCDelay returns the old "ATCDelay" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldATCDelay(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldATCDelay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldATCDelay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldATCDelay: %w", err)
	}
	return oldValue.ATCDelay, nil
}

// AddATCDelay adds i to the "ATCDelay" field.
func (m *SettingsMutation) AddATCDelay(i int32) {
	if m.add_ATCDelay != nil {
		*m.add_ATCDelay += i
	} else {
		m.add_ATCDelay = &i
	}
}

// AddedATCDelay returns the value that was added to the "ATCDelay" field in this mutation.
func (m *SettingsMutation) AddedATCDelay() (r int32, exists bool) {
	v := m.add_ATCDelay
	if v == nil {
		return
	}
	return *v, true
}

// ResetATCDelay resets all changes to the "ATCDelay" field.
func (m *SettingsMutation) ResetATCDelay() {
	m._ATCDelay = nil
	m.add_ATCDelay = nil
}

// SetAppID sets the "App" edge to the App entity by id.
func (m *SettingsMutation) SetAppID(id uuid.UUID) {
	m._App = &id
}

// ClearApp clears the "App" edge to the App entity.
func (m *SettingsMutation) ClearApp() {
	m.cleared_App = true
}

// AppCleared reports if the "App" edge to the App entity was cleared.
func (m *SettingsMutation) AppCleared() bool {
	return m.cleared_App
}

// AppID returns the "App" edge ID in the mutation.
func (m *SettingsMutation) AppID() (id uuid.UUID, exists bool) {
	if m._App != nil {
		return *m._App, true
	}
	return
}

// AppIDs returns the "App" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *SettingsMutation) AppIDs() (ids []uuid.UUID) {
	if id := m._App; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "App" edge.
func (m *SettingsMutation) ResetApp() {
	m._App = nil
	m.cleared_App = false
}

// Where appends a list predicates to the SettingsMutation builder.
func (m *SettingsMutation) Where(ps ...predicate.Settings) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SettingsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Settings).
func (m *SettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, settings.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, settings.FieldUpdatedAt)
	}
	if m._SuccessWebhook != nil {
		fields = append(fields, settings.FieldSuccessWebhook)
	}
	if m._DeclineWebhook != nil {
		fields = append(fields, settings.FieldDeclineWebhook)
	}
	if m._CheckoutDelay != nil {
		fields = append(fields, settings.FieldCheckoutDelay)
	}
	if m._ATCDelay != nil {
		fields = append(fields, settings.FieldATCDelay)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case settings.FieldCreatedAt:
		return m.CreatedAt()
	case settings.FieldUpdatedAt:
		return m.UpdatedAt()
	case settings.FieldSuccessWebhook:
		return m.SuccessWebhook()
	case settings.FieldDeclineWebhook:
		return m.DeclineWebhook()
	case settings.FieldCheckoutDelay:
		return m.CheckoutDelay()
	case settings.FieldATCDelay:
		return m.ATCDelay()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case settings.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case settings.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case settings.FieldSuccessWebhook:
		return m.OldSuccessWebhook(ctx)
	case settings.FieldDeclineWebhook:
		return m.OldDeclineWebhook(ctx)
	case settings.FieldCheckoutDelay:
		return m.OldCheckoutDelay(ctx)
	case settings.FieldATCDelay:
		return m.OldATCDelay(ctx)
	}
	return nil, fmt.Errorf("unknown Settings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case settings.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case settings.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case settings.FieldSuccessWebhook:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccessWebhook(v)
		return nil
	case settings.FieldDeclineWebhook:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclineWebhook(v)
		return nil
	case settings.FieldCheckoutDelay:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCheckoutDelay(v)
		return nil
	case settings.FieldATCDelay:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetATCDelay(v)
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingsMutation) AddedFields() []string {
	var fields []string
	if m.add_CheckoutDelay != nil {
		fields = append(fields, settings.FieldCheckoutDelay)
	}
	if m.add_ATCDelay != nil {
		fields = append(fields, settings.FieldATCDelay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case settings.FieldCheckoutDelay:
		return m.AddedCheckoutDelay()
	case settings.FieldATCDelay:
		return m.AddedATCDelay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case settings.FieldCheckoutDelay:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCheckoutDelay(v)
		return nil
	case settings.FieldATCDelay:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddATCDelay(v)
		return nil
	}
	return fmt.Errorf("unknown Settings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Settings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingsMutation) ResetField(name string) error {
	switch name {
	case settings.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case settings.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case settings.FieldSuccessWebhook:
		m.ResetSuccessWebhook()
		return nil
	case settings.FieldDeclineWebhook:
		m.ResetDeclineWebhook()
		return nil
	case settings.FieldCheckoutDelay:
		m.ResetCheckoutDelay()
		return nil
	case settings.FieldATCDelay:
		m.ResetATCDelay()
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._App != nil {
		edges = append(edges, settings.EdgeApp)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case settings.EdgeApp:
		if id := m._App; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_App {
		edges = append(edges, settings.EdgeApp)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingsMutation) EdgeCleared(name string) bool {
	switch name {
	case settings.EdgeApp:
		return m.cleared_App
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingsMutation) ClearEdge(name string) error {
	switch name {
	case settings.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown Settings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingsMutation) ResetEdge(name string) error {
	switch name {
	case settings.EdgeApp:
		m.ResetApp()
		return nil
	}
	return fmt.Errorf("unknown Settings edge %s", name)
}

// ShippingMutation represents an operation that mutates the Shipping nodes in the graph.
type ShippingMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uuid.UUID
	created_at              *time.Time
	updated_at              *time.Time
	_FirstName              *string
	_LastName               *string
	_PhoneNumber            *string
	_BillingIsShipping      *bool
	clearedFields           map[string]struct{}
	_Profile                *uuid.UUID
	cleared_Profile         bool
	_ShippingAddress        *uuid.UUID
	cleared_ShippingAddress bool
	_BillingAddress         map[uuid.UUID]struct{}
	removed_BillingAddress  map[uuid.UUID]struct{}
	cleared_BillingAddress  bool
	done                    bool
	oldValue                func(context.Context) (*Shipping, error)
	predicates              []predicate.Shipping
}

var _ ent.Mutation = (*ShippingMutation)(nil)

// shippingOption allows management of the mutation configuration using functional options.
type shippingOption func(*ShippingMutation)

// newShippingMutation creates new mutation for the Shipping entity.
func newShippingMutation(c config, op Op, opts ...shippingOption) *ShippingMutation {
	m := &ShippingMutation{
		config:        c,
		op:            op,
		typ:           TypeShipping,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShippingID sets the ID field of the mutation.
func withShippingID(id uuid.UUID) shippingOption {
	return func(m *ShippingMutation) {
		var (
			err   error
			once  sync.Once
			value *Shipping
		)
		m.oldValue = func(ctx context.Context) (*Shipping, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Shipping.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipping sets the old Shipping of the mutation.
func withShipping(node *Shipping) shippingOption {
	return func(m *ShippingMutation) {
		m.oldValue = func(context.Context) (*Shipping, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShippingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShippingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Shipping entities.
func (m *ShippingMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShippingMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *ShippingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShippingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Shipping entity.
// If the Shipping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShippingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShippingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ShippingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ShippingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Shipping entity.
// If the Shipping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShippingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ShippingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFirstName sets the "FirstName" field.
func (m *ShippingMutation) SetFirstName(s string) {
	m._FirstName = &s
}

// FirstName returns the value of the "FirstName" field in the mutation.
func (m *ShippingMutation) FirstName() (r string, exists bool) {
	v := m._FirstName
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "FirstName" field's value of the Shipping entity.
// If the Shipping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShippingMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "FirstName" field.
func (m *ShippingMutation) ResetFirstName() {
	m._FirstName = nil
}

// SetLastName sets the "LastName" field.
func (m *ShippingMutation) SetLastName(s string) {
	m._LastName = &s
}

// LastName returns the value of the "LastName" field in the mutation.
func (m *ShippingMutation) LastName() (r string, exists bool) {
	v := m._LastName
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "LastName" field's value of the Shipping entity.
// If the Shipping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShippingMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "LastName" field.
func (m *ShippingMutation) ResetLastName() {
	m._LastName = nil
}

// SetPhoneNumber sets the "PhoneNumber" field.
func (m *ShippingMutation) SetPhoneNumber(s string) {
	m._PhoneNumber = &s
}

// PhoneNumber returns the value of the "PhoneNumber" field in the mutation.
func (m *ShippingMutation) PhoneNumber() (r string, exists bool) {
	v := m._PhoneNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "PhoneNumber" field's value of the Shipping entity.
// If the Shipping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShippingMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "PhoneNumber" field.
func (m *ShippingMutation) ResetPhoneNumber() {
	m._PhoneNumber = nil
}

// SetBillingIsShipping sets the "BillingIsShipping" field.
func (m *ShippingMutation) SetBillingIsShipping(b bool) {
	m._BillingIsShipping = &b
}

// BillingIsShipping returns the value of the "BillingIsShipping" field in the mutation.
func (m *ShippingMutation) BillingIsShipping() (r bool, exists bool) {
	v := m._BillingIsShipping
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingIsShipping returns the old "BillingIsShipping" field's value of the Shipping entity.
// If the Shipping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShippingMutation) OldBillingIsShipping(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBillingIsShipping is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBillingIsShipping requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingIsShipping: %w", err)
	}
	return oldValue.BillingIsShipping, nil
}

// ResetBillingIsShipping resets all changes to the "BillingIsShipping" field.
func (m *ShippingMutation) ResetBillingIsShipping() {
	m._BillingIsShipping = nil
}

// SetProfileID sets the "Profile" edge to the Profile entity by id.
func (m *ShippingMutation) SetProfileID(id uuid.UUID) {
	m._Profile = &id
}

// ClearProfile clears the "Profile" edge to the Profile entity.
func (m *ShippingMutation) ClearProfile() {
	m.cleared_Profile = true
}

// ProfileCleared reports if the "Profile" edge to the Profile entity was cleared.
func (m *ShippingMutation) ProfileCleared() bool {
	return m.cleared_Profile
}

// ProfileID returns the "Profile" edge ID in the mutation.
func (m *ShippingMutation) ProfileID() (id uuid.UUID, exists bool) {
	if m._Profile != nil {
		return *m._Profile, true
	}
	return
}

// ProfileIDs returns the "Profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *ShippingMutation) ProfileIDs() (ids []uuid.UUID) {
	if id := m._Profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "Profile" edge.
func (m *ShippingMutation) ResetProfile() {
	m._Profile = nil
	m.cleared_Profile = false
}

// SetShippingAddressID sets the "ShippingAddress" edge to the Address entity by id.
func (m *ShippingMutation) SetShippingAddressID(id uuid.UUID) {
	m._ShippingAddress = &id
}

// ClearShippingAddress clears the "ShippingAddress" edge to the Address entity.
func (m *ShippingMutation) ClearShippingAddress() {
	m.cleared_ShippingAddress = true
}

// ShippingAddressCleared reports if the "ShippingAddress" edge to the Address entity was cleared.
func (m *ShippingMutation) ShippingAddressCleared() bool {
	return m.cleared_ShippingAddress
}

// ShippingAddressID returns the "ShippingAddress" edge ID in the mutation.
func (m *ShippingMutation) ShippingAddressID() (id uuid.UUID, exists bool) {
	if m._ShippingAddress != nil {
		return *m._ShippingAddress, true
	}
	return
}

// ShippingAddressIDs returns the "ShippingAddress" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShippingAddressID instead. It exists only for internal usage by the builders.
func (m *ShippingMutation) ShippingAddressIDs() (ids []uuid.UUID) {
	if id := m._ShippingAddress; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShippingAddress resets all changes to the "ShippingAddress" edge.
func (m *ShippingMutation) ResetShippingAddress() {
	m._ShippingAddress = nil
	m.cleared_ShippingAddress = false
}

// AddBillingAddresIDs adds the "BillingAddress" edge to the Address entity by ids.
func (m *ShippingMutation) AddBillingAddresIDs(ids ...uuid.UUID) {
	if m._BillingAddress == nil {
		m._BillingAddress = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._BillingAddress[ids[i]] = struct{}{}
	}
}

// ClearBillingAddress clears the "BillingAddress" edge to the Address entity.
func (m *ShippingMutation) ClearBillingAddress() {
	m.cleared_BillingAddress = true
}

// BillingAddressCleared reports if the "BillingAddress" edge to the Address entity was cleared.
func (m *ShippingMutation) BillingAddressCleared() bool {
	return m.cleared_BillingAddress
}

// RemoveBillingAddresIDs removes the "BillingAddress" edge to the Address entity by IDs.
func (m *ShippingMutation) RemoveBillingAddresIDs(ids ...uuid.UUID) {
	if m.removed_BillingAddress == nil {
		m.removed_BillingAddress = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._BillingAddress, ids[i])
		m.removed_BillingAddress[ids[i]] = struct{}{}
	}
}

// RemovedBillingAddress returns the removed IDs of the "BillingAddress" edge to the Address entity.
func (m *ShippingMutation) RemovedBillingAddressIDs() (ids []uuid.UUID) {
	for id := range m.removed_BillingAddress {
		ids = append(ids, id)
	}
	return
}

// BillingAddressIDs returns the "BillingAddress" edge IDs in the mutation.
func (m *ShippingMutation) BillingAddressIDs() (ids []uuid.UUID) {
	for id := range m._BillingAddress {
		ids = append(ids, id)
	}
	return
}

// ResetBillingAddress resets all changes to the "BillingAddress" edge.
func (m *ShippingMutation) ResetBillingAddress() {
	m._BillingAddress = nil
	m.cleared_BillingAddress = false
	m.removed_BillingAddress = nil
}

// Where appends a list predicates to the ShippingMutation builder.
func (m *ShippingMutation) Where(ps ...predicate.Shipping) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ShippingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Shipping).
func (m *ShippingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShippingMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, shipping.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, shipping.FieldUpdatedAt)
	}
	if m._FirstName != nil {
		fields = append(fields, shipping.FieldFirstName)
	}
	if m._LastName != nil {
		fields = append(fields, shipping.FieldLastName)
	}
	if m._PhoneNumber != nil {
		fields = append(fields, shipping.FieldPhoneNumber)
	}
	if m._BillingIsShipping != nil {
		fields = append(fields, shipping.FieldBillingIsShipping)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShippingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipping.FieldCreatedAt:
		return m.CreatedAt()
	case shipping.FieldUpdatedAt:
		return m.UpdatedAt()
	case shipping.FieldFirstName:
		return m.FirstName()
	case shipping.FieldLastName:
		return m.LastName()
	case shipping.FieldPhoneNumber:
		return m.PhoneNumber()
	case shipping.FieldBillingIsShipping:
		return m.BillingIsShipping()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShippingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipping.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shipping.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case shipping.FieldFirstName:
		return m.OldFirstName(ctx)
	case shipping.FieldLastName:
		return m.OldLastName(ctx)
	case shipping.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case shipping.FieldBillingIsShipping:
		return m.OldBillingIsShipping(ctx)
	}
	return nil, fmt.Errorf("unknown Shipping field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShippingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipping.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shipping.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case shipping.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case shipping.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case shipping.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case shipping.FieldBillingIsShipping:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingIsShipping(v)
		return nil
	}
	return fmt.Errorf("unknown Shipping field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShippingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShippingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShippingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Shipping numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShippingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShippingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShippingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Shipping nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShippingMutation) ResetField(name string) error {
	switch name {
	case shipping.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shipping.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case shipping.FieldFirstName:
		m.ResetFirstName()
		return nil
	case shipping.FieldLastName:
		m.ResetLastName()
		return nil
	case shipping.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case shipping.FieldBillingIsShipping:
		m.ResetBillingIsShipping()
		return nil
	}
	return fmt.Errorf("unknown Shipping field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShippingMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Profile != nil {
		edges = append(edges, shipping.EdgeProfile)
	}
	if m._ShippingAddress != nil {
		edges = append(edges, shipping.EdgeShippingAddress)
	}
	if m._BillingAddress != nil {
		edges = append(edges, shipping.EdgeBillingAddress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShippingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipping.EdgeProfile:
		if id := m._Profile; id != nil {
			return []ent.Value{*id}
		}
	case shipping.EdgeShippingAddress:
		if id := m._ShippingAddress; id != nil {
			return []ent.Value{*id}
		}
	case shipping.EdgeBillingAddress:
		ids := make([]ent.Value, 0, len(m._BillingAddress))
		for id := range m._BillingAddress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShippingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_BillingAddress != nil {
		edges = append(edges, shipping.EdgeBillingAddress)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShippingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case shipping.EdgeBillingAddress:
		ids := make([]ent.Value, 0, len(m.removed_BillingAddress))
		for id := range m.removed_BillingAddress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShippingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Profile {
		edges = append(edges, shipping.EdgeProfile)
	}
	if m.cleared_ShippingAddress {
		edges = append(edges, shipping.EdgeShippingAddress)
	}
	if m.cleared_BillingAddress {
		edges = append(edges, shipping.EdgeBillingAddress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShippingMutation) EdgeCleared(name string) bool {
	switch name {
	case shipping.EdgeProfile:
		return m.cleared_Profile
	case shipping.EdgeShippingAddress:
		return m.cleared_ShippingAddress
	case shipping.EdgeBillingAddress:
		return m.cleared_BillingAddress
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShippingMutation) ClearEdge(name string) error {
	switch name {
	case shipping.EdgeProfile:
		m.ClearProfile()
		return nil
	case shipping.EdgeShippingAddress:
		m.ClearShippingAddress()
		return nil
	}
	return fmt.Errorf("unknown Shipping unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShippingMutation) ResetEdge(name string) error {
	switch name {
	case shipping.EdgeProfile:
		m.ResetProfile()
		return nil
	case shipping.EdgeShippingAddress:
		m.ResetShippingAddress()
		return nil
	case shipping.EdgeBillingAddress:
		m.ResetBillingAddress()
		return nil
	}
	return fmt.Errorf("unknown Shipping edge %s", name)
}

// StatisticMutation represents an operation that mutates the Statistic nodes in the graph.
type StatisticMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	created_at          *time.Time
	updated_at          *time.Time
	_Type               *statistic.Type
	_PotentialProfit    *int
	add_PotentialProfit *int
	_Axis               *map[schema.Axis]string
	_Value              *int
	add_Value           *int
	_Spent              *float64
	add_Spent           *float64
	clearedFields       map[string]struct{}
	_User               map[uuid.UUID]struct{}
	removed_User        map[uuid.UUID]struct{}
	cleared_User        bool
	_Product            map[uuid.UUID]struct{}
	removed_Product     map[uuid.UUID]struct{}
	cleared_Product     bool
	done                bool
	oldValue            func(context.Context) (*Statistic, error)
	predicates          []predicate.Statistic
}

var _ ent.Mutation = (*StatisticMutation)(nil)

// statisticOption allows management of the mutation configuration using functional options.
type statisticOption func(*StatisticMutation)

// newStatisticMutation creates new mutation for the Statistic entity.
func newStatisticMutation(c config, op Op, opts ...statisticOption) *StatisticMutation {
	m := &StatisticMutation{
		config:        c,
		op:            op,
		typ:           TypeStatistic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatisticID sets the ID field of the mutation.
func withStatisticID(id uuid.UUID) statisticOption {
	return func(m *StatisticMutation) {
		var (
			err   error
			once  sync.Once
			value *Statistic
		)
		m.oldValue = func(ctx context.Context) (*Statistic, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Statistic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatistic sets the old Statistic of the mutation.
func withStatistic(node *Statistic) statisticOption {
	return func(m *StatisticMutation) {
		m.oldValue = func(context.Context) (*Statistic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatisticMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatisticMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Statistic entities.
func (m *StatisticMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StatisticMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *StatisticMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StatisticMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StatisticMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StatisticMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StatisticMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StatisticMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "Type" field.
func (m *StatisticMutation) SetType(s statistic.Type) {
	m._Type = &s
}

// GetType returns the value of the "Type" field in the mutation.
func (m *StatisticMutation) GetType() (r statistic.Type, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldType(ctx context.Context) (v statistic.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "Type" field.
func (m *StatisticMutation) ResetType() {
	m._Type = nil
}

// SetPotentialProfit sets the "PotentialProfit" field.
func (m *StatisticMutation) SetPotentialProfit(i int) {
	m._PotentialProfit = &i
	m.add_PotentialProfit = nil
}

// PotentialProfit returns the value of the "PotentialProfit" field in the mutation.
func (m *StatisticMutation) PotentialProfit() (r int, exists bool) {
	v := m._PotentialProfit
	if v == nil {
		return
	}
	return *v, true
}

// OldPotentialProfit returns the old "PotentialProfit" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldPotentialProfit(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPotentialProfit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPotentialProfit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPotentialProfit: %w", err)
	}
	return oldValue.PotentialProfit, nil
}

// AddPotentialProfit adds i to the "PotentialProfit" field.
func (m *StatisticMutation) AddPotentialProfit(i int) {
	if m.add_PotentialProfit != nil {
		*m.add_PotentialProfit += i
	} else {
		m.add_PotentialProfit = &i
	}
}

// AddedPotentialProfit returns the value that was added to the "PotentialProfit" field in this mutation.
func (m *StatisticMutation) AddedPotentialProfit() (r int, exists bool) {
	v := m.add_PotentialProfit
	if v == nil {
		return
	}
	return *v, true
}

// ClearPotentialProfit clears the value of the "PotentialProfit" field.
func (m *StatisticMutation) ClearPotentialProfit() {
	m._PotentialProfit = nil
	m.add_PotentialProfit = nil
	m.clearedFields[statistic.FieldPotentialProfit] = struct{}{}
}

// PotentialProfitCleared returns if the "PotentialProfit" field was cleared in this mutation.
func (m *StatisticMutation) PotentialProfitCleared() bool {
	_, ok := m.clearedFields[statistic.FieldPotentialProfit]
	return ok
}

// ResetPotentialProfit resets all changes to the "PotentialProfit" field.
func (m *StatisticMutation) ResetPotentialProfit() {
	m._PotentialProfit = nil
	m.add_PotentialProfit = nil
	delete(m.clearedFields, statistic.FieldPotentialProfit)
}

// SetAxis sets the "Axis" field.
func (m *StatisticMutation) SetAxis(value map[schema.Axis]string) {
	m._Axis = &value
}

// Axis returns the value of the "Axis" field in the mutation.
func (m *StatisticMutation) Axis() (r map[schema.Axis]string, exists bool) {
	v := m._Axis
	if v == nil {
		return
	}
	return *v, true
}

// OldAxis returns the old "Axis" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldAxis(ctx context.Context) (v map[schema.Axis]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAxis is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAxis requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAxis: %w", err)
	}
	return oldValue.Axis, nil
}

// ResetAxis resets all changes to the "Axis" field.
func (m *StatisticMutation) ResetAxis() {
	m._Axis = nil
}

// SetValue sets the "Value" field.
func (m *StatisticMutation) SetValue(i int) {
	m._Value = &i
	m.add_Value = nil
}

// Value returns the value of the "Value" field in the mutation.
func (m *StatisticMutation) Value() (r int, exists bool) {
	v := m._Value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "Value" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds i to the "Value" field.
func (m *StatisticMutation) AddValue(i int) {
	if m.add_Value != nil {
		*m.add_Value += i
	} else {
		m.add_Value = &i
	}
}

// AddedValue returns the value that was added to the "Value" field in this mutation.
func (m *StatisticMutation) AddedValue() (r int, exists bool) {
	v := m.add_Value
	if v == nil {
		return
	}
	return *v, true
}

// ClearValue clears the value of the "Value" field.
func (m *StatisticMutation) ClearValue() {
	m._Value = nil
	m.add_Value = nil
	m.clearedFields[statistic.FieldValue] = struct{}{}
}

// ValueCleared returns if the "Value" field was cleared in this mutation.
func (m *StatisticMutation) ValueCleared() bool {
	_, ok := m.clearedFields[statistic.FieldValue]
	return ok
}

// ResetValue resets all changes to the "Value" field.
func (m *StatisticMutation) ResetValue() {
	m._Value = nil
	m.add_Value = nil
	delete(m.clearedFields, statistic.FieldValue)
}

// SetSpent sets the "Spent" field.
func (m *StatisticMutation) SetSpent(f float64) {
	m._Spent = &f
	m.add_Spent = nil
}

// Spent returns the value of the "Spent" field in the mutation.
func (m *StatisticMutation) Spent() (r float64, exists bool) {
	v := m._Spent
	if v == nil {
		return
	}
	return *v, true
}

// OldSpent returns the old "Spent" field's value of the Statistic entity.
// If the Statistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatisticMutation) OldSpent(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpent: %w", err)
	}
	return oldValue.Spent, nil
}

// AddSpent adds f to the "Spent" field.
func (m *StatisticMutation) AddSpent(f float64) {
	if m.add_Spent != nil {
		*m.add_Spent += f
	} else {
		m.add_Spent = &f
	}
}

// AddedSpent returns the value that was added to the "Spent" field in this mutation.
func (m *StatisticMutation) AddedSpent() (r float64, exists bool) {
	v := m.add_Spent
	if v == nil {
		return
	}
	return *v, true
}

// ClearSpent clears the value of the "Spent" field.
func (m *StatisticMutation) ClearSpent() {
	m._Spent = nil
	m.add_Spent = nil
	m.clearedFields[statistic.FieldSpent] = struct{}{}
}

// SpentCleared returns if the "Spent" field was cleared in this mutation.
func (m *StatisticMutation) SpentCleared() bool {
	_, ok := m.clearedFields[statistic.FieldSpent]
	return ok
}

// ResetSpent resets all changes to the "Spent" field.
func (m *StatisticMutation) ResetSpent() {
	m._Spent = nil
	m.add_Spent = nil
	delete(m.clearedFields, statistic.FieldSpent)
}

// AddUserIDs adds the "User" edge to the User entity by ids.
func (m *StatisticMutation) AddUserIDs(ids ...uuid.UUID) {
	if m._User == nil {
		m._User = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._User[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "User" edge to the User entity.
func (m *StatisticMutation) ClearUser() {
	m.cleared_User = true
}

// UserCleared reports if the "User" edge to the User entity was cleared.
func (m *StatisticMutation) UserCleared() bool {
	return m.cleared_User
}

// RemoveUserIDs removes the "User" edge to the User entity by IDs.
func (m *StatisticMutation) RemoveUserIDs(ids ...uuid.UUID) {
	if m.removed_User == nil {
		m.removed_User = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._User, ids[i])
		m.removed_User[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "User" edge to the User entity.
func (m *StatisticMutation) RemovedUserIDs() (ids []uuid.UUID) {
	for id := range m.removed_User {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "User" edge IDs in the mutation.
func (m *StatisticMutation) UserIDs() (ids []uuid.UUID) {
	for id := range m._User {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "User" edge.
func (m *StatisticMutation) ResetUser() {
	m._User = nil
	m.cleared_User = false
	m.removed_User = nil
}

// AddProductIDs adds the "Product" edge to the Product entity by ids.
func (m *StatisticMutation) AddProductIDs(ids ...uuid.UUID) {
	if m._Product == nil {
		m._Product = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Product[ids[i]] = struct{}{}
	}
}

// ClearProduct clears the "Product" edge to the Product entity.
func (m *StatisticMutation) ClearProduct() {
	m.cleared_Product = true
}

// ProductCleared reports if the "Product" edge to the Product entity was cleared.
func (m *StatisticMutation) ProductCleared() bool {
	return m.cleared_Product
}

// RemoveProductIDs removes the "Product" edge to the Product entity by IDs.
func (m *StatisticMutation) RemoveProductIDs(ids ...uuid.UUID) {
	if m.removed_Product == nil {
		m.removed_Product = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Product, ids[i])
		m.removed_Product[ids[i]] = struct{}{}
	}
}

// RemovedProduct returns the removed IDs of the "Product" edge to the Product entity.
func (m *StatisticMutation) RemovedProductIDs() (ids []uuid.UUID) {
	for id := range m.removed_Product {
		ids = append(ids, id)
	}
	return
}

// ProductIDs returns the "Product" edge IDs in the mutation.
func (m *StatisticMutation) ProductIDs() (ids []uuid.UUID) {
	for id := range m._Product {
		ids = append(ids, id)
	}
	return
}

// ResetProduct resets all changes to the "Product" edge.
func (m *StatisticMutation) ResetProduct() {
	m._Product = nil
	m.cleared_Product = false
	m.removed_Product = nil
}

// Where appends a list predicates to the StatisticMutation builder.
func (m *StatisticMutation) Where(ps ...predicate.Statistic) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StatisticMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Statistic).
func (m *StatisticMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatisticMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, statistic.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, statistic.FieldUpdatedAt)
	}
	if m._Type != nil {
		fields = append(fields, statistic.FieldType)
	}
	if m._PotentialProfit != nil {
		fields = append(fields, statistic.FieldPotentialProfit)
	}
	if m._Axis != nil {
		fields = append(fields, statistic.FieldAxis)
	}
	if m._Value != nil {
		fields = append(fields, statistic.FieldValue)
	}
	if m._Spent != nil {
		fields = append(fields, statistic.FieldSpent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatisticMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statistic.FieldCreatedAt:
		return m.CreatedAt()
	case statistic.FieldUpdatedAt:
		return m.UpdatedAt()
	case statistic.FieldType:
		return m.GetType()
	case statistic.FieldPotentialProfit:
		return m.PotentialProfit()
	case statistic.FieldAxis:
		return m.Axis()
	case statistic.FieldValue:
		return m.Value()
	case statistic.FieldSpent:
		return m.Spent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatisticMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statistic.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case statistic.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case statistic.FieldType:
		return m.OldType(ctx)
	case statistic.FieldPotentialProfit:
		return m.OldPotentialProfit(ctx)
	case statistic.FieldAxis:
		return m.OldAxis(ctx)
	case statistic.FieldValue:
		return m.OldValue(ctx)
	case statistic.FieldSpent:
		return m.OldSpent(ctx)
	}
	return nil, fmt.Errorf("unknown Statistic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatisticMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statistic.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case statistic.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case statistic.FieldType:
		v, ok := value.(statistic.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case statistic.FieldPotentialProfit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPotentialProfit(v)
		return nil
	case statistic.FieldAxis:
		v, ok := value.(map[schema.Axis]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAxis(v)
		return nil
	case statistic.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case statistic.FieldSpent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpent(v)
		return nil
	}
	return fmt.Errorf("unknown Statistic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatisticMutation) AddedFields() []string {
	var fields []string
	if m.add_PotentialProfit != nil {
		fields = append(fields, statistic.FieldPotentialProfit)
	}
	if m.add_Value != nil {
		fields = append(fields, statistic.FieldValue)
	}
	if m.add_Spent != nil {
		fields = append(fields, statistic.FieldSpent)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatisticMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case statistic.FieldPotentialProfit:
		return m.AddedPotentialProfit()
	case statistic.FieldValue:
		return m.AddedValue()
	case statistic.FieldSpent:
		return m.AddedSpent()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatisticMutation) AddField(name string, value ent.Value) error {
	switch name {
	case statistic.FieldPotentialProfit:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPotentialProfit(v)
		return nil
	case statistic.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case statistic.FieldSpent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpent(v)
		return nil
	}
	return fmt.Errorf("unknown Statistic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatisticMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(statistic.FieldPotentialProfit) {
		fields = append(fields, statistic.FieldPotentialProfit)
	}
	if m.FieldCleared(statistic.FieldValue) {
		fields = append(fields, statistic.FieldValue)
	}
	if m.FieldCleared(statistic.FieldSpent) {
		fields = append(fields, statistic.FieldSpent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatisticMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatisticMutation) ClearField(name string) error {
	switch name {
	case statistic.FieldPotentialProfit:
		m.ClearPotentialProfit()
		return nil
	case statistic.FieldValue:
		m.ClearValue()
		return nil
	case statistic.FieldSpent:
		m.ClearSpent()
		return nil
	}
	return fmt.Errorf("unknown Statistic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatisticMutation) ResetField(name string) error {
	switch name {
	case statistic.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case statistic.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case statistic.FieldType:
		m.ResetType()
		return nil
	case statistic.FieldPotentialProfit:
		m.ResetPotentialProfit()
		return nil
	case statistic.FieldAxis:
		m.ResetAxis()
		return nil
	case statistic.FieldValue:
		m.ResetValue()
		return nil
	case statistic.FieldSpent:
		m.ResetSpent()
		return nil
	}
	return fmt.Errorf("unknown Statistic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatisticMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._User != nil {
		edges = append(edges, statistic.EdgeUser)
	}
	if m._Product != nil {
		edges = append(edges, statistic.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatisticMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statistic.EdgeUser:
		ids := make([]ent.Value, 0, len(m._User))
		for id := range m._User {
			ids = append(ids, id)
		}
		return ids
	case statistic.EdgeProduct:
		ids := make([]ent.Value, 0, len(m._Product))
		for id := range m._Product {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatisticMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_User != nil {
		edges = append(edges, statistic.EdgeUser)
	}
	if m.removed_Product != nil {
		edges = append(edges, statistic.EdgeProduct)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatisticMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case statistic.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removed_User))
		for id := range m.removed_User {
			ids = append(ids, id)
		}
		return ids
	case statistic.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.removed_Product))
		for id := range m.removed_Product {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatisticMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_User {
		edges = append(edges, statistic.EdgeUser)
	}
	if m.cleared_Product {
		edges = append(edges, statistic.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatisticMutation) EdgeCleared(name string) bool {
	switch name {
	case statistic.EdgeUser:
		return m.cleared_User
	case statistic.EdgeProduct:
		return m.cleared_Product
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatisticMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Statistic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatisticMutation) ResetEdge(name string) error {
	switch name {
	case statistic.EdgeUser:
		m.ResetUser()
		return nil
	case statistic.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown Statistic edge %s", name)
}

// StripeMutation represents an operation that mutates the Stripe nodes in the graph.
type StripeMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	created_at      *time.Time
	updated_at      *time.Time
	_CustomerID     *string
	_SubscriptionID *string
	_RenewalDate    *time.Time
	clearedFields   map[string]struct{}
	_License        *uuid.UUID
	cleared_License bool
	done            bool
	oldValue        func(context.Context) (*Stripe, error)
	predicates      []predicate.Stripe
}

var _ ent.Mutation = (*StripeMutation)(nil)

// stripeOption allows management of the mutation configuration using functional options.
type stripeOption func(*StripeMutation)

// newStripeMutation creates new mutation for the Stripe entity.
func newStripeMutation(c config, op Op, opts ...stripeOption) *StripeMutation {
	m := &StripeMutation{
		config:        c,
		op:            op,
		typ:           TypeStripe,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStripeID sets the ID field of the mutation.
func withStripeID(id uuid.UUID) stripeOption {
	return func(m *StripeMutation) {
		var (
			err   error
			once  sync.Once
			value *Stripe
		)
		m.oldValue = func(ctx context.Context) (*Stripe, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stripe.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStripe sets the old Stripe of the mutation.
func withStripe(node *Stripe) stripeOption {
	return func(m *StripeMutation) {
		m.oldValue = func(context.Context) (*Stripe, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StripeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StripeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Stripe entities.
func (m *StripeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StripeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *StripeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StripeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Stripe entity.
// If the Stripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StripeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StripeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StripeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StripeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Stripe entity.
// If the Stripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StripeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StripeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCustomerID sets the "CustomerID" field.
func (m *StripeMutation) SetCustomerID(s string) {
	m._CustomerID = &s
}

// CustomerID returns the value of the "CustomerID" field in the mutation.
func (m *StripeMutation) CustomerID() (r string, exists bool) {
	v := m._CustomerID
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "CustomerID" field's value of the Stripe entity.
// If the Stripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StripeMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "CustomerID" field.
func (m *StripeMutation) ResetCustomerID() {
	m._CustomerID = nil
}

// SetSubscriptionID sets the "SubscriptionID" field.
func (m *StripeMutation) SetSubscriptionID(s string) {
	m._SubscriptionID = &s
}

// SubscriptionID returns the value of the "SubscriptionID" field in the mutation.
func (m *StripeMutation) SubscriptionID() (r string, exists bool) {
	v := m._SubscriptionID
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionID returns the old "SubscriptionID" field's value of the Stripe entity.
// If the Stripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StripeMutation) OldSubscriptionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionID: %w", err)
	}
	return oldValue.SubscriptionID, nil
}

// ClearSubscriptionID clears the value of the "SubscriptionID" field.
func (m *StripeMutation) ClearSubscriptionID() {
	m._SubscriptionID = nil
	m.clearedFields[stripe.FieldSubscriptionID] = struct{}{}
}

// SubscriptionIDCleared returns if the "SubscriptionID" field was cleared in this mutation.
func (m *StripeMutation) SubscriptionIDCleared() bool {
	_, ok := m.clearedFields[stripe.FieldSubscriptionID]
	return ok
}

// ResetSubscriptionID resets all changes to the "SubscriptionID" field.
func (m *StripeMutation) ResetSubscriptionID() {
	m._SubscriptionID = nil
	delete(m.clearedFields, stripe.FieldSubscriptionID)
}

// SetRenewalDate sets the "RenewalDate" field.
func (m *StripeMutation) SetRenewalDate(t time.Time) {
	m._RenewalDate = &t
}

// RenewalDate returns the value of the "RenewalDate" field in the mutation.
func (m *StripeMutation) RenewalDate() (r time.Time, exists bool) {
	v := m._RenewalDate
	if v == nil {
		return
	}
	return *v, true
}

// OldRenewalDate returns the old "RenewalDate" field's value of the Stripe entity.
// If the Stripe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StripeMutation) OldRenewalDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRenewalDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRenewalDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenewalDate: %w", err)
	}
	return oldValue.RenewalDate, nil
}

// ClearRenewalDate clears the value of the "RenewalDate" field.
func (m *StripeMutation) ClearRenewalDate() {
	m._RenewalDate = nil
	m.clearedFields[stripe.FieldRenewalDate] = struct{}{}
}

// RenewalDateCleared returns if the "RenewalDate" field was cleared in this mutation.
func (m *StripeMutation) RenewalDateCleared() bool {
	_, ok := m.clearedFields[stripe.FieldRenewalDate]
	return ok
}

// ResetRenewalDate resets all changes to the "RenewalDate" field.
func (m *StripeMutation) ResetRenewalDate() {
	m._RenewalDate = nil
	delete(m.clearedFields, stripe.FieldRenewalDate)
}

// SetLicenseID sets the "License" edge to the License entity by id.
func (m *StripeMutation) SetLicenseID(id uuid.UUID) {
	m._License = &id
}

// ClearLicense clears the "License" edge to the License entity.
func (m *StripeMutation) ClearLicense() {
	m.cleared_License = true
}

// LicenseCleared reports if the "License" edge to the License entity was cleared.
func (m *StripeMutation) LicenseCleared() bool {
	return m.cleared_License
}

// LicenseID returns the "License" edge ID in the mutation.
func (m *StripeMutation) LicenseID() (id uuid.UUID, exists bool) {
	if m._License != nil {
		return *m._License, true
	}
	return
}

// LicenseIDs returns the "License" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LicenseID instead. It exists only for internal usage by the builders.
func (m *StripeMutation) LicenseIDs() (ids []uuid.UUID) {
	if id := m._License; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLicense resets all changes to the "License" edge.
func (m *StripeMutation) ResetLicense() {
	m._License = nil
	m.cleared_License = false
}

// Where appends a list predicates to the StripeMutation builder.
func (m *StripeMutation) Where(ps ...predicate.Stripe) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StripeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Stripe).
func (m *StripeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StripeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, stripe.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, stripe.FieldUpdatedAt)
	}
	if m._CustomerID != nil {
		fields = append(fields, stripe.FieldCustomerID)
	}
	if m._SubscriptionID != nil {
		fields = append(fields, stripe.FieldSubscriptionID)
	}
	if m._RenewalDate != nil {
		fields = append(fields, stripe.FieldRenewalDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StripeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stripe.FieldCreatedAt:
		return m.CreatedAt()
	case stripe.FieldUpdatedAt:
		return m.UpdatedAt()
	case stripe.FieldCustomerID:
		return m.CustomerID()
	case stripe.FieldSubscriptionID:
		return m.SubscriptionID()
	case stripe.FieldRenewalDate:
		return m.RenewalDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StripeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stripe.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case stripe.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case stripe.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case stripe.FieldSubscriptionID:
		return m.OldSubscriptionID(ctx)
	case stripe.FieldRenewalDate:
		return m.OldRenewalDate(ctx)
	}
	return nil, fmt.Errorf("unknown Stripe field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StripeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stripe.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case stripe.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case stripe.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case stripe.FieldSubscriptionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionID(v)
		return nil
	case stripe.FieldRenewalDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenewalDate(v)
		return nil
	}
	return fmt.Errorf("unknown Stripe field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StripeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StripeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StripeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Stripe numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StripeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stripe.FieldSubscriptionID) {
		fields = append(fields, stripe.FieldSubscriptionID)
	}
	if m.FieldCleared(stripe.FieldRenewalDate) {
		fields = append(fields, stripe.FieldRenewalDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StripeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StripeMutation) ClearField(name string) error {
	switch name {
	case stripe.FieldSubscriptionID:
		m.ClearSubscriptionID()
		return nil
	case stripe.FieldRenewalDate:
		m.ClearRenewalDate()
		return nil
	}
	return fmt.Errorf("unknown Stripe nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StripeMutation) ResetField(name string) error {
	switch name {
	case stripe.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case stripe.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case stripe.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case stripe.FieldSubscriptionID:
		m.ResetSubscriptionID()
		return nil
	case stripe.FieldRenewalDate:
		m.ResetRenewalDate()
		return nil
	}
	return fmt.Errorf("unknown Stripe field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StripeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._License != nil {
		edges = append(edges, stripe.EdgeLicense)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StripeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stripe.EdgeLicense:
		if id := m._License; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StripeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StripeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StripeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_License {
		edges = append(edges, stripe.EdgeLicense)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StripeMutation) EdgeCleared(name string) bool {
	switch name {
	case stripe.EdgeLicense:
		return m.cleared_License
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StripeMutation) ClearEdge(name string) error {
	switch name {
	case stripe.EdgeLicense:
		m.ClearLicense()
		return nil
	}
	return fmt.Errorf("unknown Stripe unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StripeMutation) ResetEdge(name string) error {
	switch name {
	case stripe.EdgeLicense:
		m.ResetLicense()
		return nil
	}
	return fmt.Errorf("unknown Stripe edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	created_at           *time.Time
	updated_at           *time.Time
	_StartTime           *time.Time
	clearedFields        map[string]struct{}
	_Product             map[uuid.UUID]struct{}
	removed_Product      map[uuid.UUID]struct{}
	cleared_Product      bool
	_ProxyList           map[uuid.UUID]struct{}
	removed_ProxyList    map[uuid.UUID]struct{}
	cleared_ProxyList    bool
	_ProfileGroup        map[uuid.UUID]struct{}
	removed_ProfileGroup map[uuid.UUID]struct{}
	cleared_ProfileGroup bool
	_TaskGroup           *uuid.UUID
	cleared_TaskGroup    bool
	done                 bool
	oldValue             func(context.Context) (*Task, error)
	predicates           []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id uuid.UUID) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStartTime sets the "StartTime" field.
func (m *TaskMutation) SetStartTime(t time.Time) {
	m._StartTime = &t
}

// StartTime returns the value of the "StartTime" field in the mutation.
func (m *TaskMutation) StartTime() (r time.Time, exists bool) {
	v := m._StartTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "StartTime" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStartTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ClearStartTime clears the value of the "StartTime" field.
func (m *TaskMutation) ClearStartTime() {
	m._StartTime = nil
	m.clearedFields[task.FieldStartTime] = struct{}{}
}

// StartTimeCleared returns if the "StartTime" field was cleared in this mutation.
func (m *TaskMutation) StartTimeCleared() bool {
	_, ok := m.clearedFields[task.FieldStartTime]
	return ok
}

// ResetStartTime resets all changes to the "StartTime" field.
func (m *TaskMutation) ResetStartTime() {
	m._StartTime = nil
	delete(m.clearedFields, task.FieldStartTime)
}

// AddProductIDs adds the "Product" edge to the Product entity by ids.
func (m *TaskMutation) AddProductIDs(ids ...uuid.UUID) {
	if m._Product == nil {
		m._Product = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Product[ids[i]] = struct{}{}
	}
}

// ClearProduct clears the "Product" edge to the Product entity.
func (m *TaskMutation) ClearProduct() {
	m.cleared_Product = true
}

// ProductCleared reports if the "Product" edge to the Product entity was cleared.
func (m *TaskMutation) ProductCleared() bool {
	return m.cleared_Product
}

// RemoveProductIDs removes the "Product" edge to the Product entity by IDs.
func (m *TaskMutation) RemoveProductIDs(ids ...uuid.UUID) {
	if m.removed_Product == nil {
		m.removed_Product = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Product, ids[i])
		m.removed_Product[ids[i]] = struct{}{}
	}
}

// RemovedProduct returns the removed IDs of the "Product" edge to the Product entity.
func (m *TaskMutation) RemovedProductIDs() (ids []uuid.UUID) {
	for id := range m.removed_Product {
		ids = append(ids, id)
	}
	return
}

// ProductIDs returns the "Product" edge IDs in the mutation.
func (m *TaskMutation) ProductIDs() (ids []uuid.UUID) {
	for id := range m._Product {
		ids = append(ids, id)
	}
	return
}

// ResetProduct resets all changes to the "Product" edge.
func (m *TaskMutation) ResetProduct() {
	m._Product = nil
	m.cleared_Product = false
	m.removed_Product = nil
}

// AddProxyListIDs adds the "ProxyList" edge to the ProxyList entity by ids.
func (m *TaskMutation) AddProxyListIDs(ids ...uuid.UUID) {
	if m._ProxyList == nil {
		m._ProxyList = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ProxyList[ids[i]] = struct{}{}
	}
}

// ClearProxyList clears the "ProxyList" edge to the ProxyList entity.
func (m *TaskMutation) ClearProxyList() {
	m.cleared_ProxyList = true
}

// ProxyListCleared reports if the "ProxyList" edge to the ProxyList entity was cleared.
func (m *TaskMutation) ProxyListCleared() bool {
	return m.cleared_ProxyList
}

// RemoveProxyListIDs removes the "ProxyList" edge to the ProxyList entity by IDs.
func (m *TaskMutation) RemoveProxyListIDs(ids ...uuid.UUID) {
	if m.removed_ProxyList == nil {
		m.removed_ProxyList = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ProxyList, ids[i])
		m.removed_ProxyList[ids[i]] = struct{}{}
	}
}

// RemovedProxyList returns the removed IDs of the "ProxyList" edge to the ProxyList entity.
func (m *TaskMutation) RemovedProxyListIDs() (ids []uuid.UUID) {
	for id := range m.removed_ProxyList {
		ids = append(ids, id)
	}
	return
}

// ProxyListIDs returns the "ProxyList" edge IDs in the mutation.
func (m *TaskMutation) ProxyListIDs() (ids []uuid.UUID) {
	for id := range m._ProxyList {
		ids = append(ids, id)
	}
	return
}

// ResetProxyList resets all changes to the "ProxyList" edge.
func (m *TaskMutation) ResetProxyList() {
	m._ProxyList = nil
	m.cleared_ProxyList = false
	m.removed_ProxyList = nil
}

// AddProfileGroupIDs adds the "ProfileGroup" edge to the ProfileGroup entity by ids.
func (m *TaskMutation) AddProfileGroupIDs(ids ...uuid.UUID) {
	if m._ProfileGroup == nil {
		m._ProfileGroup = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._ProfileGroup[ids[i]] = struct{}{}
	}
}

// ClearProfileGroup clears the "ProfileGroup" edge to the ProfileGroup entity.
func (m *TaskMutation) ClearProfileGroup() {
	m.cleared_ProfileGroup = true
}

// ProfileGroupCleared reports if the "ProfileGroup" edge to the ProfileGroup entity was cleared.
func (m *TaskMutation) ProfileGroupCleared() bool {
	return m.cleared_ProfileGroup
}

// RemoveProfileGroupIDs removes the "ProfileGroup" edge to the ProfileGroup entity by IDs.
func (m *TaskMutation) RemoveProfileGroupIDs(ids ...uuid.UUID) {
	if m.removed_ProfileGroup == nil {
		m.removed_ProfileGroup = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._ProfileGroup, ids[i])
		m.removed_ProfileGroup[ids[i]] = struct{}{}
	}
}

// RemovedProfileGroup returns the removed IDs of the "ProfileGroup" edge to the ProfileGroup entity.
func (m *TaskMutation) RemovedProfileGroupIDs() (ids []uuid.UUID) {
	for id := range m.removed_ProfileGroup {
		ids = append(ids, id)
	}
	return
}

// ProfileGroupIDs returns the "ProfileGroup" edge IDs in the mutation.
func (m *TaskMutation) ProfileGroupIDs() (ids []uuid.UUID) {
	for id := range m._ProfileGroup {
		ids = append(ids, id)
	}
	return
}

// ResetProfileGroup resets all changes to the "ProfileGroup" edge.
func (m *TaskMutation) ResetProfileGroup() {
	m._ProfileGroup = nil
	m.cleared_ProfileGroup = false
	m.removed_ProfileGroup = nil
}

// SetTaskGroupID sets the "TaskGroup" edge to the TaskGroup entity by id.
func (m *TaskMutation) SetTaskGroupID(id uuid.UUID) {
	m._TaskGroup = &id
}

// ClearTaskGroup clears the "TaskGroup" edge to the TaskGroup entity.
func (m *TaskMutation) ClearTaskGroup() {
	m.cleared_TaskGroup = true
}

// TaskGroupCleared reports if the "TaskGroup" edge to the TaskGroup entity was cleared.
func (m *TaskMutation) TaskGroupCleared() bool {
	return m.cleared_TaskGroup
}

// TaskGroupID returns the "TaskGroup" edge ID in the mutation.
func (m *TaskMutation) TaskGroupID() (id uuid.UUID, exists bool) {
	if m._TaskGroup != nil {
		return *m._TaskGroup, true
	}
	return
}

// TaskGroupIDs returns the "TaskGroup" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskGroupID instead. It exists only for internal usage by the builders.
func (m *TaskMutation) TaskGroupIDs() (ids []uuid.UUID) {
	if id := m._TaskGroup; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTaskGroup resets all changes to the "TaskGroup" edge.
func (m *TaskMutation) ResetTaskGroup() {
	m._TaskGroup = nil
	m.cleared_TaskGroup = false
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	if m._StartTime != nil {
		fields = append(fields, task.FieldStartTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldUpdatedAt:
		return m.UpdatedAt()
	case task.FieldStartTime:
		return m.StartTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case task.FieldStartTime:
		return m.OldStartTime(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case task.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldStartTime) {
		fields = append(fields, task.FieldStartTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldStartTime:
		m.ClearStartTime()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case task.FieldStartTime:
		m.ResetStartTime()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._Product != nil {
		edges = append(edges, task.EdgeProduct)
	}
	if m._ProxyList != nil {
		edges = append(edges, task.EdgeProxyList)
	}
	if m._ProfileGroup != nil {
		edges = append(edges, task.EdgeProfileGroup)
	}
	if m._TaskGroup != nil {
		edges = append(edges, task.EdgeTaskGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeProduct:
		ids := make([]ent.Value, 0, len(m._Product))
		for id := range m._Product {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeProxyList:
		ids := make([]ent.Value, 0, len(m._ProxyList))
		for id := range m._ProxyList {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeProfileGroup:
		ids := make([]ent.Value, 0, len(m._ProfileGroup))
		for id := range m._ProfileGroup {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeTaskGroup:
		if id := m._TaskGroup; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_Product != nil {
		edges = append(edges, task.EdgeProduct)
	}
	if m.removed_ProxyList != nil {
		edges = append(edges, task.EdgeProxyList)
	}
	if m.removed_ProfileGroup != nil {
		edges = append(edges, task.EdgeProfileGroup)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case task.EdgeProduct:
		ids := make([]ent.Value, 0, len(m.removed_Product))
		for id := range m.removed_Product {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeProxyList:
		ids := make([]ent.Value, 0, len(m.removed_ProxyList))
		for id := range m.removed_ProxyList {
			ids = append(ids, id)
		}
		return ids
	case task.EdgeProfileGroup:
		ids := make([]ent.Value, 0, len(m.removed_ProfileGroup))
		for id := range m.removed_ProfileGroup {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_Product {
		edges = append(edges, task.EdgeProduct)
	}
	if m.cleared_ProxyList {
		edges = append(edges, task.EdgeProxyList)
	}
	if m.cleared_ProfileGroup {
		edges = append(edges, task.EdgeProfileGroup)
	}
	if m.cleared_TaskGroup {
		edges = append(edges, task.EdgeTaskGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	switch name {
	case task.EdgeProduct:
		return m.cleared_Product
	case task.EdgeProxyList:
		return m.cleared_ProxyList
	case task.EdgeProfileGroup:
		return m.cleared_ProfileGroup
	case task.EdgeTaskGroup:
		return m.cleared_TaskGroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	switch name {
	case task.EdgeTaskGroup:
		m.ClearTaskGroup()
		return nil
	}
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	switch name {
	case task.EdgeProduct:
		m.ResetProduct()
		return nil
	case task.EdgeProxyList:
		m.ResetProxyList()
		return nil
	case task.EdgeProfileGroup:
		m.ResetProfileGroup()
		return nil
	case task.EdgeTaskGroup:
		m.ResetTaskGroup()
		return nil
	}
	return fmt.Errorf("unknown Task edge %s", name)
}

// TaskGroupMutation represents an operation that mutates the TaskGroup nodes in the graph.
type TaskGroupMutation struct {
	config
	op            Op
	typ           string
	id            *uuid.UUID
	created_at    *time.Time
	updated_at    *time.Time
	_Name         *string
	clearedFields map[string]struct{}
	_App          map[uuid.UUID]struct{}
	removed_App   map[uuid.UUID]struct{}
	cleared_App   bool
	_Tasks        map[uuid.UUID]struct{}
	removed_Tasks map[uuid.UUID]struct{}
	cleared_Tasks bool
	done          bool
	oldValue      func(context.Context) (*TaskGroup, error)
	predicates    []predicate.TaskGroup
}

var _ ent.Mutation = (*TaskGroupMutation)(nil)

// taskgroupOption allows management of the mutation configuration using functional options.
type taskgroupOption func(*TaskGroupMutation)

// newTaskGroupMutation creates new mutation for the TaskGroup entity.
func newTaskGroupMutation(c config, op Op, opts ...taskgroupOption) *TaskGroupMutation {
	m := &TaskGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskGroupID sets the ID field of the mutation.
func withTaskGroupID(id uuid.UUID) taskgroupOption {
	return func(m *TaskGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskGroup
		)
		m.oldValue = func(ctx context.Context) (*TaskGroup, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskGroup sets the old TaskGroup of the mutation.
func withTaskGroup(node *TaskGroup) taskgroupOption {
	return func(m *TaskGroupMutation) {
		m.oldValue = func(context.Context) (*TaskGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TaskGroup entities.
func (m *TaskGroupMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskGroupMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TaskGroup entity.
// If the TaskGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TaskGroup entity.
// If the TaskGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "Name" field.
func (m *TaskGroupMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *TaskGroupMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the TaskGroup entity.
// If the TaskGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *TaskGroupMutation) ResetName() {
	m._Name = nil
}

// AddAppIDs adds the "App" edge to the App entity by ids.
func (m *TaskGroupMutation) AddAppIDs(ids ...uuid.UUID) {
	if m._App == nil {
		m._App = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._App[ids[i]] = struct{}{}
	}
}

// ClearApp clears the "App" edge to the App entity.
func (m *TaskGroupMutation) ClearApp() {
	m.cleared_App = true
}

// AppCleared reports if the "App" edge to the App entity was cleared.
func (m *TaskGroupMutation) AppCleared() bool {
	return m.cleared_App
}

// RemoveAppIDs removes the "App" edge to the App entity by IDs.
func (m *TaskGroupMutation) RemoveAppIDs(ids ...uuid.UUID) {
	if m.removed_App == nil {
		m.removed_App = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._App, ids[i])
		m.removed_App[ids[i]] = struct{}{}
	}
}

// RemovedApp returns the removed IDs of the "App" edge to the App entity.
func (m *TaskGroupMutation) RemovedAppIDs() (ids []uuid.UUID) {
	for id := range m.removed_App {
		ids = append(ids, id)
	}
	return
}

// AppIDs returns the "App" edge IDs in the mutation.
func (m *TaskGroupMutation) AppIDs() (ids []uuid.UUID) {
	for id := range m._App {
		ids = append(ids, id)
	}
	return
}

// ResetApp resets all changes to the "App" edge.
func (m *TaskGroupMutation) ResetApp() {
	m._App = nil
	m.cleared_App = false
	m.removed_App = nil
}

// AddTaskIDs adds the "Tasks" edge to the Task entity by ids.
func (m *TaskGroupMutation) AddTaskIDs(ids ...uuid.UUID) {
	if m._Tasks == nil {
		m._Tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Tasks[ids[i]] = struct{}{}
	}
}

// ClearTasks clears the "Tasks" edge to the Task entity.
func (m *TaskGroupMutation) ClearTasks() {
	m.cleared_Tasks = true
}

// TasksCleared reports if the "Tasks" edge to the Task entity was cleared.
func (m *TaskGroupMutation) TasksCleared() bool {
	return m.cleared_Tasks
}

// RemoveTaskIDs removes the "Tasks" edge to the Task entity by IDs.
func (m *TaskGroupMutation) RemoveTaskIDs(ids ...uuid.UUID) {
	if m.removed_Tasks == nil {
		m.removed_Tasks = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Tasks, ids[i])
		m.removed_Tasks[ids[i]] = struct{}{}
	}
}

// RemovedTasks returns the removed IDs of the "Tasks" edge to the Task entity.
func (m *TaskGroupMutation) RemovedTasksIDs() (ids []uuid.UUID) {
	for id := range m.removed_Tasks {
		ids = append(ids, id)
	}
	return
}

// TasksIDs returns the "Tasks" edge IDs in the mutation.
func (m *TaskGroupMutation) TasksIDs() (ids []uuid.UUID) {
	for id := range m._Tasks {
		ids = append(ids, id)
	}
	return
}

// ResetTasks resets all changes to the "Tasks" edge.
func (m *TaskGroupMutation) ResetTasks() {
	m._Tasks = nil
	m.cleared_Tasks = false
	m.removed_Tasks = nil
}

// Where appends a list predicates to the TaskGroupMutation builder.
func (m *TaskGroupMutation) Where(ps ...predicate.TaskGroup) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TaskGroup).
func (m *TaskGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, taskgroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, taskgroup.FieldUpdatedAt)
	}
	if m._Name != nil {
		fields = append(fields, taskgroup.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case taskgroup.FieldCreatedAt:
		return m.CreatedAt()
	case taskgroup.FieldUpdatedAt:
		return m.UpdatedAt()
	case taskgroup.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case taskgroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case taskgroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case taskgroup.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown TaskGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case taskgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case taskgroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case taskgroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown TaskGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskGroupMutation) ResetField(name string) error {
	switch name {
	case taskgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case taskgroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case taskgroup.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown TaskGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._App != nil {
		edges = append(edges, taskgroup.EdgeApp)
	}
	if m._Tasks != nil {
		edges = append(edges, taskgroup.EdgeTasks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case taskgroup.EdgeApp:
		ids := make([]ent.Value, 0, len(m._App))
		for id := range m._App {
			ids = append(ids, id)
		}
		return ids
	case taskgroup.EdgeTasks:
		ids := make([]ent.Value, 0, len(m._Tasks))
		for id := range m._Tasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_App != nil {
		edges = append(edges, taskgroup.EdgeApp)
	}
	if m.removed_Tasks != nil {
		edges = append(edges, taskgroup.EdgeTasks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case taskgroup.EdgeApp:
		ids := make([]ent.Value, 0, len(m.removed_App))
		for id := range m.removed_App {
			ids = append(ids, id)
		}
		return ids
	case taskgroup.EdgeTasks:
		ids := make([]ent.Value, 0, len(m.removed_Tasks))
		for id := range m.removed_Tasks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_App {
		edges = append(edges, taskgroup.EdgeApp)
	}
	if m.cleared_Tasks {
		edges = append(edges, taskgroup.EdgeTasks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case taskgroup.EdgeApp:
		return m.cleared_App
	case taskgroup.EdgeTasks:
		return m.cleared_Tasks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskGroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskGroupMutation) ResetEdge(name string) error {
	switch name {
	case taskgroup.EdgeApp:
		m.ResetApp()
		return nil
	case taskgroup.EdgeTasks:
		m.ResetTasks()
		return nil
	}
	return fmt.Errorf("unknown TaskGroup edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	created_at         *time.Time
	updated_at         *time.Time
	_Disabled          *bool
	clearedFields      map[string]struct{}
	_License           *uuid.UUID
	cleared_License    bool
	_Statistics        map[uuid.UUID]struct{}
	removed_Statistics map[uuid.UUID]struct{}
	cleared_Statistics bool
	_App               *uuid.UUID
	cleared_App        bool
	_Metadata          *uuid.UUID
	cleared_Metadata   bool
	_Sessions          map[uuid.UUID]struct{}
	removed_Sessions   map[uuid.UUID]struct{}
	cleared_Sessions   bool
	_Release           *uuid.UUID
	cleared_Release    bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDisabled sets the "Disabled" field.
func (m *UserMutation) SetDisabled(b bool) {
	m._Disabled = &b
}

// Disabled returns the value of the "Disabled" field in the mutation.
func (m *UserMutation) Disabled() (r bool, exists bool) {
	v := m._Disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "Disabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ResetDisabled resets all changes to the "Disabled" field.
func (m *UserMutation) ResetDisabled() {
	m._Disabled = nil
}

// SetLicenseID sets the "License" edge to the License entity by id.
func (m *UserMutation) SetLicenseID(id uuid.UUID) {
	m._License = &id
}

// ClearLicense clears the "License" edge to the License entity.
func (m *UserMutation) ClearLicense() {
	m.cleared_License = true
}

// LicenseCleared reports if the "License" edge to the License entity was cleared.
func (m *UserMutation) LicenseCleared() bool {
	return m.cleared_License
}

// LicenseID returns the "License" edge ID in the mutation.
func (m *UserMutation) LicenseID() (id uuid.UUID, exists bool) {
	if m._License != nil {
		return *m._License, true
	}
	return
}

// LicenseIDs returns the "License" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LicenseID instead. It exists only for internal usage by the builders.
func (m *UserMutation) LicenseIDs() (ids []uuid.UUID) {
	if id := m._License; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLicense resets all changes to the "License" edge.
func (m *UserMutation) ResetLicense() {
	m._License = nil
	m.cleared_License = false
}

// AddStatisticIDs adds the "Statistics" edge to the Statistic entity by ids.
func (m *UserMutation) AddStatisticIDs(ids ...uuid.UUID) {
	if m._Statistics == nil {
		m._Statistics = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Statistics[ids[i]] = struct{}{}
	}
}

// ClearStatistics clears the "Statistics" edge to the Statistic entity.
func (m *UserMutation) ClearStatistics() {
	m.cleared_Statistics = true
}

// StatisticsCleared reports if the "Statistics" edge to the Statistic entity was cleared.
func (m *UserMutation) StatisticsCleared() bool {
	return m.cleared_Statistics
}

// RemoveStatisticIDs removes the "Statistics" edge to the Statistic entity by IDs.
func (m *UserMutation) RemoveStatisticIDs(ids ...uuid.UUID) {
	if m.removed_Statistics == nil {
		m.removed_Statistics = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Statistics, ids[i])
		m.removed_Statistics[ids[i]] = struct{}{}
	}
}

// RemovedStatistics returns the removed IDs of the "Statistics" edge to the Statistic entity.
func (m *UserMutation) RemovedStatisticsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Statistics {
		ids = append(ids, id)
	}
	return
}

// StatisticsIDs returns the "Statistics" edge IDs in the mutation.
func (m *UserMutation) StatisticsIDs() (ids []uuid.UUID) {
	for id := range m._Statistics {
		ids = append(ids, id)
	}
	return
}

// ResetStatistics resets all changes to the "Statistics" edge.
func (m *UserMutation) ResetStatistics() {
	m._Statistics = nil
	m.cleared_Statistics = false
	m.removed_Statistics = nil
}

// SetAppID sets the "App" edge to the App entity by id.
func (m *UserMutation) SetAppID(id uuid.UUID) {
	m._App = &id
}

// ClearApp clears the "App" edge to the App entity.
func (m *UserMutation) ClearApp() {
	m.cleared_App = true
}

// AppCleared reports if the "App" edge to the App entity was cleared.
func (m *UserMutation) AppCleared() bool {
	return m.cleared_App
}

// AppID returns the "App" edge ID in the mutation.
func (m *UserMutation) AppID() (id uuid.UUID, exists bool) {
	if m._App != nil {
		return *m._App, true
	}
	return
}

// AppIDs returns the "App" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *UserMutation) AppIDs() (ids []uuid.UUID) {
	if id := m._App; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "App" edge.
func (m *UserMutation) ResetApp() {
	m._App = nil
	m.cleared_App = false
}

// SetMetadataID sets the "Metadata" edge to the Metadata entity by id.
func (m *UserMutation) SetMetadataID(id uuid.UUID) {
	m._Metadata = &id
}

// ClearMetadata clears the "Metadata" edge to the Metadata entity.
func (m *UserMutation) ClearMetadata() {
	m.cleared_Metadata = true
}

// MetadataCleared reports if the "Metadata" edge to the Metadata entity was cleared.
func (m *UserMutation) MetadataCleared() bool {
	return m.cleared_Metadata
}

// MetadataID returns the "Metadata" edge ID in the mutation.
func (m *UserMutation) MetadataID() (id uuid.UUID, exists bool) {
	if m._Metadata != nil {
		return *m._Metadata, true
	}
	return
}

// MetadataIDs returns the "Metadata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MetadataID instead. It exists only for internal usage by the builders.
func (m *UserMutation) MetadataIDs() (ids []uuid.UUID) {
	if id := m._Metadata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMetadata resets all changes to the "Metadata" edge.
func (m *UserMutation) ResetMetadata() {
	m._Metadata = nil
	m.cleared_Metadata = false
}

// AddSessionIDs adds the "Sessions" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...uuid.UUID) {
	if m._Sessions == nil {
		m._Sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m._Sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "Sessions" edge to the Session entity.
func (m *UserMutation) ClearSessions() {
	m.cleared_Sessions = true
}

// SessionsCleared reports if the "Sessions" edge to the Session entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.cleared_Sessions
}

// RemoveSessionIDs removes the "Sessions" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...uuid.UUID) {
	if m.removed_Sessions == nil {
		m.removed_Sessions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m._Sessions, ids[i])
		m.removed_Sessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "Sessions" edge to the Session entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []uuid.UUID) {
	for id := range m.removed_Sessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "Sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []uuid.UUID) {
	for id := range m._Sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "Sessions" edge.
func (m *UserMutation) ResetSessions() {
	m._Sessions = nil
	m.cleared_Sessions = false
	m.removed_Sessions = nil
}

// SetReleaseID sets the "Release" edge to the Release entity by id.
func (m *UserMutation) SetReleaseID(id uuid.UUID) {
	m._Release = &id
}

// ClearRelease clears the "Release" edge to the Release entity.
func (m *UserMutation) ClearRelease() {
	m.cleared_Release = true
}

// ReleaseCleared reports if the "Release" edge to the Release entity was cleared.
func (m *UserMutation) ReleaseCleared() bool {
	return m.cleared_Release
}

// ReleaseID returns the "Release" edge ID in the mutation.
func (m *UserMutation) ReleaseID() (id uuid.UUID, exists bool) {
	if m._Release != nil {
		return *m._Release, true
	}
	return
}

// ReleaseIDs returns the "Release" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReleaseID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ReleaseIDs() (ids []uuid.UUID) {
	if id := m._Release; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelease resets all changes to the "Release" edge.
func (m *UserMutation) ResetRelease() {
	m._Release = nil
	m.cleared_Release = false
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m._Disabled != nil {
		fields = append(fields, user.FieldDisabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDisabled:
		return m.Disabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDisabled:
		return m.OldDisabled(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDisabled:
		m.ResetDisabled()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m._License != nil {
		edges = append(edges, user.EdgeLicense)
	}
	if m._Statistics != nil {
		edges = append(edges, user.EdgeStatistics)
	}
	if m._App != nil {
		edges = append(edges, user.EdgeApp)
	}
	if m._Metadata != nil {
		edges = append(edges, user.EdgeMetadata)
	}
	if m._Sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m._Release != nil {
		edges = append(edges, user.EdgeRelease)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeLicense:
		if id := m._License; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeStatistics:
		ids := make([]ent.Value, 0, len(m._Statistics))
		for id := range m._Statistics {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApp:
		if id := m._App; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeMetadata:
		if id := m._Metadata; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m._Sessions))
		for id := range m._Sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRelease:
		if id := m._Release; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removed_Statistics != nil {
		edges = append(edges, user.EdgeStatistics)
	}
	if m.removed_Sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeStatistics:
		ids := make([]ent.Value, 0, len(m.removed_Statistics))
		for id := range m.removed_Statistics {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removed_Sessions))
		for id := range m.removed_Sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleared_License {
		edges = append(edges, user.EdgeLicense)
	}
	if m.cleared_Statistics {
		edges = append(edges, user.EdgeStatistics)
	}
	if m.cleared_App {
		edges = append(edges, user.EdgeApp)
	}
	if m.cleared_Metadata {
		edges = append(edges, user.EdgeMetadata)
	}
	if m.cleared_Sessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.cleared_Release {
		edges = append(edges, user.EdgeRelease)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeLicense:
		return m.cleared_License
	case user.EdgeStatistics:
		return m.cleared_Statistics
	case user.EdgeApp:
		return m.cleared_App
	case user.EdgeMetadata:
		return m.cleared_Metadata
	case user.EdgeSessions:
		return m.cleared_Sessions
	case user.EdgeRelease:
		return m.cleared_Release
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeLicense:
		m.ClearLicense()
		return nil
	case user.EdgeApp:
		m.ClearApp()
		return nil
	case user.EdgeMetadata:
		m.ClearMetadata()
		return nil
	case user.EdgeRelease:
		m.ClearRelease()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeLicense:
		m.ResetLicense()
		return nil
	case user.EdgeStatistics:
		m.ResetStatistics()
		return nil
	case user.EdgeApp:
		m.ResetApp()
		return nil
	case user.EdgeMetadata:
		m.ResetMetadata()
		return nil
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeRelease:
		m.ResetRelease()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
